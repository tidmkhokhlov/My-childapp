import {
  require_react_dom
} from "./chunk-LVYSNMLB.js";
import {
  require_jsx_runtime
} from "./chunk-F7DWQTFG.js";
import {
  Icon12Circle,
  Icon12Dropdown,
  Icon12OnlineMobile,
  Icon16Cancel,
  Icon16Chevron,
  Icon16Clear,
  Icon16Done,
  Icon16Dropdown,
  Icon16SearchOutline,
  Icon16Spinner,
  Icon20CalendarOutline,
  Icon20Cancel,
  Icon20CheckBoxIndetermanate,
  Icon20CheckBoxOff,
  Icon20CheckBoxOn,
  Icon20CheckCircleOff,
  Icon20CheckCircleOn,
  Icon20ChevronLeftOutline,
  Icon20ChevronRightOutline,
  Icon20ChevronUp,
  Icon20Dropdown,
  Icon24ArrowLeftOutline,
  Icon24Attach,
  Icon24Cancel,
  Icon24CancelOutline,
  Icon24CheckBoxOff,
  Icon24CheckBoxOn,
  Icon24CheckCircleOff,
  Icon24CheckCircleOn,
  Icon24CheckCircleOutline,
  Icon24Chevron,
  Icon24ChevronCompactLeft,
  Icon24ChevronCompactRight,
  Icon24ChevronDown,
  Icon24ChevronUp,
  Icon24Dismiss,
  Icon24DismissDark,
  Icon24DoneOutline,
  Icon24PenOutline,
  Icon24Reorder,
  Icon24ReorderIos,
  Icon24Send,
  Icon24Spinner,
  Icon28AddCircleOutline,
  Icon28ArrowLeftOutline,
  Icon28AttachOutline,
  Icon28CancelOutline,
  Icon28CheckCircleOutline,
  Icon28ChevronBack,
  Icon28ChevronLeftOutline,
  Icon28ChevronRightCircle,
  Icon28DoneOutline,
  Icon28EditOutline,
  Icon28Send,
  Icon32Spinner,
  Icon44Spinner,
  Icon48WritebarDone,
  Icon48WritebarSend,
  IconAppearanceProvider,
  _class_call_check,
  _create_class,
  _define_property,
  _object_spread,
  _object_spread_props,
  _object_without_properties
} from "./chunk-C4Z2UXD6.js";
import {
  require_react
} from "./chunk-GK2R5YRN.js";
import {
  __publicField,
  __toESM
} from "./chunk-EQCVQC35.js";

// node_modules/@vkontakte/vkui/dist/components/AppRoot/AppRoot.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var React12 = __toESM(require_react());

// node_modules/@vkontakte/vkjs/lib/es6/other/dom.js
var canUseDOM = function() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}();
var canUseEventListeners = function() {
  return canUseDOM && !!window.addEventListener;
}();

// node_modules/@vkontakte/vkjs/lib/es6/animation/animate.js
var animationEvent = function() {
  var obj = {
    supported: false,
    name: "animationend"
  };
  if (canUseDOM) {
    if (typeof AnimationEvent !== "undefined") {
      obj.supported = true;
    } else if (typeof WebKitAnimationEvent !== "undefined") {
      obj.supported = true;
      obj.name = "webkitAnimationEnd";
    }
  }
  return obj;
}();
var transitionEvent = function() {
  var obj = {
    supported: false,
    name: "transitionend"
  };
  if (canUseDOM) {
    if (typeof TransitionEvent !== "undefined") {
      obj.supported = true;
    } else if (typeof WebKitTransitionEvent !== "undefined") {
      obj.supported = true;
      obj.name = "webkitTransitionEnd";
    }
  }
  return obj;
}();

// node_modules/@swc/helpers/esm/_array_like_to_array.js
function _array_like_to_array(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}

// node_modules/@swc/helpers/esm/_unsupported_iterable_to_array.js
function _unsupported_iterable_to_array(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _array_like_to_array(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}

// node_modules/@swc/helpers/esm/_type_of.js
function _type_of(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}

// node_modules/@vkontakte/vkjs/lib/es6/async/debounce.js
function debounce(fn, delay) {
  var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : typeof window !== "undefined" ? window : void 0;
  var timeoutId;
  var args;
  var later = function() {
    return fn.apply(context, args);
  };
  var debouncedFn = function() {
    for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {
      a[_key] = arguments[_key];
    }
    args = a;
    clearTimeout(timeoutId);
    timeoutId = setTimeout(later, delay);
  };
  debouncedFn.cancel = function() {
    clearTimeout(timeoutId);
  };
  return debouncedFn;
}

// node_modules/@vkontakte/vkjs/lib/es6/datetime/date.js
var SECONDS_IN_THE_DAY = 86400;
var MILLISECONDS_IN_THE_DAY = SECONDS_IN_THE_DAY * 1e3;

// node_modules/@vkontakte/vkjs/lib/es6/device/IOSDetections.js
function detectIOS(ua) {
  if (!ua) {
    ua = canUseDOM ? navigator.userAgent : "";
  }
  ua = ua.toLowerCase();
  var isIPadOS2 = checkIPadOS(ua);
  var isIPad2 = isIPadOS2 || ua.includes("ipad");
  var isIPhone2 = !isIPad2 && ua.search(/iphone|ipod/) !== -1;
  var isIOS2 = isIPhone2 || isIPad2;
  var iosVersion = isIOS2 && ua.match(/os ([\d_]+) like mac os x/i);
  var iosMajor2 = 0;
  var iosMinor2 = 0;
  if (isIPadOS2) {
    iosMajor2 = 13;
    iosMinor2 = 0;
  } else if (iosVersion) {
    iosVersion = iosVersion[1].split("_");
    iosMajor2 = +iosVersion[0];
    iosMinor2 = +iosVersion[1];
  }
  iosVersion = null;
  var isScrollBasedViewport2 = iosMajor2 < 13 && !(iosMajor2 === 11 && iosMinor2 < 3);
  var isWKWebView2 = isIOS2 && checkWKWebView(ua);
  var isIPhoneX2 = false;
  if (canUseDOM) {
    isIPhoneX2 = isIOS2 && screen.width === 375 && screen.height === 812 && window.devicePixelRatio === 3;
  }
  var isIOSChrome2 = ua.search(/crios/i) !== -1;
  return {
    isIPad: isIPad2,
    isIPhone: isIPhone2,
    isIOS: isIOS2,
    isIPadOS: isIPadOS2,
    iosMajor: iosMajor2,
    iosMinor: iosMinor2,
    isWKWebView: isWKWebView2,
    isScrollBasedViewport: isScrollBasedViewport2,
    isIPhoneX: isIPhoneX2,
    isIOSChrome: isIOSChrome2
  };
}
var detect = detectIOS();
var isIPad = function() {
  return detect.isIPad;
}();
var isIPhone = function() {
  return detect.isIPhone;
}();
var isIOS = function() {
  return detect.isIOS;
}();
var isIPadOS = function() {
  return detect.isIPadOS;
}();
var iosMajor = function() {
  return detect.iosMajor;
}();
var iosMinor = function() {
  return detect.iosMinor;
}();
var isWKWebView = function() {
  return detect.isWKWebView;
}();
var isScrollBasedViewport = function() {
  return detect.isScrollBasedViewport;
}();
var isIPhoneX = function() {
  return detect.isIPhoneX;
}();
var isIOSChrome = function() {
  return detect.isIOSChrome;
}();
function checkWKWebView(ua) {
  if (!canUseDOM) {
    return false;
  }
  var webkit = window.webkit;
  if (webkit && webkit.messageHandlers) {
    return true;
  }
  var lte9 = /constructor/i.test(String(window.HTMLElement));
  var idb = !!window.indexedDB;
  if (ua.includes("safari") && ua.includes("version") && !navigator.standalone) {
  } else if (!idb && lte9 || !(window.statusbar && window.statusbar.visible)) {
  } else if (!lte9 || idb) {
    return true;
  }
  return false;
}
function checkIPadOS(ua) {
  if (!canUseDOM) {
    return false;
  }
  var isNotIOS = !/ipPad|iPhone|iPod/i.test(ua);
  var isMacOS = /Mac OS/i.test(ua);
  return isNotIOS && isMacOS && "ontouchend" in document;
}

// node_modules/@vkontakte/vkjs/lib/es6/device/InputUtils.js
var detect2 = function() {
  var obj = {
    hasMouse: false,
    hasTouchEvents: false,
    hasHover: false,
    hasTouch: false
  };
  if (!canUseDOM) {
    return obj;
  }
  if (isIOS && !isIPadOS) {
    obj.hasMouse = false;
    obj.hasHover = false;
    obj.hasTouchEvents = true;
    obj.hasTouch = true;
  } else {
    obj.hasTouchEvents = "ontouchstart" in document;
    obj.hasTouch = obj.hasTouchEvents || "maxTouchPoints" in navigator && navigator.maxTouchPoints > 0;
    if (obj.hasTouch) {
      var notMobile = !/android|mobile|tablet/i.test(navigator.userAgent);
      obj.hasMouse = typeof window.matchMedia === "function" && window.matchMedia("(pointer)").matches ? matchMedia("(pointer: fine)").matches : notMobile;
      obj.hasHover = obj.hasMouse && (typeof window.matchMedia === "function" && window.matchMedia("(hover)").matches ? matchMedia("(hover: hover)").matches : notMobile);
    } else {
      obj.hasMouse = true;
      obj.hasHover = true;
    }
  }
  return obj;
}();
var hasMouse = function() {
  return detect2.hasMouse;
}();
var hasHover = function() {
  return detect2.hasHover;
}();
var hasTouchEvents = function() {
  return detect2.hasTouchEvents;
}();
var hasTouch = function() {
  return detect2.hasTouch;
}();

// node_modules/@vkontakte/vkjs/lib/es6/other/regexp.js
function escapeRegExp(string) {
  if (string) {
    return string.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1");
  }
  return "";
}

// node_modules/@vkontakte/vkjs/lib/es6/internal/replacer.js
var Replacer = function() {
  "use strict";
  function Replacer2(map) {
    _class_call_check(this, Replacer2);
    _define_property(this, "regexp", void 0);
    _define_property(this, "map", void 0);
    this.map = map;
  }
  _create_class(Replacer2, [
    {
      key: "build",
      value: function build() {
        if (this.regexp) {
          return;
        }
        var groups = Object.keys(this.map).map(escapeRegExp).sort(function(a, b) {
          return b.length - a.length;
        });
        var pattern = "(?:".concat(groups.join("|"), ")");
        this.regexp = new RegExp(pattern, "g");
      }
    },
    {
      key: "replace",
      value: function replace(string) {
        var _this = this;
        if (!string) {
          return "";
        }
        this.build();
        return string.replace(this.regexp, function(substring) {
          return _this.map[substring];
        });
      }
    }
  ]);
  return Replacer2;
}();

// node_modules/@vkontakte/vkjs/lib/es6/internal/codepoints.js
var fromCodePoint = function() {
  return String.fromCodePoint || function(astralCodePoint) {
    return String.fromCharCode(Math.floor((astralCodePoint - 65536) / 1024) + 55296, (astralCodePoint - 65536) % 1024 + 56320);
  };
}();
var codePointAtNative = function() {
  return (
    // eslint-disable-next-line @typescript-eslint/unbound-method
    String.prototype.codePointAt
  );
}();

// node_modules/@vkontakte/vkjs/lib/es6/html/escape.js
var escapeReplacer = new Replacer({
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  "'": "&#39;",
  '"': "&quot;"
});
var unescapeReplacer = new Replacer({
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"'
});
var outOfBoundsChar = String.fromCharCode(65533);

// node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}

// node_modules/@vkontakte/vkjs/lib/es6/other/functions.js
var noop = function() {
};

// node_modules/@vkontakte/vkjs/lib/es6/other/detections.js
var isPassiveEventsSupported = function() {
  var isSupported = false;
  if (canUseEventListeners) {
    try {
      var options = Object.defineProperty({}, "passive", {
        get: function get() {
          isSupported = true;
        }
      });
      window.addEventListener("test", noop, options);
      window.removeEventListener("test", noop, options);
    } catch (e) {
    }
  }
  return isSupported;
}();
function detectSmoothScrollSupport() {
  if (!canUseDOM) {
    return false;
  }
  var isSupported = false;
  try {
    var div = document.createElement("div");
    div.scrollTo({
      top: 0,
      get behavior() {
        isSupported = true;
        return "smooth";
      }
    });
  } catch (e) {
  }
  return isSupported;
}
var isSmoothScrollSupported = detectSmoothScrollSupport();

// node_modules/@vkontakte/vkjs/lib/es6/typecheck/type_checkers.js
function isObjectLike(object) {
  return (typeof object === "undefined" ? "undefined" : _type_of(object)) === "object" && object !== null;
}
function isFunction(object) {
  return typeof object === "function";
}

// node_modules/@vkontakte/vkjs/lib/es6/other/equal.js
function isEqual(value, other) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  if (isObjectLike(value) && isObjectLike(other)) {
    if (Object.keys(value).length !== Object.keys(other).length) {
      return false;
    }
    for (var prop in value) {
      if (value.hasOwnProperty(prop) && other.hasOwnProperty(prop)) {
        if (!isEqual(value[prop], other[prop])) {
          return false;
        }
      } else {
        return false;
      }
    }
    return true;
  }
  return false;
}

// node_modules/@swc/helpers/esm/_instanceof.js
function _instanceof(left, right) {
  if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
    return !!right[Symbol.hasInstance](left);
  } else return left instanceof right;
}

// node_modules/@vkontakte/vkjs/lib/es6/other/react_utils.js
function hasReactNode(value) {
  return value !== void 0 && value !== false && value !== null && value !== "";
}
function isPrimitiveReactNode(node) {
  return typeof node === "string" || typeof node === "number";
}

// node_modules/@vkontakte/vkjs/lib/es6/other/storage.js
var CustomStorage = function() {
  "use strict";
  function CustomStorage2() {
    var _this = this;
    _class_call_check(this, CustomStorage2);
    _define_property(this, "data", {});
    _define_property(this, "getItem", function(key) {
      return _this.data.hasOwnProperty(key) ? _this.data[key] : null;
    });
    _define_property(this, "keys", function() {
      return Object.keys(_this.data);
    });
  }
  _create_class(CustomStorage2, [
    {
      key: "setItem",
      value: function setItem(key, val) {
        this.data[key] = String(val);
      }
    },
    {
      key: "removeItem",
      value: function removeItem(id) {
        delete this.data[id];
      }
    },
    {
      key: "clear",
      value: function clear() {
        this.data = {};
      }
    },
    {
      key: "length",
      get: function get() {
        return Object.keys(this.data).length;
      }
    },
    {
      key: "key",
      value: function key(index2) {
        return Object.keys(this.data)[index2];
      }
    }
  ]);
  return CustomStorage2;
}();

// node_modules/@vkontakte/vkjs/lib/es6/text/numbers.js
function leadingZero2(number) {
  if (number >= 10) {
    return String(number);
  } else {
    return "0" + String(number);
  }
}

// node_modules/@vkontakte/vkjs/lib/es6/text/transliteration.js
var transliterationDictVKRusToEng = {
  "А": "A",
  "Б": "B",
  "В": "V",
  "Г": "G",
  "¥": "G",
  "Д": "D",
  "Е": "E",
  "Є": "Ye",
  "Ё": "Yo",
  "Ж": "Zh",
  "З": "Z",
  "И": "I",
  "Ї": "Yi",
  "²": "I",
  "Й": "J",
  "К": "K",
  "Л": "L",
  "М": "M",
  "Н": "N",
  "О": "O",
  "П": "P",
  "Р": "R",
  "С": "S",
  "Т": "T",
  "У": "U",
  "Ў": "W",
  "Ф": "F",
  "Х": "Kh",
  "Ц": "Ts",
  "Ч": "Ch",
  "Ш": "Sh",
  "Щ": "Sch",
  "Ы": "Y",
  "Ый": "Y",
  "Э": "E",
  "Ю": "Yu",
  "Я": "Ya",
  "а": "a",
  "б": "b",
  "в": "v",
  "г": "g",
  "´": "g",
  "д": "d",
  "е": "e",
  "є": "ye",
  "ё": "yo",
  "ж": "zh",
  "з": "z",
  "ия": "ia",
  "ий": "y",
  "и": "i",
  "й": "y",
  "ї": "yi",
  "³": "i",
  "кс": "x",
  "к": "k",
  "л": "l",
  "м": "m",
  "н": "n",
  "о": "o",
  "п": "p",
  "р": "r",
  "с": "s",
  "т": "t",
  "у": "u",
  "ў": "w",
  "ф": "f",
  "х": "kh",
  "ц": "ts",
  "ч": "ch",
  "ш": "sh",
  "щ": "sch",
  "ъ": "",
  "ый": "y",
  "ы": "y",
  "ь": "",
  "ье": "ye",
  "ьо": "io",
  "э": "e",
  "ю": "yu",
  "я": "ya"
};
var transliterationDictVKEngToRus = {
  "a": "а",
  "b": "б",
  "v": "в",
  "g": "г",
  "d": "д",
  "e": "е",
  "z": "з",
  "i": "и",
  "j": "й",
  "k": "к",
  "l": "л",
  "m": "м",
  "n": "н",
  "o": "о",
  "p": "п",
  "r": "р",
  "s": "с",
  "t": "т",
  "u": "у",
  "f": "ф",
  "h": "х",
  "c": "ц",
  "y": "ы",
  "A": "А",
  "B": "Б",
  "V": "В",
  "G": "Г",
  "D": "Д",
  "E": "Е",
  "Z": "З",
  "I": "И",
  "J": "Й",
  "K": "К",
  "L": "Л",
  "M": "М",
  "N": "Н",
  "O": "О",
  "P": "П",
  "R": "Р",
  "S": "С",
  "T": "Т",
  "U": "У",
  "F": "Ф",
  "H": "Х",
  "C": "Ц",
  "Y": "Ы",
  "w": "в",
  "q": "к",
  "x": "кс",
  "W": "В",
  "Q": "К",
  "X": "КС",
  "yo": "ё",
  "zh": "ж",
  "kh": "х",
  "ts": "ц",
  "ch": "ч",
  "sch": "щ",
  "shch": "щ",
  "sh": "ш",
  "eh": "э",
  "yu": "ю",
  "ya": "я",
  "YO": "Ё",
  "ZH": "Ж",
  "KH": "Х",
  "TS": "Ц",
  "CH": "Ч",
  "SCH": "Щ",
  "SHCH": "Щ",
  "SH": "Ш",
  "EH": "Э",
  "YU": "Ю",
  "YA": "Я",
  "'": "ь"
};
var transliterationDictGostLetterCombinationsRu = {
  "А": "A",
  "Б": "B",
  "В": "V",
  "Г": "G",
  "Д": "D",
  "Е": "E",
  "Ё": "Yo",
  "Ж": "Zh",
  "З": "Z",
  "И": "I",
  "Й": "J",
  "К": "K",
  "Л": "L",
  "М": "M",
  "Н": "N",
  "О": "O",
  "П": "P",
  "Р": "R",
  "С": "S",
  "Т": "T",
  "У": "U",
  "Ф": "F",
  "Х": "X",
  "Ц": "Cz",
  "Ч": "Ch",
  "Ш": "Sh",
  "Щ": "Shh",
  "Ъ": "``",
  "Ы": "Y`",
  "Ь": "`",
  "Э": "E`",
  "Ю": "Yu",
  "Я": "Ya",
  "а": "a",
  "б": "b",
  "в": "v",
  "г": "g",
  "д": "d",
  "е": "e",
  "ё": "yo",
  "ж": "zh",
  "з": "z",
  "и": "i",
  "й": "j",
  "к": "k",
  "л": "l",
  "м": "m",
  "н": "n",
  "о": "o",
  "п": "p",
  "р": "r",
  "с": "s",
  "т": "t",
  "у": "u",
  "ф": "f",
  "х": "x",
  "ц": "cz",
  "ч": "ch",
  "ш": "sh",
  "щ": "shh",
  "ъ": "``",
  "ы": "y`",
  "ь": "`",
  "э": "e`",
  "ю": "yu",
  "я": "ya",
  "’": "'",
  // апостроф
  "Ѣ": "ye",
  // ять
  "Ѳ": "fh",
  //	фита
  "Ѵ": "yh"
};
var Transliterator = function() {
  "use strict";
  function Transliterator2(dict) {
    _class_call_check(this, Transliterator2);
    _define_property(this, "replacer", void 0);
    this.replacer = new Replacer(dict);
  }
  _create_class(Transliterator2, [
    {
      /**
      * Производит транслитерацию текста
      */
      key: "transliteration",
      value: function transliteration(text) {
        return this.replacer.replace(text);
      }
    }
  ]);
  return Transliterator2;
}();
var transliteratorVKRusToEng = new Transliterator(transliterationDictVKRusToEng);
var transliteratorVKEngToRus = new Transliterator(transliterationDictVKEngToRus);
var transliteratorGostLetterCombinationsRu = new Transliterator(transliterationDictGostLetterCombinationsRu);

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivity.js
var React2 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/AdaptivityProvider/AdaptivityContext.js
var React = __toESM(require_react());
var AdaptivityContext = React.createContext({});

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivity.js
var useAdaptivity = () => {
  return React2.useContext(AdaptivityContext);
};

// node_modules/@vkontakte/vkui/dist/hooks/useKeyboardInputTracker.js
var React5 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/children.js
var import_react = __toESM(require_react());
var childToString = (child) => {
  if (typeof child === "undefined" || child === null || typeof child === "boolean") {
    return "";
  }
  if (JSON.stringify(child) === "{}") {
    return "";
  }
  return child.toString();
};
var getTextFromChildren = (children) => {
  if (!(children instanceof Array) && !(0, import_react.isValidElement)(children)) {
    return childToString(children);
  }
  return import_react.Children.toArray(children).reduce((text, child) => {
    let newText = "";
    const isValidElementResult = (0, import_react.isValidElement)(child);
    const hasChildren = isValidElementResult && "children" in child.props;
    if (isValidElementResult && hasChildren) {
      newText = getTextFromChildren(child.props.children);
    } else if (isValidElementResult && !hasChildren) {
      newText = "";
    } else {
      newText = childToString(child);
    }
    return text.concat(newText);
  }, "");
};

// node_modules/@vkontakte/vkui/dist/lib/accessibility.js
var FOCUSABLE_ELEMENTS_LIST = [
  "a[href]",
  "area[href]",
  'input:not([disabled]):not([hidden]):not([type="hidden"]):not([aria-hidden])',
  "select:not([disabled]):not([hidden]):not([aria-hidden])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "iframe",
  "audio",
  "video",
  "[contenteditable]",
  '[tabindex]:not([tabindex="-1"])'
];
var Keys = {
  ENTER: "Enter",
  SPACE: "Space",
  TAB: "Tab",
  ESCAPE: "Escape",
  HOME: "Home",
  END: "End",
  DELETE: "Delete",
  BACKSPACE: "Backspace",
  ARROW_LEFT: "ArrowLeft",
  ARROW_RIGHT: "ArrowRight",
  ARROW_UP: "ArrowUp",
  ARROW_DOWN: "ArrowDown",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown"
};
var EVENT_KEY_TO_COMMON_KEY_MAP = /* @__PURE__ */ new Map([
  [
    "Enter",
    Keys.ENTER
  ],
  [
    "Space",
    Keys.SPACE
  ],
  [
    "Spacebar",
    Keys.SPACE
  ],
  [
    " ",
    Keys.SPACE
  ],
  [
    "Tab",
    Keys.TAB
  ],
  [
    "Escape",
    Keys.ESCAPE
  ],
  [
    "Home",
    Keys.HOME
  ],
  [
    "End",
    Keys.END
  ],
  [
    "ArrowLeft",
    Keys.ARROW_LEFT
  ],
  [
    "ArrowRight",
    Keys.ARROW_RIGHT
  ],
  [
    "ArrowUp",
    Keys.ARROW_UP
  ],
  [
    "ArrowDown",
    Keys.ARROW_DOWN
  ],
  [
    "PageUp",
    Keys.PAGE_UP
  ],
  [
    "PageDown",
    Keys.PAGE_DOWN
  ]
]);
function pressedKey(event) {
  const foundKey = EVENT_KEY_TO_COMMON_KEY_MAP.get(event.key);
  return foundKey ? foundKey : null;
}
var FOCUS_ALLOW_LIST_KEYS = /* @__PURE__ */ new Set([
  Keys.TAB,
  Keys.ARROW_LEFT,
  Keys.ARROW_RIGHT,
  Keys.ARROW_UP,
  Keys.ARROW_DOWN,
  Keys.BACKSPACE,
  Keys.DELETE
]);
function isKeyboardFocusingStarted(event) {
  return FOCUS_ALLOW_LIST_KEYS.has(event.key);
}
function shouldTriggerClickOnEnterOrSpace(e) {
  const el = e.target;
  const { tagName } = el;
  const role = el.getAttribute("role");
  const isValidKeyboardEventTarget = el.isContentEditable !== true && tagName !== "INPUT" && tagName !== "TEXTAREA" && (role === "button" || role === "link" || role === "menuitem");
  const isNativeAnchorEl = tagName === "A" && el.hasAttribute("href");
  const keyPressed = pressedKey(e);
  return isValidKeyboardEventTarget && // trigger buttons on Space
  (keyPressed === Keys.SPACE && role === "button" || // trigger non-native links and buttons on Enter
  keyPressed === Keys.ENTER && !isNativeAnchorEl);
}
var injectAriaExpandedPropByRole = (props, state, role) => {
  switch (role) {
    case "dialog":
    case "menu":
    case "application":
    case "tab":
    case "menuitem":
    case "treeitem":
    case "gridcell":
      props["aria-expanded"] = state;
      return props;
    default:
      return props;
  }
};
function hasAccessibleName({ "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, title, children }) {
  if (ariaLabel || ariaLabelledBy || title) {
    return true;
  }
  const accessibleLabel = getTextFromChildren(children);
  if (accessibleLabel.trim() !== "") {
    return true;
  }
  return false;
}
var getHorizontalFocusGoTo = (keys) => {
  switch (keys) {
    case Keys.ARROW_UP:
    case Keys.ARROW_LEFT:
      return "prev";
    case Keys.ARROW_DOWN:
    case Keys.ARROW_RIGHT:
      return "next";
  }
};

// node_modules/@vkontakte/vkui/dist/lib/dom.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var React3 = __toESM(require_react());

// node_modules/@swc/helpers/esm/_async_to_generator.js
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) resolve(value);
  else Promise.resolve(value).then(_next, _throw);
}
function _async_to_generator(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}

// node_modules/tslib/tslib.es6.mjs
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@vkontakte/vkui-floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  var reference = _ref.reference, floating = _ref.floating;
  var sideAxis = getSideAxis(placement);
  var alignmentAxis = getAlignmentAxis(placement);
  var alignLength = getAxisLength(alignmentAxis);
  var side = getSide(placement);
  var isVertical = sideAxis === "y";
  var commonX = reference.x + reference.width / 2 - floating.width / 2;
  var commonY = reference.y + reference.height / 2 - floating.height / 2;
  var commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  var coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = function() {
  var _ref = _async_to_generator(function(reference, floating, config) {
    var _config_placement, placement, _config_strategy, strategy, _config_middleware, middleware, platform3, validMiddleware, rtl, rects, _computeCoordsFromPlacement, x, y, statefulPlacement, middlewareData, resetCount, i, _validMiddleware_i, name, fn, _ref2, nextX, nextY, data, reset, _tmp, ref;
    return __generator(this, function(_state) {
      switch (_state.label) {
        case 0:
          _config_placement = config.placement, placement = _config_placement === void 0 ? "bottom" : _config_placement, _config_strategy = config.strategy, strategy = _config_strategy === void 0 ? "absolute" : _config_strategy, _config_middleware = config.middleware, middleware = _config_middleware === void 0 ? [] : _config_middleware, platform3 = config.platform;
          validMiddleware = middleware.filter(Boolean);
          return [
            4,
            platform3.isRTL == null ? void 0 : platform3.isRTL(floating)
          ];
        case 1:
          rtl = _state.sent();
          return [
            4,
            platform3.getElementRects({
              reference,
              floating,
              strategy
            })
          ];
        case 2:
          rects = _state.sent();
          _computeCoordsFromPlacement = computeCoordsFromPlacement(rects, placement, rtl), x = _computeCoordsFromPlacement.x, y = _computeCoordsFromPlacement.y;
          statefulPlacement = placement;
          middlewareData = {};
          resetCount = 0;
          i = 0;
          _state.label = 3;
        case 3:
          if (!(i < validMiddleware.length)) return [
            3,
            11
          ];
          _validMiddleware_i = validMiddleware[i], name = _validMiddleware_i.name, fn = _validMiddleware_i.fn;
          return [
            4,
            fn({
              x,
              y,
              initialPlacement: placement,
              placement: statefulPlacement,
              strategy,
              middlewareData,
              rects,
              platform: platform3,
              elements: {
                reference,
                floating
              }
            })
          ];
        case 4:
          _ref2 = _state.sent(), nextX = _ref2.x, nextY = _ref2.y, data = _ref2.data, reset = _ref2.reset;
          x = nextX != null ? nextX : x;
          y = nextY != null ? nextY : y;
          middlewareData = _object_spread_props(_object_spread({}, middlewareData), _define_property({}, name, _object_spread({}, middlewareData[name], data)));
          if (!(reset && resetCount <= 50)) return [
            3,
            10
          ];
          resetCount++;
          if (!((typeof reset === "undefined" ? "undefined" : _type_of(reset)) === "object")) return [
            3,
            9
          ];
          if (reset.placement) {
            statefulPlacement = reset.placement;
          }
          if (!reset.rects) return [
            3,
            8
          ];
          if (!(reset.rects === true)) return [
            3,
            6
          ];
          return [
            4,
            platform3.getElementRects({
              reference,
              floating,
              strategy
            })
          ];
        case 5:
          _tmp = _state.sent();
          return [
            3,
            7
          ];
        case 6:
          _tmp = reset.rects;
          _state.label = 7;
        case 7:
          rects = _tmp;
          _state.label = 8;
        case 8:
          ref = computeCoordsFromPlacement(rects, statefulPlacement, rtl), x = ref.x, y = ref.y, ref;
          _state.label = 9;
        case 9:
          i = -1;
          _state.label = 10;
        case 10:
          i++;
          return [
            3,
            3
          ];
        case 11:
          return [
            2,
            {
              x,
              y,
              placement: statefulPlacement,
              strategy,
              middlewareData
            }
          ];
      }
    });
  });
  return function computePosition4(reference, floating, config) {
    return _ref.apply(this, arguments);
  };
}();

// node_modules/@vkontakte/vkui-floating-ui/utils/dist/floating-ui.utils.dom.mjs
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return _instanceof(value, Node) || _instanceof(value, getWindow(value).Node);
}
function isElement(value) {
  return _instanceof(value, Element) || _instanceof(value, getWindow(value).Element);
}
function isHTMLElement(value) {
  return _instanceof(value, HTMLElement) || _instanceof(value, getWindow(value).HTMLElement);
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return _instanceof(value, ShadowRoot) || _instanceof(value, getWindow(value).ShadowRoot);
}
function isOverflowElement(element) {
  var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY, display = _getComputedStyle.display;
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && ![
    "inline",
    "contents"
  ].includes(display);
}
function isLastTraversableNode(node) {
  return [
    "html",
    "body",
    "#document"
  ].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  var result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  var parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}

// node_modules/@vkontakte/vkui/dist/lib/dom.js
var getDOM = () => ({
  window: canUseDOM ? window : void 0,
  document: canUseDOM ? document : void 0
});
var DOMContext = React3.createContext(getDOM());
var useDOM = () => {
  return React3.useContext(DOMContext);
};
var isWindow = (node) => {
  return node !== null && node !== void 0 && "navigator" in node;
};
var isBody = (node) => {
  return node !== null && node !== void 0 && "tagName" in node && node.tagName === "BODY";
};
var isDocumentElement = (node) => {
  return node !== null && node !== void 0 && "tagName" in node && node.tagName === "HTML";
};
function withDOM(Component3) {
  const WithDOM = (props) => {
    const dom = useDOM();
    return (0, import_jsx_runtime.jsx)(Component3, _object_spread({}, props, dom));
  };
  return WithDOM;
}
function blurActiveElement(document1) {
  if (document1 && document1.activeElement) {
    document1.activeElement.blur();
  }
}
var TRANSFORM_DEFAULT_VALUES = [
  "none",
  "initial",
  "inherit",
  "unset"
];
var WILL_CHANGE_DEFAULT_VALUES = [
  "auto",
  "initial",
  "inherit",
  "unset"
];
function getTransformedParentCoords(element) {
  let parentNode = element.parentNode;
  while (parentNode !== null) {
    if (isHTMLElement(parentNode)) {
      const { transform, willChange } = getComputedStyle(parentNode);
      if (!TRANSFORM_DEFAULT_VALUES.includes(transform) || !WILL_CHANGE_DEFAULT_VALUES.includes(willChange)) {
        const { x, y } = parentNode.getBoundingClientRect();
        return {
          x,
          y
        };
      }
    }
    parentNode = parentNode.parentNode;
  }
  return {
    x: 0,
    y: 0
  };
}
var getBoundingClientRect = (node, isFixedStrategy = false) => {
  const element = isWindow(node) ? node.document.documentElement : node;
  const clientRect = element.getBoundingClientRect();
  if (isDocumentElement(element)) {
    clientRect.height = element.clientHeight;
  }
  let offsetX = 0;
  let offsetY = 0;
  if (isFixedStrategy) {
    const { x, y } = getTransformedParentCoords(element);
    offsetX = x;
    offsetY = y;
  }
  return rectToClientRect({
    x: clientRect.left - offsetX,
    y: clientRect.top - offsetY,
    width: clientRect.width,
    height: clientRect.height
  });
};
var getRelativeBoundingClientRect = (parent, child) => {
  const parentRect = getBoundingClientRect(parent);
  const childRect = getBoundingClientRect(child);
  return rectToClientRect({
    x: childRect.left - parentRect.left,
    y: childRect.top - parentRect.top,
    width: childRect.width,
    height: childRect.height
  });
};
var getNearestOverflowAncestor2 = (childEl) => {
  const foundAncestor = getNearestOverflowAncestor(childEl);
  return isBody(foundAncestor) ? getWindow(foundAncestor) : isHTMLElement(childEl) ? foundAncestor : null;
};
var getScrollHeight = (node) => {
  return isWindow(node) ? node.document.documentElement.scrollHeight : node.scrollHeight;
};
var getScrollRect = (node) => {
  const window1 = isElement(node) ? getWindow(node) : node;
  const scrollElRect = getBoundingClientRect(node);
  const edgeTop = window1.scrollY + scrollElRect.top;
  const edgeBottom = edgeTop + scrollElRect.height;
  const y = [
    edgeTop,
    edgeBottom
  ];
  return {
    relative: scrollElRect,
    edges: {
      y
    }
  };
};
var getDocumentBody = (node) => getWindow(node).document.body;
var getActiveElementByAnotherElement = (el) => el ? el.ownerDocument.activeElement : null;
var contains = (parent, child) => {
  return parent && child ? parent.contains(child) : false;
};
var getFirstTouchEventData = (event) => {
  let dataRaw = function resolveData() {
    switch (event.type) {
      case "touchend":
        return event.changedTouches[0];
      case "touchstart":
      case "touchmove":
      case "touchcancel":
        return event.touches[0];
      case "mousedown":
      case "mousemove":
      case "mouseup":
      case "mouseleave":
        return event;
      default:
        return {
          screenX: 0,
          screenY: 0,
          clientX: 0,
          clientY: 0,
          pageX: 0,
          pageY: 0
        };
    }
  }();
  if (false) {
    dataRaw = dataRaw ? dataRaw : {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0
    };
  }
  return {
    screenX: dataRaw.screenX || 0,
    screenY: dataRaw.screenY || 0,
    clientX: dataRaw.clientX || 0,
    clientY: dataRaw.clientY || 0,
    pageX: dataRaw.pageX || 0,
    pageY: dataRaw.pageY || 0
  };
};
var initializeBrowserGesturePreventionEffect = (window1) => {
  const options = {
    passive: false
  };
  const handleWindowTouchMove = (event) => {
    event.preventDefault();
    event.stopPropagation();
  };
  window1.document.documentElement.classList.add("vkui--disable-overscroll-behavior");
  window1.addEventListener("touchmove", handleWindowTouchMove, options);
  return function dispose() {
    window1.document.documentElement.classList.remove("vkui--disable-overscroll-behavior");
    window1.removeEventListener("touchmove", handleWindowTouchMove, options);
  };
};

// node_modules/@vkontakte/vkui/dist/lib/useIsomorphicLayoutEffect.js
var React4 = __toESM(require_react());
var useIsomorphicLayoutEffect = canUseDOM ? React4.useLayoutEffect : React4.useEffect;

// node_modules/@vkontakte/vkui/dist/hooks/useKeyboardInputTracker.js
var ENABLE_KEYBOARD_INPUT_EVENT_NAME = "enableKeyboardInput";
var DISABLE_KEYBOARD_INPUT_EVENT_NAME = "disableKeyboardInput";
var EVENT_OPTIONS = {
  passive: true,
  capture: true
};
function useKeyboardInputTracker() {
  const { document: document2 } = useDOM();
  const keyboardFocusingStartedRef = React5.useRef(false);
  useIsomorphicLayoutEffect(() => {
    if (!document2) {
      return;
    }
    const handleKeydown = (event) => {
      if (isKeyboardFocusingStarted(event)) {
        keyboardFocusingStartedRef.current = true;
      }
    };
    const handleCustomEnableKeyboardEvent = () => {
      keyboardFocusingStartedRef.current = true;
    };
    const handleCustomDisableKeyboardEvent = () => {
      keyboardFocusingStartedRef.current = false;
    };
    document2.addEventListener("keydown", handleKeydown, EVENT_OPTIONS);
    document2.addEventListener(ENABLE_KEYBOARD_INPUT_EVENT_NAME, handleCustomEnableKeyboardEvent, EVENT_OPTIONS);
    document2.addEventListener(DISABLE_KEYBOARD_INPUT_EVENT_NAME, handleCustomDisableKeyboardEvent, EVENT_OPTIONS);
    document2.addEventListener("mousedown", handleCustomDisableKeyboardEvent, EVENT_OPTIONS);
    document2.addEventListener("touchstart", handleCustomDisableKeyboardEvent, EVENT_OPTIONS);
    return () => {
      document2.removeEventListener("keydown", handleKeydown, EVENT_OPTIONS);
      document2.removeEventListener(ENABLE_KEYBOARD_INPUT_EVENT_NAME, handleCustomEnableKeyboardEvent, EVENT_OPTIONS);
      document2.removeEventListener(DISABLE_KEYBOARD_INPUT_EVENT_NAME, handleCustomDisableKeyboardEvent, EVENT_OPTIONS);
      document2.removeEventListener("mousedown", handleCustomDisableKeyboardEvent, EVENT_OPTIONS);
      document2.removeEventListener("touchstart", handleCustomDisableKeyboardEvent, EVENT_OPTIONS);
    };
  }, [
    document2
  ]);
  return keyboardFocusingStartedRef;
}

// node_modules/@vkontakte/vkui/dist/hooks/useObjectMemo.js
var React6 = __toESM(require_react());
function useObjectMemo(object) {
  const cache = React6.useRef(object);
  if (!isEqual(cache.current, object)) {
    cache.current = object;
  }
  return cache.current;
}

// node_modules/@vkontakte/vkui/dist/lib/tokens/constants.js
var DEFAULT_TOKENS_CLASS_NAMES = {
  android: {
    light: "vkui--vkBase--light",
    dark: "vkui--vkBase--dark"
  },
  ios: {
    light: "vkui--vkIOS--light",
    dark: "vkui--vkIOS--dark"
  },
  vkcom: {
    light: "vkui--vkCom--light",
    dark: "vkui--vkCom--dark"
  }
};

// node_modules/@vkontakte/vkui/dist/lib/tokens/useTokenClassName.js
var React8 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ConfigProvider/ConfigProviderContext.js
var React7 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/browser.js
var memoized = {};
function computeBrowserInfo(userAgent = "") {
  if (memoized[userAgent]) {
    return memoized[userAgent];
  }
  const browserInfo = {
    userAgent,
    system: "",
    systemVersion: null
  };
  const { isIOS: isIOS2, iosMajor: iosMajor2, iosMinor: iosMinor2 } = detectIOS(userAgent);
  if (isIOS2) {
    browserInfo.system = "ios";
    browserInfo.systemVersion = {
      major: iosMajor2,
      minor: iosMinor2
    };
  }
  memoized[userAgent] = browserInfo;
  return browserInfo;
}
function mediaQueryNull(query) {
  return {
    matches: false,
    media: query,
    onchange: noop,
    addListener: noop,
    removeListener: noop,
    addEventListener: noop,
    removeEventListener: noop,
    dispatchEvent() {
      return false;
    }
  };
}

// node_modules/@vkontakte/vkui/dist/lib/platform.js
var Platform = {
  ANDROID: "android",
  IOS: "ios",
  VKCOM: "vkcom"
};
function platform(browserInfo) {
  if (!browserInfo) {
    browserInfo = computeBrowserInfo();
  }
  return browserInfo.system === "ios" ? "ios" : "android";
}

// node_modules/@vkontakte/vkui/dist/components/ConfigProvider/ConfigProviderContext.js
var ConfigProviderContext = React7.createContext({
  hasCustomPanelHeaderAfter: false,
  customPanelHeaderAfterMinWidth: 90,
  isWebView: false,
  transitionMotionEnabled: true,
  platform: platform(),
  appearance: void 0,
  tokensClassNames: DEFAULT_TOKENS_CLASS_NAMES,
  locale: "ru"
});
var useConfigProvider = () => React7.useContext(ConfigProviderContext);

// node_modules/@vkontakte/vkui/dist/lib/appearance/index.js
var DEFAULT_APPEARANCE = "light";
var Appearance = {
  DARK: "dark",
  LIGHT: "light"
};

// node_modules/@vkontakte/vkui/dist/lib/tokens/useTokenClassName.js
var isTokensClassNamesForPlatforms = (tokensClassNames) => Platform.ANDROID in tokensClassNames || Platform.IOS in tokensClassNames || Platform.VKCOM in tokensClassNames;
var getTokenClassNameByAppearance = (appearance, tokensClassNames) => tokensClassNames ? tokensClassNames[appearance] : void 0;
var getAppearanceTokenClassNameByPlatform = (platform3, tokensClassNames) => tokensClassNames ? tokensClassNames[platform3] : void 0;
var useTokensClassName = () => {
  const { platform: platform3, appearance = DEFAULT_APPEARANCE, tokensClassNames } = React8.useContext(ConfigProviderContext);
  const appearanceSchemeClassName = isTokensClassNamesForPlatforms(tokensClassNames) ? getAppearanceTokenClassNameByPlatform(platform3, tokensClassNames) : tokensClassNames;
  const tokensClassName = getTokenClassNameByAppearance(appearance, appearanceSchemeClassName);
  return tokensClassName ? tokensClassName : DEFAULT_TOKENS_CLASS_NAMES[platform3][appearance];
};

// node_modules/@vkontakte/vkui/dist/lib/tokens/TokensClassProvider.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var React9 = __toESM(require_react());
var InjectTokenClassNameToChild = ({ children }) => {
  const tokensClassName = useTokensClassName();
  return React9.cloneElement(children, {
    className: clsx(tokensClassName, "vkuiTokensClassProvider--default-color", children.props.className)
  });
};
var TokensClassProvider = ({ children }) => {
  return React9.Children.map(children, (child) => {
    if (React9.isValidElement(child)) {
      return (0, import_jsx_runtime2.jsx)(InjectTokenClassNameToChild, {
        children: child
      });
    }
    return child;
  });
};

// node_modules/@vkontakte/vkui/dist/components/AppRoot/AppRootContext.js
var React10 = __toESM(require_react());
var DEFAULT_APP_ROOT_CONTEXT_VALUE = {
  appRoot: React10.createRef(),
  mode: "full",
  portalRoot: React10.createRef(),
  embedded: false,
  keyboardInput: false,
  disablePortal: false
};
var AppRootContext = React10.createContext(DEFAULT_APP_ROOT_CONTEXT_VALUE);

// node_modules/@vkontakte/vkui/dist/components/AppRoot/ScrollContext.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var React11 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/helpers/math.js
var clamp2 = (value, min3, max3) => Math.max(min3, Math.min(value, max3));
function getDecimalPrecision(num) {
  if (Math.abs(num) < 1) {
    const parts = num.toExponential().split("e-");
    const matissaDecimalPart = parts[0].split(".")[1];
    return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);
  }
  const decimalPart = num.toString().split(".")[1];
  return decimalPart ? decimalPart.length : 0;
}
function roundValueToStep(value, step, min3) {
  const nearest = Math.round((value - min3) / step) * step + min3;
  return Number(nearest.toFixed(getDecimalPrecision(step)));
}
function decimatedClamp(val, min3, max3, step) {
  if (step == null || step <= 0) {
    return clamp2(val, min3, max3);
  }
  const roundedValue = roundValueToStep(val, step, min3);
  return clamp2(roundedValue, min3, max3);
}
function rescale(value, from, to, options = {}) {
  const scaled = (value - from[0]) / (from[1] - from[0]) * (to[1] - to[0]) + to[0];
  return decimatedClamp(scaled, to[0], to[1], options.step);
}

// node_modules/@vkontakte/vkui/dist/components/AppRoot/ScrollContext.js
var clearDisableScrollStyle = (node) => {
  Object.assign(node.style, {
    position: "",
    top: "",
    left: "",
    right: "",
    overflowY: "",
    overflowX: ""
  });
};
var getPageYOffsetWithoutKeyboardHeight = (window2) => {
  const diffOfClientHeightAndViewportHeight = window2.document.documentElement.clientHeight - window2.innerHeight;
  return window2.pageYOffset - diffOfClientHeightAndViewportHeight;
};
var ScrollContext = React11.createContext({
  getScroll: () => ({
    x: 0,
    y: 0
  }),
  scrollTo: noop,
  isScrollLock: false,
  enableScrollLock: noop,
  disableScrollLock: noop
});
var useScroll = () => React11.useContext(ScrollContext);
var GlobalScrollController = ({ children }) => {
  const { window: window2, document: document2 } = useDOM();
  const [isScrollLock, setScrollLock] = React11.useState(false);
  const beforeScrollLockFnSetRef = React11.useRef(/* @__PURE__ */ new Set());
  const getScroll = React11.useCallback((options = {
    compensateKeyboardHeight: true
  }) => ({
    x: window2.pageXOffset,
    y: options.compensateKeyboardHeight ? getPageYOffsetWithoutKeyboardHeight(window2) : window2.pageYOffset
  }), [
    window2
  ]);
  const scrollTo = React11.useCallback((x = 0, y = 0) => {
    window2.scrollTo(x ? clamp2(x, 0, document2.body.scrollWidth - window2.innerWidth) : 0, y ? clamp2(y, 0, document2.body.scrollHeight - window2.innerHeight) : 0);
  }, [
    document2,
    window2
  ]);
  const enableScrollLock = React11.useCallback(() => {
    beforeScrollLockFnSetRef.current.forEach((fn) => {
      fn();
    });
    const scrollY = window2.pageYOffset;
    const scrollX = window2.pageXOffset;
    const overflowY = window2.innerWidth > document2.documentElement.clientWidth ? "scroll" : "";
    const overflowX = window2.innerHeight > document2.documentElement.clientHeight ? "scroll" : "";
    Object.assign(document2.body.style, {
      position: "fixed",
      top: `-${scrollY}px`,
      left: `-${scrollX}px`,
      right: "0",
      overflowY,
      overflowX
    });
    setScrollLock(true);
  }, [
    document2,
    window2
  ]);
  const disableScrollLock = React11.useCallback(() => {
    const scrollY = document2.body.style.top;
    const scrollX = document2.body.style.left;
    clearDisableScrollStyle(document2.body);
    window2.scrollTo(-parseInt(scrollX || "0"), -parseInt(scrollY || "0"));
    setScrollLock(false);
  }, [
    document2,
    window2
  ]);
  const scrollController = React11.useMemo(() => ({
    getScroll,
    scrollTo,
    isScrollLock,
    disableScrollLock,
    enableScrollLock,
    beforeScrollLockFnSetRef
  }), [
    getScroll,
    scrollTo,
    isScrollLock,
    disableScrollLock,
    enableScrollLock
  ]);
  return (0, import_jsx_runtime3.jsx)(ScrollContext.Provider, {
    value: scrollController,
    children
  });
};
var ElementScrollController = ({ elRef, children }) => {
  const [isScrollLock, setScrollLock] = React11.useState(false);
  const beforeScrollLockFnSetRef = React11.useRef(/* @__PURE__ */ new Set());
  const getScroll = React11.useCallback(() => {
    var _elRef_current, _elRef_current1;
    var _elRef_current_scrollLeft, _elRef_current_scrollTop;
    return {
      x: (_elRef_current_scrollLeft = (_elRef_current = elRef.current) === null || _elRef_current === void 0 ? void 0 : _elRef_current.scrollLeft) !== null && _elRef_current_scrollLeft !== void 0 ? _elRef_current_scrollLeft : 0,
      y: (_elRef_current_scrollTop = (_elRef_current1 = elRef.current) === null || _elRef_current1 === void 0 ? void 0 : _elRef_current1.scrollTop) !== null && _elRef_current_scrollTop !== void 0 ? _elRef_current_scrollTop : 0
    };
  }, [
    elRef
  ]);
  const scrollTo = React11.useCallback((x = 0, y = 0) => {
    const el = elRef.current;
    el === null || el === void 0 ? void 0 : el.scrollTo(x ? clamp2(x, 0, el.scrollWidth - el.clientWidth) : 0, y ? clamp2(y, 0, el.scrollHeight - el.clientHeight) : 0);
  }, [
    elRef
  ]);
  const enableScrollLock = React11.useCallback(() => {
    const el = elRef.current;
    if (!el) {
      return;
    }
    beforeScrollLockFnSetRef.current.forEach((fn) => {
      fn();
    });
    const scrollY = el.scrollTop;
    const scrollX = el.scrollLeft;
    const overflowY = el.scrollWidth > el.clientWidth ? "scroll" : "";
    const overflowX = el.scrollHeight > el.clientHeight ? "scroll" : "";
    Object.assign(el.style, {
      position: "absolute",
      top: `-${scrollY}px`,
      left: `-${scrollX}px`,
      right: "0",
      overflowY,
      overflowX
    });
    setScrollLock(true);
  }, [
    elRef
  ]);
  const disableScrollLock = React11.useCallback(() => {
    const el = elRef.current;
    if (!el) {
      return;
    }
    const scrollY = el.style.top;
    const scrollX = el.style.left;
    clearDisableScrollStyle(el);
    el.scrollTo(-parseInt(scrollX || "0"), -parseInt(scrollY || "0"));
    setScrollLock(false);
  }, [
    elRef
  ]);
  const scrollController = React11.useMemo(() => ({
    getScroll,
    scrollTo,
    isScrollLock,
    disableScrollLock,
    enableScrollLock,
    beforeScrollLockFnSetRef
  }), [
    getScroll,
    scrollTo,
    isScrollLock,
    disableScrollLock,
    enableScrollLock
  ]);
  return (0, import_jsx_runtime3.jsx)(ScrollContext.Provider, {
    value: scrollController,
    children
  });
};
var useScrollLock = (enabled = true) => {
  const { enableScrollLock, disableScrollLock, isScrollLock } = useScroll();
  useIsomorphicLayoutEffect(() => {
    if (enabled && !isScrollLock) {
      enableScrollLock();
      return disableScrollLock;
    }
    return noop;
  }, [
    enableScrollLock,
    disableScrollLock,
    enabled
  ]);
};

// node_modules/@vkontakte/vkui/dist/lib/isRefObject.js
var isRefObject = (refObject) => {
  return typeof refObject === "object" && refObject !== null && refObject.hasOwnProperty("current");
};

// node_modules/@vkontakte/vkui/dist/components/AppRoot/helpers.js
function getClassNamesByMode({ mode, layout, tokensClassName, sizeX, sizeY }) {
  const baseClassNames = [
    "vkui__root"
  ];
  const stylesClassNames = [
    tokensClassName
  ];
  if (mode === "full" || mode === "embedded") {
    if (layout) {
      const vkuiLayoutClassNames = {
        card: "vkui--layout-card",
        plain: "vkui--layout-plain"
      };
      stylesClassNames.push(vkuiLayoutClassNames[layout]);
    }
    if (sizeX !== "compact") {
      const vkuiSizeXClassNames = {
        none: "vkui--sizeX-none",
        regular: "vkui--sizeX-regular"
      };
      stylesClassNames.push(vkuiSizeXClassNames[sizeX]);
    }
    if (sizeY !== "regular") {
      const vkuiSizeYClassNames = {
        none: "vkui--sizeY-none",
        compact: "vkui--sizeY-compact"
      };
      stylesClassNames.push(vkuiSizeYClassNames[sizeY]);
    }
    if (mode === "embedded") {
      baseClassNames.push("vkui__root--embedded");
    }
  }
  return [
    baseClassNames,
    stylesClassNames
  ];
}
var getParentElement = (el) => el ? el.parentElement : null;
var extractPortalRootByProp = (portalRootProp) => isRefObject(portalRootProp) ? portalRootProp.current : portalRootProp;
var CUSTOM_PROPERTY_INSET_PREFIX = `--vkui_internal--safe_area_inset_`;
var setSafeAreaInsets = (safeAreaInsets, rootContainer, portalContainer) => {
  if (!safeAreaInsets) {
    return () => void 0;
  }
  for (const key in safeAreaInsets) {
    if (safeAreaInsets.hasOwnProperty(key) && typeof safeAreaInsets[key] === "number") {
      const propertyKey = `${CUSTOM_PROPERTY_INSET_PREFIX}${key}`;
      const propertyValue = safeAreaInsets[key];
      rootContainer.style.setProperty(propertyKey, `${propertyValue}px`);
      if (portalContainer) {
        portalContainer.style.setProperty(propertyKey, `${propertyValue}px`);
      }
    }
  }
  return function unset() {
    for (const key in safeAreaInsets) {
      if (safeAreaInsets.hasOwnProperty(key)) {
        const propertyKey = `${CUSTOM_PROPERTY_INSET_PREFIX}${key}`;
        rootContainer.style.removeProperty(propertyKey);
        if (portalContainer) {
          portalContainer.style.removeProperty(propertyKey);
        }
      }
    }
  };
};
function getUserSelectModeClassName({ userSelectMode, isWebView, hasPointer }) {
  switch (userSelectMode) {
    case "enabled-with-pointer": {
      if (hasPointer) {
        return null;
      }
      const enableByHasPointerMediaQuery = hasPointer === void 0;
      if (enableByHasPointerMediaQuery) {
        return "vkuiAppRoot--pointer-none";
      }
      return "vkuiAppRoot--user-select-none";
    }
    case "disabled":
      return "vkuiAppRoot--user-select-none";
    case "enabled":
      return null;
    default:
      return isWebView ? "vkuiAppRoot--user-select-none" : null;
  }
}

// node_modules/@vkontakte/vkui/dist/components/AppRoot/AppRoot.js
var AppRoot = (_param) => {
  var { children, mode = "full", scroll = "global", portalRoot: portalRootProp = null, disablePortal = false, disableParentTransformForPositionFixedElements, className, safeAreaInsets: safeAreaInsetsProp, layout, userSelectMode } = _param, props = _object_without_properties(_param, [
    "children",
    "mode",
    "scroll",
    "portalRoot",
    "disablePortal",
    "disableParentTransformForPositionFixedElements",
    "className",
    "safeAreaInsets",
    "layout",
    "userSelectMode"
  ]);
  const { hasPointer, sizeX = "none", sizeY = "none" } = useAdaptivity();
  const tokensClassName = useTokensClassName();
  const safeAreaInsets = useObjectMemo(safeAreaInsetsProp);
  const isKeyboardInputActiveRef = useKeyboardInputTracker();
  const appRootRef = React12.useRef(null);
  const portalRootRef = React12.useRef(null);
  useIsomorphicLayoutEffect(function setupPortalRoot() {
    const portalByProp = portalRootProp ? extractPortalRootByProp(portalRootProp) : null;
    if (portalByProp) {
      portalRootRef.current = portalByProp;
      return function cleanup() {
        portalRootRef.current = null;
      };
    }
    const documentBody = getDocumentBody(appRootRef.current);
    const portal = documentBody.ownerDocument.createElement("div");
    documentBody.appendChild(portal);
    portalRootRef.current = portal;
    return function cleanup() {
      documentBody.removeChild(portal);
      portalRootRef.current = null;
    };
  }, [
    portalRootProp
  ]);
  useIsomorphicLayoutEffect(function setupContainers() {
    if (!appRootRef.current || !portalRootRef.current) {
      return;
    }
    const parentElement = getParentElement(appRootRef.current);
    const documentBody = getDocumentBody(appRootRef.current);
    const documentElement = documentBody.ownerDocument.documentElement;
    const [baseClassNames, stylesClassNames] = getClassNamesByMode({
      mode,
      layout,
      tokensClassName,
      sizeX,
      sizeY
    });
    switch (mode) {
      case "full": {
        if (parentElement) {
          parentElement.classList.add(...baseClassNames);
        }
        documentElement.classList.add(...stylesClassNames, "vkui");
        const unsetSafeAreaInsets = setSafeAreaInsets(safeAreaInsets, documentElement);
        return function cleanup() {
          if (parentElement) {
            parentElement.classList.remove(...baseClassNames);
          }
          documentElement.classList.remove(...stylesClassNames, "vkui");
          unsetSafeAreaInsets();
        };
      }
      case "embedded": {
        if (parentElement) {
          parentElement.classList.add(...baseClassNames, ...stylesClassNames);
          if (!disableParentTransformForPositionFixedElements) {
            parentElement.style.setProperty("transform", "translate3d(0, 0, 0)");
          }
          const unsetSafeAreaInsets = setSafeAreaInsets(safeAreaInsets, parentElement, portalRootRef.current);
          return function cleanup() {
            parentElement.classList.remove(...baseClassNames, ...stylesClassNames);
            if (!disableParentTransformForPositionFixedElements) {
              parentElement.style.removeProperty("transform");
            }
            unsetSafeAreaInsets();
          };
        }
        return;
      }
      case "partial": {
        return;
      }
    }
  }, [
    mode,
    layout,
    disableParentTransformForPositionFixedElements,
    tokensClassName,
    sizeX,
    sizeY,
    safeAreaInsets
  ]);
  const ScrollController = React12.useMemo(() => scroll === "contain" ? ElementScrollController : GlobalScrollController, [
    scroll
  ]);
  const contextValue = React12.useMemo(() => ({
    appRoot: appRootRef,
    portalRoot: portalRootRef,
    embedded: mode === "embedded",
    mode,
    disablePortal,
    layout,
    get keyboardInput() {
      return isKeyboardInputActiveRef.current;
    }
  }), [
    disablePortal,
    isKeyboardInputActiveRef,
    layout,
    mode
  ]);
  const content = (0, import_jsx_runtime4.jsx)(AppRootContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime4.jsx)(ScrollController, {
      elRef: appRootRef,
      children
    })
  });
  const { isWebView } = useConfigProvider();
  const userSelectModeClassName = getUserSelectModeClassName({
    userSelectMode,
    isWebView,
    hasPointer
  });
  return mode === "partial" ? content : (0, import_jsx_runtime4.jsx)("div", _object_spread_props(_object_spread({
    ref: appRootRef,
    className: clsx("vkuiAppRoot", userSelectModeClassName, className)
  }, props), {
    children: content
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/DisplayTitle/DisplayTitle.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime());

// node_modules/@vkontakte/vkui/dist/components/Typography/Typography.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var React14 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/RootComponent/RootComponent.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var React13 = __toESM(require_react());
var RootComponent = (_param) => {
  var { Component: Component3 = "div", baseClassName, className, getRootRef } = _param, restProps = _object_without_properties(_param, [
    "Component",
    "baseClassName",
    "className",
    "getRootRef"
  ]);
  return (0, import_jsx_runtime5.jsx)(Component3, _object_spread({
    ref: getRootRef,
    className: clsx(className, baseClassName, "vkuiRootComponent", restProps.hidden === true && "vkuiRootComponent--hidden")
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Typography.js
var stylesWeight = {
  "1": "vkuiTypography--weight-1",
  "2": "vkuiTypography--weight-2",
  "3": "vkuiTypography--weight-3"
};
var Typography = (_param) => {
  var {
    weight,
    // TODO [>=7]: сделать по умолчанию false (нужен будет кодмод)
    useAccentWeight = true,
    Component: Component3 = "span",
    normalize,
    inline: inline3
  } = _param, restProps = _object_without_properties(_param, [
    "weight",
    "useAccentWeight",
    "Component",
    "normalize",
    "inline"
  ]);
  return (0, import_jsx_runtime6.jsx)(RootComponent, _object_spread({
    Component: Component3,
    baseClassName: clsx("vkuiTypography", normalize && "vkuiTypography--normalize", inline3 && "vkuiTypography--inline", weight && stylesWeight[weight], weight && useAccentWeight && "vkuiTypography--accent")
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/DisplayTitle/DisplayTitle.js
var stylesLevel = {
  "1": "vkuiDisplayTitle--level-1",
  "2": "vkuiDisplayTitle--level-2",
  "3": "vkuiDisplayTitle--level-3",
  "4": "vkuiDisplayTitle--level-4"
};
var sizeYClassNames = {
  none: "vkuiDisplayTitle--sizeY-none",
  compact: "vkuiDisplayTitle--sizeY-compact"
};
var DisplayTitle = (_param) => {
  var { className, level = "1", Component: Component3 = "span", normalize = true, inline: inline3 = false } = _param, restProps = _object_without_properties(_param, [
    "className",
    "level",
    "Component",
    "normalize",
    "inline"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime7.jsx)(Typography, _object_spread({
    Component: Component3,
    normalize,
    inline: inline3,
    className: clsx(className, sizeY !== "regular" && sizeYClassNames[sizeY], stylesLevel[level])
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Title/Title.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var stylesLevel2 = {
  "1": "vkuiTitle--level-1",
  "2": "vkuiTitle--level-2",
  "3": "vkuiTitle--level-3"
};
var sizeYClassNames2 = {
  none: "vkuiTitle--sizeY-none",
  compact: "vkuiTitle--sizeY-compact"
};
var Title = (_param) => {
  var { className, level = "1", Component: Component3 = "span", normalize = true, inline: inline3 = false } = _param, restProps = _object_without_properties(_param, [
    "className",
    "level",
    "Component",
    "normalize",
    "inline"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime8.jsx)(Typography, _object_spread({
    Component: Component3,
    normalize,
    inline: inline3,
    className: clsx(className, sizeY !== "regular" && sizeYClassNames2[sizeY], stylesLevel2[level])
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Headline/Headline.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var stylesLevel3 = {
  "1": "vkuiHeadline--level-1",
  "2": "vkuiHeadline--level-2"
};
var sizeYClassNames3 = {
  none: "vkuiHeadline--sizeY-none",
  compact: "vkuiHeadline--sizeY-compact"
};
var Headline = (_param) => {
  var { className, level = "1", Component: Component3 = "span", normalize = true, inline: inline3 = false } = _param, restProps = _object_without_properties(_param, [
    "className",
    "level",
    "Component",
    "normalize",
    "inline"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime9.jsx)(Typography, _object_spread({
    Component: Component3,
    normalize,
    inline: inline3,
    className: clsx(className, sizeY !== "regular" && sizeYClassNames3[sizeY], stylesLevel3[level])
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Text/Text.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var sizeYClassNames4 = {
  none: "vkuiText--sizeY-none",
  compact: "vkuiText--sizeY-compact"
};
var Text = (_param) => {
  var { className, Component: Component3 = "span", normalize = true, inline: inline3 = false } = _param, restProps = _object_without_properties(_param, [
    "className",
    "Component",
    "normalize",
    "inline"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime10.jsx)(Typography, _object_spread({
    Component: Component3,
    normalize,
    inline: inline3,
    className: clsx(className, "vkuiText", sizeY !== "regular" && sizeYClassNames4[sizeY])
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Paragraph/Paragraph.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var sizeYClassNames5 = {
  none: "vkuiParagraph--sizeY-none",
  compact: "vkuiParagraph--sizeY-compact"
};
var Paragraph = (_param) => {
  var { className, Component: Component3 = "span", normalize = false, inline: inline3 = false } = _param, restProps = _object_without_properties(_param, [
    "className",
    "Component",
    "normalize",
    "inline"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime11.jsx)(Typography, _object_spread({
    Component: Component3,
    normalize,
    inline: inline3,
    className: clsx(className, "vkuiParagraph", sizeY !== "regular" && sizeYClassNames5[sizeY])
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Subhead/Subhead.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
var sizeYClassNames6 = {
  none: "vkuiSubhead--sizeY-none",
  compact: "vkuiSubhead--sizeY-compact"
};
var Subhead = (_param) => {
  var { className, Component: Component3 = "span", normalize = true, inline: inline3 = false } = _param, restProps = _object_without_properties(_param, [
    "className",
    "Component",
    "normalize",
    "inline"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime12.jsx)(Typography, _object_spread({
    Component: Component3,
    normalize,
    inline: inline3,
    className: clsx(className, "vkuiSubhead", sizeY !== "regular" && sizeYClassNames6[sizeY])
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Footnote/Footnote.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
var sizeYClassNames7 = {
  none: "vkuiFootnote--sizeY-none",
  compact: "vkuiFootnote--sizeY-compact"
};
var Footnote = (_param) => {
  var { className, caps, Component: Component3 = "span", normalize = true, inline: inline3 = false } = _param, restProps = _object_without_properties(_param, [
    "className",
    "caps",
    "Component",
    "normalize",
    "inline"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime13.jsx)(Typography, _object_spread({
    Component: Component3,
    normalize,
    inline: inline3,
    className: clsx(className, sizeY !== "regular" && sizeYClassNames7[sizeY], "vkuiFootnote", caps && "vkuiFootnote--caps")
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Caption/Caption.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var stylesLevel4 = {
  "1": "vkuiCaption--level-1",
  "2": "vkuiCaption--level-2",
  "3": "vkuiCaption--level-3"
};
var sizeYClassNames8 = {
  none: "vkuiCaption--sizeY-none",
  compact: "vkuiCaption--sizeY-compact"
};
var Caption = (_param) => {
  var { className, level = "1", caps, Component: Component3 = "span", normalize = true, inline: inline3 = false } = _param, restProps = _object_without_properties(_param, [
    "className",
    "level",
    "caps",
    "Component",
    "normalize",
    "inline"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime14.jsx)(Typography, _object_spread({
    Component: Component3,
    normalize,
    inline: inline3,
    className: clsx(className, sizeY !== "regular" && sizeYClassNames8[sizeY], caps && "vkuiCaption--caps", stylesLevel4[level])
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/EllipsisText/EllipsisText.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
var import_react2 = __toESM(require_react());
var EllipsisText = (_param) => {
  var { className, getRootRef, children, maxWidth, maxLines = 1 } = _param, restProps = _object_without_properties(_param, [
    "className",
    "getRootRef",
    "children",
    "maxWidth",
    "maxLines"
  ]);
  const contentRef = (0, import_react2.useRef)(null);
  useIsomorphicLayoutEffect(() => {
    if (contentRef && contentRef.current) {
      contentRef.current.style.setProperty("-webkit-line-clamp", maxLines > 1 ? `${maxLines}` : "");
    }
  }, [
    contentRef,
    maxLines
  ]);
  return (0, import_jsx_runtime15.jsx)("span", _object_spread_props(_object_spread({
    ref: getRootRef,
    className: clsx("vkuiEllipsisText", className)
  }, restProps), {
    children: (0, import_jsx_runtime15.jsx)("span", {
      style: {
        maxWidth
      },
      ref: contentRef,
      className: clsx("vkuiEllipsisText__content", maxLines > 1 && "vkuiEllipsisText__content--multiline"),
      children
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/UnstyledTextField/UnstyledTextField.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
var React15 = __toESM(require_react());
var UnstyledTextField = (_param) => {
  var { as, noPadding = false, className } = _param, restProps = _object_without_properties(_param, [
    "as",
    "noPadding",
    "className"
  ]);
  return (0, import_jsx_runtime16.jsx)(Text, _object_spread({
    Component: as,
    normalize: false,
    className: clsx("vkuiUnstyledTextField", noPadding && "vkuiUnstyledTextField--noPadding", className)
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Tappable/Tappable.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime());

// node_modules/@vkontakte/vkui/dist/lib/adaptivity/constants.js
var ViewWidth = {
  SMALL_MOBILE: 1,
  MOBILE: 2,
  SMALL_TABLET: 3,
  TABLET: 4,
  DESKTOP: 5
};
var ViewHeight = {
  EXTRA_SMALL: 1,
  SMALL: 2,
  MEDIUM: 3
};
var SizeType = {
  COMPACT: "compact",
  REGULAR: "regular"
};
var VIEW_WIDTH_TO_CSS_BREAKPOINT_MAP = {
  [ViewWidth.SMALL_MOBILE]: "smallMobileMinus",
  [ViewWidth.MOBILE]: "mobile",
  [ViewWidth.SMALL_TABLET]: "smallTablet",
  [ViewWidth.TABLET]: "tablet",
  [ViewWidth.DESKTOP]: "desktopPlus"
};

// node_modules/@vkontakte/vkui/dist/lib/adaptivity/breakpoints.js
var BREAKPOINTS = {
  DESKTOP: 1280,
  TABLET: 1024,
  SMALL_TABLET: 768,
  MOBILE: 320,
  MOBILE_LANDSCAPE_HEIGHT: 415,
  MEDIUM_HEIGHT: 720
};
function widthPlus(a) {
  return `(min-width: ${a}px)`;
}
function widthMinus(b) {
  return `(max-width: ${b - 0.1}px)`;
}
function widthHalfInterval(a, b) {
  return `${widthPlus(a)} and ${widthMinus(b)}`;
}
function heightPlus(a) {
  return `(min-height: ${a}px)`;
}
var MEDIA_QUERIES = {
  DESKTOP_PLUS: widthPlus(BREAKPOINTS.DESKTOP),
  TABLET: widthHalfInterval(BREAKPOINTS.TABLET, BREAKPOINTS.DESKTOP),
  SMALL_TABLET_PLUS: widthPlus(BREAKPOINTS.SMALL_TABLET),
  SMALL_TABLET: widthHalfInterval(BREAKPOINTS.SMALL_TABLET, BREAKPOINTS.TABLET),
  MOBILE: widthHalfInterval(BREAKPOINTS.MOBILE, BREAKPOINTS.SMALL_TABLET),
  MEDIUM_HEIGHT: heightPlus(BREAKPOINTS.MEDIUM_HEIGHT),
  MOBILE_LANDSCAPE_HEIGHT: heightPlus(BREAKPOINTS.MOBILE_LANDSCAPE_HEIGHT)
};

// node_modules/@vkontakte/vkui/dist/lib/adaptivity/functions.js
function getViewWidthByViewportWidth(viewportWidth) {
  if (viewportWidth >= BREAKPOINTS.DESKTOP) {
    return ViewWidth.DESKTOP;
  }
  if (viewportWidth >= BREAKPOINTS.TABLET) {
    return ViewWidth.TABLET;
  }
  if (viewportWidth >= BREAKPOINTS.SMALL_TABLET) {
    return ViewWidth.SMALL_TABLET;
  }
  if (viewportWidth >= BREAKPOINTS.MOBILE) {
    return ViewWidth.MOBILE;
  }
  return ViewWidth.SMALL_MOBILE;
}
function getViewWidthByMediaQueries(mediaQueries) {
  if (mediaQueries.desktopPlus.matches) {
    return ViewWidth.DESKTOP;
  }
  if (mediaQueries.tablet.matches) {
    return ViewWidth.TABLET;
  }
  if (mediaQueries.smallTablet.matches) {
    return ViewWidth.SMALL_TABLET;
  }
  if (mediaQueries.mobile.matches) {
    return ViewWidth.MOBILE;
  }
  return ViewWidth.SMALL_MOBILE;
}
function getViewHeightByViewportHeight(viewportHeight) {
  if (viewportHeight >= BREAKPOINTS.MEDIUM_HEIGHT) {
    return ViewHeight.MEDIUM;
  }
  if (viewportHeight >= BREAKPOINTS.MOBILE_LANDSCAPE_HEIGHT) {
    return ViewHeight.SMALL;
  }
  return ViewHeight.EXTRA_SMALL;
}
function getViewHeightByMediaQueries(mediaQueries) {
  if (mediaQueries.mediumHeight.matches) {
    return ViewHeight.MEDIUM;
  }
  if (mediaQueries.mobileLandscapeHeight.matches) {
    return ViewHeight.SMALL;
  }
  return ViewHeight.EXTRA_SMALL;
}
function getSizeX(viewWidth) {
  return viewWidth <= ViewWidth.MOBILE ? "compact" : "regular";
}
function isCompactByViewWidth(viewWidth, hasPointer) {
  return viewWidth !== void 0 && viewWidth >= ViewWidth.SMALL_TABLET && hasPointer;
}
function isCompactByViewHeight(viewHeight) {
  return viewHeight !== void 0 && viewHeight <= ViewHeight.EXTRA_SMALL;
}
function getSizeY(viewWidth, viewHeight, hasPointer) {
  if (isCompactByViewWidth(viewWidth, hasPointer) || isCompactByViewHeight(viewHeight)) {
    return "compact";
  }
  return "regular";
}
function tryToCheckIsDesktop(viewWidth, viewHeight, hasPointer, platform3) {
  const IS_VKCOM_CRUTCH = platform3 === "vkcom";
  if ((viewWidth === void 0 || hasPointer === void 0) && (viewWidth === void 0 || viewHeight === void 0) || hasPointer === void 0 && viewHeight === void 0) {
    return IS_VKCOM_CRUTCH ? true : null;
  }
  const widthIsLikeDesktop = viewWidth >= ViewWidth.SMALL_TABLET;
  const otherParametersIsLikeDesktop = hasPointer || (viewHeight !== void 0 ? viewHeight >= ViewHeight.MEDIUM : false);
  return widthIsLikeDesktop && otherParametersIsLikeDesktop || IS_VKCOM_CRUTCH;
}
function viewWidthToClassName(breakpointClassNames2, viewWidth = "none") {
  if (viewWidth === "none") {
    return breakpointClassNames2.hasOwnProperty("none") ? breakpointClassNames2["none"] : null;
  }
  const breakpoints = [];
  const breakpointName = VIEW_WIDTH_TO_CSS_BREAKPOINT_MAP[viewWidth];
  if (breakpointClassNames2.hasOwnProperty(breakpointName)) {
    breakpoints.push(breakpointClassNames2[breakpointName]);
  }
  if (viewWidth >= ViewWidth.MOBILE) {
    if (breakpointClassNames2.hasOwnProperty("mobilePlus")) {
      breakpoints.push(breakpointClassNames2["mobilePlus"]);
    }
  }
  if (viewWidth >= ViewWidth.SMALL_TABLET) {
    if (breakpointClassNames2.hasOwnProperty("smallTabletPlus")) {
      breakpoints.push(breakpointClassNames2["smallTabletPlus"]);
    }
  } else {
    if (breakpointClassNames2.hasOwnProperty("smallTabletMinus")) {
      breakpoints.push(breakpointClassNames2["smallTabletMinus"]);
    }
  }
  if (viewWidth >= ViewWidth.TABLET) {
    if (breakpointClassNames2.hasOwnProperty("tabletPlus")) {
      breakpoints.push(breakpointClassNames2["tabletPlus"]);
    }
  } else {
    if (breakpointClassNames2.hasOwnProperty("tabletMinus")) {
      breakpoints.push(breakpointClassNames2["tabletMinus"]);
    }
  }
  return breakpoints.length > 0 ? breakpoints.join(" ") : null;
}

// node_modules/@vkontakte/vkui/dist/lib/callMultiple.js
var callMultiple = (...fns) => (...args) => fns.filter((f) => typeof f === "function").forEach((f) => f(...args));

// node_modules/@vkontakte/vkui/dist/lib/mergeCalls.js
function mergeCalls(...props) {
  const objectToArrays = props.reduce((record, obj) => {
    Object.entries(obj).forEach(([key, value]) => {
      if (!record.hasOwnProperty(key)) {
        record[key] = [];
      }
      record[key].push(value);
    });
    return record;
  }, {});
  return Object.entries(objectToArrays).reduce((record, [key, array]) => {
    record[key] = callMultiple(...array);
    return record;
  }, {});
}

// node_modules/@vkontakte/vkui/dist/components/Clickable/Clickable.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
var React19 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useFocusVisible.js
var import_react3 = __toESM(require_react());
function useFocusVisible(withKeyboardInputCheck = true) {
  const [isFocused, setIsFocused] = (0, import_react3.useState)(false);
  const { keyboardInput } = (0, import_react3.useContext)(AppRootContext);
  const onFocus = (0, import_react3.useCallback)((event) => {
    event.stopPropagation();
    setIsFocused(true);
  }, [
    setIsFocused
  ]);
  const onBlur = (0, import_react3.useCallback)((event) => {
    event.stopPropagation();
    setIsFocused(false);
  }, [
    setIsFocused
  ]);
  const focusVisible = withKeyboardInputCheck ? keyboardInput && isFocused : isFocused;
  return {
    focusVisible,
    onFocus,
    onBlur
  };
}

// node_modules/@vkontakte/vkui/dist/hooks/useFocusVisibleClassName.js
var focusVisiblePresetModeClassNames = {
  inside: "vkui-focus-visible--mode-inside",
  outside: "vkui-focus-visible--mode-outside"
};
var isPresetMode = (mode) => mode === "inside" || mode === "outside";
function useFocusVisibleClassName({ focusVisible = false, mode = "inside" }) {
  const modeClassName = isPresetMode(mode) ? focusVisiblePresetModeClassNames[mode] : mode;
  const focusVisibleClassNames = clsx("vkui-focus-visible", focusVisible && "vkui-focus-visible--focused", focusVisible && modeClassName);
  return focusVisibleClassNames;
}

// node_modules/@vkontakte/vkui/dist/lib/utils.js
var React16 = __toESM(require_react());
function setRef(element1, ref) {
  if (ref) {
    if (typeof ref === "function") {
      ref(element1);
    } else {
      ref.current = element1;
    }
  }
}
function multiRef(...refs) {
  let current = null;
  return {
    get current() {
      return current;
    },
    set current(element) {
      current = element;
      refs.forEach((ref) => ref && setRef(element, ref));
    }
  };
}
var stopPropagation = (event) => event.stopPropagation();
var excludeKeysWithUndefined = (obj) => {
  const filteredObj = {};
  for (const key in obj) {
    if (obj.hasOwnProperty(key) && obj[key] !== void 0) {
      filteredObj[key] = obj[key];
    }
  }
  return filteredObj;
};
var isDOMTypeElement = (element1) => typeof element1.type === "string";
function isValidNotReactFragmentElement(children) {
  return React16.isValidElement(children) && // @ts-expect-error: TS2339 $$typeof всегда symbol, в отличии от type, благодаря этому пропускаем лишние проверки на тип.
  children.$$typeof !== Symbol.for("react.fragment");
}
function isForwardRefElement(children) {
  if (!React16.isValidElement(children)) {
    return false;
  }
  const typeOfOfType = children.type && children.type.$$typeof;
  return typeOfOfType === Symbol.for("react.forward_ref");
}
function getFetchPriorityProp(value) {
  if (React16.version.startsWith("19")) {
    return {
      fetchPriority: value
    };
  }
  return {
    fetchpriority: value
  };
}
function clickByKeyboardHandler(event) {
  var _event_target_click, _event_target;
  if (!isHTMLElement(event.target) || !shouldTriggerClickOnEnterOrSpace(event)) {
    return;
  }
  event.preventDefault();
  (_event_target_click = (_event_target = event.target).click) === null || _event_target_click === void 0 ? void 0 : _event_target_click.call(_event_target);
}

// node_modules/@vkontakte/vkui/dist/components/Clickable/useState.js
var React18 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Clickable/useStateWithDelay.js
var React17 = __toESM(require_react());
function useStateWithDelay(initialState, defaultDelay = 0, onStateChange = noop) {
  const [value, setValue] = React17.useState(initialState);
  const timeout = React17.useRef();
  const handleSetValue = React17.useCallback((nextValue) => {
    if (isFunction(nextValue)) {
      setValue((prevValue) => {
        const value2 = nextValue(prevValue);
        onStateChange(value2);
        return value2;
      });
    } else {
      setValue(nextValue);
      onStateChange(nextValue);
    }
  }, [
    onStateChange
  ]);
  const setValueWithDelay = React17.useCallback((newValue, delay = defaultDelay) => {
    clearTimeout(timeout.current);
    if (delay === 0) {
      handleSetValue(newValue);
      return;
    }
    timeout.current = setTimeout(() => handleSetValue(newValue), delay);
  }, [
    defaultDelay,
    handleSetValue
  ]);
  return [
    value,
    setValueWithDelay
  ];
}

// node_modules/@vkontakte/vkui/dist/components/Clickable/useState.js
var DEFAULT_ACTIVE_EFFECT_DELAY = 600;
var ACTIVE_DELAY = 70;
function useHover({ hovered, hasHover: hasHover2 = true, lockState, setParentStateLock }) {
  const [hoveredStateLocal, setHoveredStateLocal] = React18.useState(false);
  const prevIsHoveredRef = React18.useRef(void 0);
  const handleHover = React18.useCallback((isHover) => {
    setHoveredStateLocal(isHover);
    const isHovered2 = hovered !== null && hovered !== void 0 ? hovered : calculateStateValue({
      hasState: hasHover2,
      isLocked: lockState,
      stateValueLocal: isHover
    });
    if (isHovered2 !== prevIsHoveredRef.current) {
      prevIsHoveredRef.current = isHovered2;
      setParentStateLock(isHovered2);
    }
  }, [
    setParentStateLock,
    hasHover2,
    hovered,
    lockState
  ]);
  const onPointerEnter = (e) => {
    if (e.pointerType === "touch") {
      return;
    }
    handleHover(true);
  };
  const onPointerLeave = () => {
    handleHover(false);
  };
  const isHovered = hovered !== null && hovered !== void 0 ? hovered : calculateStateValue({
    hasState: hasHover2,
    isLocked: lockState,
    stateValueLocal: hoveredStateLocal
  });
  return {
    isHovered,
    onPointerEnter: hasHover2 ? onPointerEnter : noop,
    onPointerLeave: hasHover2 ? onPointerLeave : noop
  };
}
function useActive({ activated, activeEffectDelay, hasActive = true, lockStateRef, setParentStateLock }) {
  const [activatedState, setActivated] = useStateWithDelay(false, 0, setParentStateLock);
  const pointersUp = React18.useMemo(() => /* @__PURE__ */ new Set(), []);
  const onPointerDown = () => {
    if (lockStateRef.current) {
      return;
    }
    setActivated(true, ACTIVE_DELAY);
    setParentStateLock(true);
  };
  const onPointerCancel = (e) => {
    if (pointersUp.has(e.pointerId)) {
      pointersUp.delete(e.pointerId);
      return;
    }
    setActivated(false);
  };
  const onPointerUp = (e) => {
    pointersUp.add(e.pointerId);
    if (lockStateRef.current) {
      return;
    }
    setActivated(true);
    setActivated(false, activeEffectDelay);
  };
  const isActivated = activated !== null && activated !== void 0 ? activated : calculateStateValue({
    hasState: hasActive,
    isLocked: lockStateRef.current,
    stateValueLocal: activatedState
  });
  return {
    isActivated,
    onPointerLeave: hasActive ? onPointerCancel : noop,
    onPointerDown: hasActive ? onPointerDown : noop,
    onPointerCancel: hasActive ? onPointerCancel : noop,
    onPointerUp: hasActive ? onPointerUp : noop
  };
}
var ClickableLockStateContext = React18.createContext({
  lockHoverStateBubbling: void 0,
  lockActiveStateBubbling: void 0
});
function useLockState(setParentStateLockBubbling) {
  const [lockState, setLockState] = React18.useState(false);
  const setStateLockBubblingImmediate = React18.useCallback((isLock) => {
    setLockState(isLock);
    setParentStateLockBubbling(isLock);
  }, [
    setParentStateLockBubbling
  ]);
  return [
    lockState,
    setParentStateLockBubbling,
    setStateLockBubblingImmediate
  ];
}
function useLockRef(setParentStateLockBubbling) {
  const lockStateRef = React18.useRef(false);
  const setStateLockBubblingImmediate = React18.useCallback((isLock) => {
    lockStateRef.current = isLock;
    setParentStateLockBubbling(isLock);
  }, [
    setParentStateLockBubbling
  ]);
  return [
    lockStateRef,
    setParentStateLockBubbling,
    setStateLockBubblingImmediate
  ];
}
function useState5({ hovered, hasHover: hasHover2, activated, hasActive, activeEffectDelay, unlockParentHover, hoverClassName, activeClassName }) {
  const { lockHoverStateBubbling = noop, lockActiveStateBubbling = noop } = React18.useContext(ClickableLockStateContext);
  const [lockHoverState, setParentStateLockHoverBubbling, setLockHoverBubblingImmediate] = useLockState(unlockParentHover ? noop : lockHoverStateBubbling);
  const [lockActiveStateRef, setParentStateLockActiveBubbling, setLockActiveBubblingImmediate] = useLockRef(lockActiveStateBubbling);
  const _useHover = useHover({
    hasHover: hasHover2,
    hovered,
    lockState: lockHoverState,
    setParentStateLock: setParentStateLockHoverBubbling
  }), { isHovered } = _useHover, hoverEvent = _object_without_properties(_useHover, [
    "isHovered"
  ]);
  const _useActive = useActive({
    activated,
    hasActive,
    activeEffectDelay,
    lockStateRef: lockActiveStateRef,
    setParentStateLock: setParentStateLockActiveBubbling
  }), { isActivated } = _useActive, activeEvent = _object_without_properties(_useActive, [
    "isActivated"
  ]);
  const stateClassName = clsx(isHovered && hoverClassName, isActivated && activeClassName);
  const handlers = mergeCalls(hoverEvent, activeEvent);
  return _object_spread({
    stateClassName,
    setLockHoverBubblingImmediate,
    setLockActiveBubblingImmediate
  }, handlers);
}
function calculateStateValue({ hasState, isLocked, stateValueLocal }) {
  return hasState && !isLocked && stateValueLocal;
}

// node_modules/@vkontakte/vkui/dist/components/Clickable/Clickable.js
var NonClickable = (_param) => {
  var { href, onClick, onClickCapture, activeClassName, hoverClassName, hasActive, hasHover: hasHover2, hovered, unlockParentHover, activated, activeEffectDelay } = _param, restProps = _object_without_properties(_param, [
    "href",
    "onClick",
    "onClickCapture",
    "activeClassName",
    "hoverClassName",
    "hasActive",
    "hasHover",
    "hovered",
    "unlockParentHover",
    "activated",
    "activeEffectDelay"
  ]);
  return (0, import_jsx_runtime17.jsx)(RootComponent, _object_spread({}, restProps));
};
var RealClickable = (_param) => {
  var { baseClassName, children, focusVisibleMode = "inside", activeClassName, hoverClassName, activeEffectDelay = DEFAULT_ACTIVE_EFFECT_DELAY, hasHover: hasHover2 = true, hasActive = true, hovered, activated, hasHoverWithChildren, unlockParentHover, onPointerEnter, onPointerLeave, onPointerDown, onPointerCancel, onPointerUp, onBlur, onFocus, onKeyDown } = _param, restProps = _object_without_properties(_param, [
    "baseClassName",
    "children",
    "focusVisibleMode",
    "activeClassName",
    "hoverClassName",
    "activeEffectDelay",
    "hasHover",
    "hasActive",
    "hovered",
    "activated",
    "hasHoverWithChildren",
    "unlockParentHover",
    "onPointerEnter",
    "onPointerLeave",
    "onPointerDown",
    "onPointerCancel",
    "onPointerUp",
    "onBlur",
    "onFocus",
    "onKeyDown"
  ]);
  const _useFocusVisible = useFocusVisible(), { focusVisible } = _useFocusVisible, focusEvents = _object_without_properties(_useFocusVisible, [
    "focusVisible"
  ]);
  const focusVisibleClassNames = useFocusVisibleClassName({
    focusVisible,
    mode: focusVisibleMode
  });
  const _useState = useState5({
    activeClassName,
    hoverClassName,
    activeEffectDelay,
    hasHover: hasHover2,
    hasActive,
    hovered,
    activated,
    unlockParentHover
  }), { stateClassName, setLockHoverBubblingImmediate, setLockActiveBubblingImmediate } = _useState, stateEvents = _object_without_properties(_useState, [
    "stateClassName",
    "setLockHoverBubblingImmediate",
    "setLockActiveBubblingImmediate"
  ]);
  const handlers = mergeCalls(focusEvents, stateEvents, {
    onKeyDown: clickByKeyboardHandler
  }, {
    onPointerEnter,
    onPointerLeave,
    onPointerDown,
    onPointerCancel,
    onPointerUp,
    onBlur,
    onFocus,
    onKeyDown
  });
  const lockStateContextValue = React19.useMemo(() => ({
    lockHoverStateBubbling: hasHoverWithChildren ? noop : setLockHoverBubblingImmediate,
    lockActiveStateBubbling: setLockActiveBubblingImmediate
  }), [
    setLockHoverBubblingImmediate,
    setLockActiveBubblingImmediate,
    hasHoverWithChildren
  ]);
  return (0, import_jsx_runtime17.jsx)(RootComponent, _object_spread_props(_object_spread({
    baseClassName: clsx(baseClassName, "vkuiClickable__realClickable", focusVisibleClassNames, stateClassName)
  }, handlers, restProps), {
    children: (0, import_jsx_runtime17.jsx)(ClickableLockStateContext.Provider, {
      value: lockStateContextValue,
      children
    })
  }));
};
function checkClickable(props) {
  return (props.href !== void 0 || props.onClick !== void 0 || props.onClickCapture !== void 0 || props.Component === "a" || props.Component === "button" || props.Component === "label" || props.Component === "input") && !props.disabled;
}
function component({ Component: Component3, onClick, onClickCapture, href, disabled }) {
  if (Component3 !== void 0) {
    return {
      Component: Component3
    };
  } else if (href !== void 0) {
    return {
      "Component": "a",
      "aria-disabled": disabled
    };
  } else if (onClick !== void 0 || onClickCapture !== void 0) {
    return {
      "Component": "div",
      "role": "button",
      "tabIndex": disabled ? void 0 : 0,
      "aria-disabled": disabled
    };
  }
  return {};
}
var getUserAgentResetClassName = (Component3) => {
  if (Component3 === "a") {
    return "vkuiClickable__resetLinkStyle";
  }
  if (Component3 === "button") {
    return "vkuiClickable__resetButtonStyle";
  }
  return;
};
var Clickable = (_param) => {
  var { focusVisibleMode = "inside", baseClassName: baseClassNameProp } = _param, restProps = _object_without_properties(_param, [
    "focusVisibleMode",
    "baseClassName"
  ]);
  const commonProps = component(restProps);
  const isClickable = checkClickable(restProps);
  const baseClassName = clsx(baseClassNameProp, getUserAgentResetClassName(commonProps.Component), "vkuiClickable__host");
  if (isClickable) {
    return (0, import_jsx_runtime17.jsx)(RealClickable, _object_spread({
      baseClassName,
      focusVisibleMode
    }, commonProps, restProps));
  }
  return (0, import_jsx_runtime17.jsx)(NonClickable, _object_spread({
    baseClassName
  }, commonProps, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Tappable/Ripple.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var React20 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/usePlatform.js
function usePlatform() {
  const { platform: platform3 } = useConfigProvider();
  return platform3;
}

// node_modules/@vkontakte/vkui/dist/lib/offset.js
function getOffsetRect2(elem) {
  const box = elem === null || elem === void 0 ? void 0 : elem.getBoundingClientRect();
  return {
    top: box === null || box === void 0 ? void 0 : box.top,
    left: box === null || box === void 0 ? void 0 : box.left,
    width: elem === null || elem === void 0 ? void 0 : elem.offsetWidth,
    height: elem === null || elem === void 0 ? void 0 : elem.offsetHeight
  };
}

// node_modules/@vkontakte/vkui/dist/components/Tappable/Ripple.js
var useMaybeNeedRipple = (activeMode, hasPointer) => {
  const platform3 = usePlatform();
  return platform3 === "android" && !hasPointer && activeMode === "background";
};
var DELAY = 70;
var WAVE_LIVE = 225;
var useRipple = (needRipple, hasPointerContext) => {
  const [clicks, setClicks] = React20.useState([]);
  const pointerDelayTimers = React20.useMemo(() => /* @__PURE__ */ new Map(), []);
  React20.useEffect(function setClearClicksTimeout() {
    const clicksTimeoutId = clicks.length > 0 ? setTimeout(() => setClicks([]), WAVE_LIVE) : null;
    return function cancelClearClicksTimeout() {
      if (clicksTimeoutId) {
        clearTimeout(clicksTimeoutId);
      }
    };
  }, [
    clicks
  ]);
  function addClick(x, y, pointerId) {
    const dateNow = Date.now();
    const filteredClicks = clicks.filter((click) => click.id + WAVE_LIVE > dateNow);
    setClicks([
      ...filteredClicks,
      {
        x,
        y,
        id: dateNow,
        pointerId
      }
    ]);
    pointerDelayTimers.delete(pointerId);
  }
  const onPointerDown = (e) => {
    const { top, left } = getOffsetRect2(e.currentTarget);
    const x = e.clientX - (left !== null && left !== void 0 ? left : 0);
    const y = e.clientY - (top !== null && top !== void 0 ? top : 0);
    pointerDelayTimers.set(e.pointerId, setTimeout(() => addClick(x, y, e.pointerId), DELAY));
  };
  const onPointerCancel = (e) => {
    const timer = pointerDelayTimers.get(e.pointerId);
    clearTimeout(timer);
    pointerDelayTimers.delete(e.pointerId);
  };
  const reallyNeedRipple = (!hasMouse || hasPointerContext === false) && needRipple;
  return {
    clicks,
    onPointerDown: reallyNeedRipple ? onPointerDown : noop,
    onPointerCancel: reallyNeedRipple ? onPointerCancel : noop
  };
};
var Ripple = ({ needRipple = true, clicks }) => {
  return (0, import_jsx_runtime18.jsx)("span", {
    "aria-hidden": true,
    className: clsx("vkuiTappable__stateLayer", needRipple && "vkuiTappable__ripple"),
    children: clicks.map((wave) => (0, import_jsx_runtime18.jsx)("span", {
      className: "vkuiTappable__wave",
      style: {
        top: wave.y,
        left: wave.x
      }
    }, wave.id))
  });
};

// node_modules/@vkontakte/vkui/dist/components/Tappable/state.js
var DEFAULT_STATE_MODE = "background";
var stylesHovered = {
  background: "vkuiTappable--hovered-background",
  opacity: "vkuiTappable--hovered-opacity",
  none: ""
};
function hoverClass(hoverMode = DEFAULT_STATE_MODE) {
  const presetClass = stylesHovered[hoverMode];
  return presetClass !== void 0 ? presetClass : hoverMode;
}
var stylesActivated = {
  background: "vkuiTappable--activated-background",
  opacity: "vkuiTappable--activated-opacity",
  none: ""
};
function activeClass(activeMode = DEFAULT_STATE_MODE) {
  const presetClass = stylesActivated[activeMode];
  return presetClass !== void 0 ? presetClass : activeMode;
}

// node_modules/@vkontakte/vkui/dist/components/Tappable/Tappable.js
var sizeXClassNames = {
  none: "vkuiTappable--sizeX-none",
  compact: "vkuiTappable--sizeX-compact"
};
function hasPointerClassName(hasPointer) {
  switch (hasPointer) {
    case void 0:
      return "vkuiTappable--hasPointer-none";
    case false:
      return "vkuiTappable--hasPointer-false";
  }
  return void 0;
}
var Tappable = (_param) => {
  var { baseClassName, borderRadiusMode = "auto", children, hoverMode = DEFAULT_STATE_MODE, activeMode = DEFAULT_STATE_MODE, onPointerDown, onPointerCancel } = _param, restProps = _object_without_properties(_param, [
    "baseClassName",
    "borderRadiusMode",
    "children",
    "hoverMode",
    "activeMode",
    "onPointerDown",
    "onPointerCancel"
  ]);
  const isClickable = checkClickable(restProps);
  const { sizeX = "none", hasPointer } = useAdaptivity();
  const needRipple = useMaybeNeedRipple(activeMode, hasPointer);
  const _useRipple = useRipple(needRipple, hasPointer), { clicks } = _useRipple, rippleEvents = _object_without_properties(_useRipple, [
    "clicks"
  ]);
  const handlers = mergeCalls(rippleEvents, {
    onPointerDown,
    onPointerCancel
  });
  const typeProps = restProps.Component === "button" ? {
    type: "button"
  } : {};
  return (0, import_jsx_runtime19.jsxs)(Clickable, _object_spread_props(_object_spread({
    baseClassName: clsx(baseClassName, "vkuiTappable", sizeX !== SizeType.REGULAR && sizeXClassNames[sizeX], borderRadiusMode === "inherit" && "vkuiTappable--borderRadiusInherit", hasPointerClassName(hasPointer)),
    hoverClassName: hoverClass(hoverMode),
    activeClassName: activeClass(activeMode)
  }, typeProps, handlers, restProps), {
    children: [
      children,
      isClickable && (hoverMode === "background" || activeMode === "background") && (0, import_jsx_runtime19.jsx)(Ripple, {
        needRipple,
        clicks
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/FixedLayout/FixedLayout.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime());
var import_react5 = __toESM(require_react());
var React25 = __toESM(require_react());

// node_modules/@swc/helpers/esm/_class_apply_descriptor_get.js
function _class_apply_descriptor_get(receiver, descriptor) {
  if (descriptor.get) return descriptor.get.call(receiver);
  return descriptor.value;
}

// node_modules/@swc/helpers/esm/_class_extract_field_descriptor.js
function _class_extract_field_descriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) throw new TypeError("attempted to " + action + " private field on non-instance");
  return privateMap.get(receiver);
}

// node_modules/@swc/helpers/esm/_class_private_field_get.js
function _class_private_field_get(receiver, privateMap) {
  var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
  return _class_apply_descriptor_get(receiver, descriptor);
}

// node_modules/@swc/helpers/esm/_check_private_redeclaration.js
function _check_private_redeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}

// node_modules/@swc/helpers/esm/_class_private_field_init.js
function _class_private_field_init(obj, privateMap, value) {
  _check_private_redeclaration(obj, privateMap);
  privateMap.set(obj, value);
}

// node_modules/@swc/helpers/esm/_class_apply_descriptor_set.js
function _class_apply_descriptor_set(receiver, descriptor, value) {
  if (descriptor.set) descriptor.set.call(receiver, value);
  else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}

// node_modules/@swc/helpers/esm/_class_private_field_set.js
function _class_private_field_set(receiver, privateMap, value) {
  var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
  _class_apply_descriptor_set(receiver, descriptor, value);
  return value;
}

// node_modules/@vkontakte/vkui/dist/hooks/useEventListener.js
var React21 = __toESM(require_react());
var _target = /* @__PURE__ */ new WeakMap();
var _listener = /* @__PURE__ */ new WeakMap();
var EventListener = class {
  constructor(type, callback, options) {
    _define_property(this, "callback", noop);
    _define_property(this, "options", void 0);
    _define_property(this, "eventType", void 0);
    _class_private_field_init(this, _target, {
      writable: true,
      value: null
    });
    _class_private_field_init(this, _listener, {
      writable: true,
      value: (ev) => {
        this.callback(ev);
      }
    });
    _define_property(this, "add", (el) => {
      if (!canUseDOM) {
        return;
      }
      this.remove();
      if (!el) {
        return;
      }
      el.addEventListener(this.eventType, _class_private_field_get(this, _listener), this.options);
      _class_private_field_set(this, _target, el);
    });
    _define_property(this, "remove", () => {
      if (!canUseDOM || !_class_private_field_get(this, _target)) {
        return;
      }
      _class_private_field_get(this, _target).removeEventListener(this.eventType, _class_private_field_get(this, _listener), this.options);
      _class_private_field_set(this, _target, null);
    });
    this.options = options;
    this.eventType = type;
    if (callback) {
      this.callback = callback;
    }
  }
};
function useEventListener(event, _cb, _options) {
  const ref = React21.useRef(null);
  if (ref.current === null) {
    ref.current = new EventListener(event, _cb, _options);
  } else {
    ref.current.eventType = event;
    ref.current.options = _options;
    if (_cb) {
      ref.current.callback = _cb;
    }
  }
  React21.useEffect(() => {
    var _ref_current;
    const detach = (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.remove.bind(ref.current);
    return detach;
  }, []);
  return ref.current;
}

// node_modules/@vkontakte/vkui/dist/hooks/useGlobalEventListener.js
function useGlobalEventListener(element, event, cb, options) {
  const listener = useEventListener(event, cb, options);
  useIsomorphicLayoutEffect(() => {
    if (cb && element) {
      listener.add(element);
    } else {
      listener.remove();
    }
  }, [
    Boolean(cb),
    Boolean(element)
  ]);
}

// node_modules/@vkontakte/vkui/dist/hooks/useResizeObserver.js
var import_react4 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/floating/customResizeObserver.js
var defaultIframeStyles = {
  position: "absolute",
  left: "0",
  top: "0",
  zIndex: "-1",
  width: "100%",
  height: "100%",
  pointerEvents: "none",
  opacity: "0",
  border: "0"
};
var CustomResizeObserver = class {
  observe(element) {
    if (isPositioned(element)) {
      return this.observeUsingIframe(element);
    }
    return this.observeUsingMutationObserver(element);
  }
  appendToTheDOM() {
    for (let record of this.records) {
      record.target.appendChild(record.iframe);
    }
    for (let record of this.records) {
      if (record.iframe.contentWindow) {
        record.iframe.contentWindow.addEventListener("resize", this.updateFunction);
      }
    }
  }
  observeUsingIframe(element) {
    const iframe = element.ownerDocument.createElement("iframe");
    iframe.ariaHidden = "true";
    iframe.tabIndex = -1;
    Object.assign(iframe.style, defaultIframeStyles);
    this.records.push({
      target: element,
      iframe
    });
  }
  observeUsingMutationObserver(element) {
    if (!this.mutationObserverFallback) {
      this.mutationObserverFallback = new MutationObserver(this.updateFunction);
    }
    this.mutationObserverFallback.observe(element, {
      childList: true,
      subtree: true
    });
  }
  disconnect() {
    this.records.map(({ target, iframe }) => {
      if (iframe.contentWindow) {
        iframe.contentWindow.removeEventListener("resize", this.updateFunction);
      }
      target.removeChild(iframe);
    });
    this.records = [];
    if (this.mutationObserverFallback) {
      this.mutationObserverFallback.disconnect();
    }
    this.mutationObserverFallback = null;
  }
  constructor(updateFunction) {
    _define_property(this, "updateFunction", void 0);
    _define_property(this, "records", void 0);
    _define_property(this, "mutationObserverFallback", void 0);
    this.updateFunction = updateFunction;
    this.records = [];
    this.mutationObserverFallback = null;
    this.updateFunction = updateFunction;
  }
};
function isPositioned(element) {
  return getComputedStyle(element).position !== "static";
}

// node_modules/@vkontakte/vkui/dist/hooks/useStableCallback.js
var React22 = __toESM(require_react());
function useStableCallback(fn) {
  const ref = React22.useRef(fn);
  useIsomorphicLayoutEffect(() => {
    ref.current = fn;
  });
  return React22.useRef((...args) => (0, ref.current)(...args)).current;
}

// node_modules/@vkontakte/vkui/dist/hooks/useResizeObserver.js
function useResizeObserver(ref, callback) {
  const stableCallback = useStableCallback(callback);
  (0, import_react4.useEffect)(function addResizeObserverHandler() {
    if (!ref || !ref.current) {
      return;
    }
    const element = ref.current;
    const observer = new CustomResizeObserver(() => stableCallback(element));
    observer.observe(element);
    observer.appendToTheDOM();
    return () => observer.disconnect();
  }, [
    ref,
    stableCallback
  ]);
}

// node_modules/@vkontakte/vkui/dist/components/OnboardingTooltip/OnboardingTooltipContainer.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
var React23 = __toESM(require_react());
var onboardingTooltipContainerAttr = "data-onboarding-tooltip-container";
var OnboardingTooltipContainer = React23.forwardRef((_param, ref) => {
  var { fixed = false, Component: Component3 = "div" } = _param, props = _object_without_properties(_param, [
    "fixed",
    "Component"
  ]);
  const dataProps = {
    [onboardingTooltipContainerAttr]: fixed ? "fixed" : "true"
  };
  return (0, import_jsx_runtime20.jsx)(Component3, _object_spread_props(_object_spread({}, dataProps, props), {
    ref
  }));
});
OnboardingTooltipContainer.displayName = "OnboardingTooltipContainer";

// node_modules/@vkontakte/vkui/dist/components/SplitCol/SplitColContext.js
var React24 = __toESM(require_react());
var SplitColContext = React24.createContext({
  colRef: null,
  animate: true
});
var useSplitCol = () => React24.useContext(SplitColContext);

// node_modules/@vkontakte/vkui/dist/components/FixedLayout/FixedLayout.js
var stylesVertical = {
  top: "vkuiFixedLayout--vertical-top",
  bottom: clsx("vkuiFixedLayout--vertical-bottom", "vkuiInternalFixedLayout--vertical-bottom")
};
var FixedLayout = (_param) => {
  var { children, style, vertical, getRootRef, filled, className, useParentWidth } = _param, restProps = _object_without_properties(_param, [
    "children",
    "style",
    "vertical",
    "getRootRef",
    "filled",
    "className",
    "useParentWidth"
  ]);
  const platform3 = usePlatform();
  const ref = React25.useRef(null);
  const [width, setWidth] = React25.useState(void 0);
  const { window: window2 } = useDOM();
  const { colRef } = React25.useContext(SplitColContext);
  const parentRef = React25.useRef(null);
  const handleRootRef = (0, import_react5.useCallback)((node) => {
    if (!node) {
      return;
    }
    setRef(node, getRootRef);
    setRef(node, ref);
    setRef(node.parentElement, parentRef);
  }, [
    getRootRef
  ]);
  const doResize = () => {
    if (useParentWidth && parentRef.current) {
      const parentWidth = parentRef.current.getBoundingClientRect().width;
      setWidth(parentWidth ? `${parentWidth}px` : void 0);
    } else if (colRef === null || colRef === void 0 ? void 0 : colRef.current) {
      const computedStyle = getComputedStyle(colRef.current);
      setWidth(`${colRef.current.clientWidth - parseFloat(computedStyle.paddingLeft || "0") - parseFloat(computedStyle.paddingRight || "0")}px`);
    } else {
      setWidth(void 0);
    }
  };
  React25.useEffect(doResize, [
    colRef,
    platform3,
    ref,
    useParentWidth
  ]);
  useGlobalEventListener(window2, "resize", doResize);
  useResizeObserver(useParentWidth ? parentRef : colRef, doResize);
  return (0, import_jsx_runtime21.jsx)(OnboardingTooltipContainer, _object_spread_props(_object_spread({}, restProps), {
    fixed: true,
    ref: handleRootRef,
    className: clsx("vkuiFixedLayout", platform3 === "ios" && "vkuiInternalFixedLayout--ios", filled && "vkuiFixedLayout--filled", vertical && stylesVertical[vertical], className),
    style: _object_spread_props(_object_spread({}, style), {
      width
    }),
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBase.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime());
var React34 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useExternRef.js
var React26 = __toESM(require_react());
var _element = /* @__PURE__ */ new WeakMap();
var _externRefs = /* @__PURE__ */ new WeakMap();
var ExternalRef = class {
  updateExternRefs(refs) {
    refs.forEach((ref) => {
      if (!ref || _class_private_field_get(this, _externRefs).has(ref)) {
        return;
      }
      setRef(_class_private_field_get(this, _element), ref);
      _class_private_field_get(this, _externRefs).add(ref);
    });
  }
  get current() {
    return _class_private_field_get(this, _element);
  }
  set current(el) {
    _class_private_field_set(this, _element, el);
    _class_private_field_get(this, _externRefs).forEach((ref) => setRef(el, ref));
  }
  /**
  * React проверяет наличие свойства current у объектов через hasOwnProperty
  *
  * https://github.com/facebook/react/blob/c3cdbec0a78d39b5ff7329384cb41c4573a38212/packages/react-reconciler/src/ReactFiberCommitWork.js#L1612
  */
  hasOwnProperty(v) {
    return v === "current";
  }
  constructor(externRefs = []) {
    _class_private_field_init(this, _element, {
      writable: true,
      value: null
    });
    _class_private_field_init(this, _externRefs, {
      writable: true,
      value: /* @__PURE__ */ new Set()
    });
    externRefs.forEach((ref) => {
      if (ref) {
        _class_private_field_get(this, _externRefs).add(ref);
      }
    });
  }
};
function useExternRef(...externRefs) {
  const ref = React26.useRef(null);
  if (ref.current === null) {
    ref.current = new ExternalRef(externRefs);
  } else {
    ref.current.updateExternRefs(externRefs);
  }
  return ref.current;
}

// node_modules/@vkontakte/vkui/dist/lib/comparing.js
function isNotUndefined(value) {
  return value !== void 0;
}
function fnArgsOr(fn, args, defaultValue) {
  const definedArgs = args.filter(isNotUndefined);
  if (definedArgs.length) {
    return fn(...definedArgs);
  }
  return defaultValue;
}
function minOr(args, defaultValue) {
  return fnArgsOr(Math.min, args, defaultValue);
}

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBaseBadge/ImageBaseBadge.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
var React28 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ImageBase/context.js
var React27 = __toESM(require_react());
var ImageBaseContext = React27.createContext({
  size: 0
});

// node_modules/@vkontakte/vkui/dist/lib/warnOnce.js
function warnOnce(zone) {
  const didWarn = /* @__PURE__ */ new Set();
  return (message, type = "warn") => {
    if (!didWarn.has(message)) {
      didWarn.add(message);
      const formattedMessage = `%c[VKUI/${zone}] ${message}`;
      const styles = type === "log" ? "color: steelblue; font-style: italic" : void 0;
      console[type](formattedMessage, styles);
    }
  };
}
function getA11yRuleUrl(ruleName) {
  const AXE_CORE_MINOR_VERSION = "4.5";
  return `https://dequeuniversity.com/rules/axe/${AXE_CORE_MINOR_VERSION}/${ruleName}`;
}
var COMMON_WARNINGS = {
  a11y: {
    "button-name": `a11y: Кнопка должна содержать текст, доступный для скринридеров. Чтобы исправить эту ошибку, передайте компоненту текст или свойство aria-label.
${getA11yRuleUrl("button-name")}`,
    "link-name": `a11y: Ссылка должна содержать текст, доступный для скринридеров. Чтобы исправить эту ошибку, передайте компоненту текст или свойство aria-label.
${getA11yRuleUrl("link-name")}`,
    "image-alt": `a11y: Изображение должно содержать альтернативный текст, который его описывает. Чтобы исправить эту ошибку, передайте компоненту свойство alt.
${getA11yRuleUrl("image-alt")}`
  }
};

// node_modules/@vkontakte/vkui/dist/components/ImageBase/helpers.js
function getFallbackIconSizeByImageBaseSize(imageSize) {
  if (imageSize <= 20) {
    return 12;
  } else if (imageSize > 20 && imageSize <= 28) {
    return 16;
  } else if (imageSize > 28 && imageSize <= 32) {
    return 20;
  } else if (imageSize > 32 && imageSize <= 44) {
    return 24;
  } else if (imageSize > 44 && imageSize <= 64) {
    return 28;
  }
  return getFallbackIconSizeByImageBaseSize.MAX_SIZE;
}
getFallbackIconSizeByImageBaseSize.MAX_SIZE = 36;
function getBadgeIconSizeByImageBaseSize(imageSize) {
  if (imageSize <= 36) {
    return 12;
  } else if (imageSize > 36 && imageSize <= 48) {
    return 16;
  } else if (imageSize > 48 && imageSize <= 64) {
    return 20;
  }
  return getBadgeIconSizeByImageBaseSize.MAX_SIZE;
}
getBadgeIconSizeByImageBaseSize.MAX_SIZE = 24;
function getOverlayIconSizeByImageBaseSize(imageSize) {
  if (imageSize <= 20) {
    return 12;
  } else if (imageSize > 20 && imageSize <= 24) {
    return 16;
  } else if (imageSize > 24 && imageSize <= 28) {
    return 18;
  } else if (imageSize > 28 && imageSize <= 40) {
    return 20;
  } else if (imageSize > 40 && imageSize <= 48) {
    return 24;
  } else if (imageSize > 48 && imageSize <= 88) {
    return 28;
  }
  return getOverlayIconSizeByImageBaseSize.MAX_SIZE;
}
getOverlayIconSizeByImageBaseSize.MAX_SIZE = 32;

// node_modules/@vkontakte/vkui/dist/components/ImageBase/types.js
var imageBaseSizes = [
  16,
  20,
  24,
  28,
  32,
  36,
  40,
  44,
  48,
  56,
  64,
  72,
  80,
  88,
  96
];

// node_modules/@vkontakte/vkui/dist/components/ImageBase/validators.js
function parseIconSizeByDisplayName(displayName) {
  if (typeof displayName !== "string") {
    return null;
  }
  const match2 = /Icon(\d+)/.exec(displayName);
  return match2 ? Number(match2[1]) : null;
}
function parseIconSizeByWidthProp(width) {
  if (typeof width !== "string" && typeof width !== "number") {
    return null;
  }
  const size4 = Number(width);
  return size4 > 0 ? size4 : null;
}
function getElementDisplayName(element) {
  var _element_type_displayName;
  return (_element_type_displayName = element.type.displayName) !== null && _element_type_displayName !== void 0 ? _element_type_displayName : null;
}
function getElementWidthProp(element) {
  var _element_props_width;
  return (_element_props_width = element.props.width) !== null && _element_props_width !== void 0 ? _element_props_width : null;
}
function getIconSizeByElement(element) {
  const sizeByDisplayName = parseIconSizeByDisplayName(getElementDisplayName(element));
  const sizeByWidth = parseIconSizeByWidthProp(getElementWidthProp(element));
  return sizeByWidth ? sizeByWidth : sizeByDisplayName;
}
function validateIconComponentSizeByImageSize(imageSize, iconProp, selectorFn, logger) {
  const iconSize2 = getIconSizeByElement(iconProp.value);
  if (iconSize2 === null) {
    return;
  }
  const result = selectorFn(imageSize);
  if (result === iconSize2 || result === selectorFn.MAX_SIZE && iconSize2 >= result) {
    return;
  }
  const iconName = getElementDisplayName(iconProp.value);
  const propMessage = iconName ? `${iconProp.name}={<${iconName} />}` : iconProp.name;
  logger(`Размер \`${propMessage}\` не соответствует дизайн-системе. Для \`size={${imageSize}}\` размер иконки для \`${iconProp.name}\` должен соответствовать <Icon${result}<name> />. Если такого размера нет, то используйте <${iconName} width={${result}} height={${result}} />`, "log");
}
var warnImageBase = warnOnce("ImageBase");
function validateFallbackIcon(imageSize, iconProp) {
  return validateIconComponentSizeByImageSize(imageSize, iconProp, getFallbackIconSizeByImageBaseSize, warnImageBase);
}
var mapOfExpectedSize = new Set(imageBaseSizes);
var arrayOfSizes = Array.from(mapOfExpectedSize).map((str) => Number(str));
var maxSize = arrayOfSizes.reduce((maxSize2, size4) => size4 > maxSize2 ? size4 : maxSize2, 0);
function validateSize(imageSize) {
  if (imageSize > maxSize || mapOfExpectedSize.has(imageSize)) {
    return;
  }
  warnImageBase(`\`size={${imageSize}}\` не соответствует дизайн-системе. Пожалуйста, используйте один из следующих вариантов: ${arrayOfSizes.join(" | ")}`, "log");
}
var warnImageBaseBadge = warnOnce("ImageBase.Badge");
function validateBadgeIcon(imageSize, iconProp) {
  if (imageSize < 24 && iconProp) {
    return warnImageBaseBadge("Не используйте бейдж при `size < 24`.", "log");
  }
  validateIconComponentSizeByImageSize(imageSize, iconProp, getBadgeIconSizeByImageBaseSize, warnImageBaseBadge);
}
var warnImageBaseOverlay = warnOnce("ImageBase.Overlay");
function validateOverlayIcon(imageSize, iconProp) {
  validateIconComponentSizeByImageSize(imageSize, iconProp, getOverlayIconSizeByImageBaseSize, warnImageBaseOverlay);
}

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBaseBadge/ImageBaseBadge.js
function DevelopmentCheck({ children }) {
  const { size: size4 } = React28.useContext(ImageBaseContext);
  if (children) {
    validateBadgeIcon(size4, {
      name: "children",
      value: children
    });
  }
  return null;
}
var backgroundStyles = {
  stroke: "vkuiImageBaseBadge--background-stroke",
  shadow: "vkuiImageBaseBadge--background-shadow"
};
var ImageBaseBadge = (_param) => {
  var { background = "shadow" } = _param, restProps = _object_without_properties(_param, [
    "background"
  ]);
  return (0, import_jsx_runtime22.jsxs)(import_jsx_runtime22.Fragment, {
    children: [
      (0, import_jsx_runtime22.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
        baseClassName: clsx("vkuiImageBaseBadge", backgroundStyles[background])
      })),
      (0, import_jsx_runtime22.jsx)(DevelopmentCheck, {
        children: restProps.children
      })
    ]
  });
};
ImageBaseBadge.displayName = "ImageBaseBadge";

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBaseOverlay/ImageBaseOverlay.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
var React33 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivityHasPointer.js
var React30 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useIsClient.js
var React29 = __toESM(require_react());
function useIsClient(initial = false) {
  const [isClient, setIsClient] = React29.useState(initial);
  useIsomorphicLayoutEffect(() => {
    setIsClient(true);
  }, []);
  return isClient;
}

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivityHasPointer.js
function useAdaptivityHasPointer(deferDetect = true) {
  const { hasPointer: hasPointerContext } = React30.useContext(AdaptivityContext);
  const needTwoPassRendering = deferDetect || hasPointerContext === void 0;
  const isClient = useIsClient(!needTwoPassRendering);
  if (!isClient || hasPointerContext !== void 0) {
    return hasPointerContext;
  }
  return hasMouse;
}

// node_modules/@vkontakte/vkui/dist/hooks/useAppearance.js
function useAppearance() {
  const { appearance } = useConfigProvider();
  return appearance !== null && appearance !== void 0 ? appearance : DEFAULT_APPEARANCE;
}

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBaseOverlay/hooks.js
var React32 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useFocusWithin.js
var React31 = __toESM(require_react());
var isFocusWithin = (ref, document2) => ref.contains(document2.activeElement);
function useFocusWithin(ref) {
  const { document: document2 } = useDOM();
  const [focusWithin, setFocusWithin] = React31.useState(() => ref.current && document2 ? isFocusWithin(ref.current, document2) : false);
  useIsomorphicLayoutEffect(function handleAutoFocus() {
    if (!document2) {
      return;
    }
    const handleFocusOrBlurEvents = () => {
      if (ref.current) {
        setFocusWithin(isFocusWithin(ref.current, document2));
      }
    };
    void handleFocusOrBlurEvents();
    document2.addEventListener("focus", handleFocusOrBlurEvents, {
      capture: true
    });
    document2.addEventListener("blur", handleFocusOrBlurEvents, {
      capture: true
    });
    return () => {
      document2.removeEventListener("focus", handleFocusOrBlurEvents, {
        capture: true
      });
      document2.removeEventListener("blur", handleFocusOrBlurEvents, {
        capture: true
      });
    };
  }, []);
  return focusWithin;
}

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBaseOverlay/hooks.js
function useNonInteractiveOverlayProps(rootRef) {
  const focusWithin = useFocusWithin(rootRef);
  const [nonInteractiveFocusShown, setNonInteractiveFocusShown] = React32.useState(false);
  function onClick(event) {
    if (event.detail > 0) {
      setNonInteractiveFocusShown(false);
    }
  }
  useIsomorphicLayoutEffect(() => {
    setNonInteractiveFocusShown(focusWithin);
  }, [
    focusWithin
  ]);
  return {
    shown: nonInteractiveFocusShown && focusWithin,
    onClick
  };
}

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBaseOverlay/ImageBaseOverlay.js
function DevelopmentCheck2({ children }) {
  const { size: size4 } = React33.useContext(ImageBaseContext);
  if (true) {
    if (children) {
      validateOverlayIcon(size4, {
        name: "children",
        value: children
      });
    }
  }
  return null;
}
var ImageBaseOverlayInteractive = (_param) => {
  var { children, className, getRootRef, disableInteractive, overlayShown } = _param, restProps = _object_without_properties(_param, [
    "children",
    "className",
    "getRootRef",
    "disableInteractive",
    "overlayShown"
  ]);
  const _useFocusVisible = useFocusVisible(), { focusVisible } = _useFocusVisible, focusEvents = _object_without_properties(_useFocusVisible, [
    "focusVisible"
  ]);
  const focusVisibleClassNames = useFocusVisibleClassName({
    focusVisible,
    mode: "inside"
  });
  return (0, import_jsx_runtime23.jsxs)(import_jsx_runtime23.Fragment, {
    children: [
      (0, import_jsx_runtime23.jsx)("div", _object_spread_props(_object_spread(_object_spread_props(_object_spread({}, restProps), {
        tabIndex: 0,
        role: "button",
        className: clsx("vkuiImageBaseOverlay--clickable", (focusVisible || overlayShown) && "vkuiImageBaseOverlay--visible", focusVisibleClassNames, className),
        ref: getRootRef,
        onKeyDown: clickByKeyboardHandler
      }), focusEvents), {
        children
      })),
      (0, import_jsx_runtime23.jsx)(DevelopmentCheck2, {
        children
      })
    ]
  });
};
var ImageBaseOverlayNonInteractive = (_param) => {
  var { className, getRootRef, disableInteractive, overlayShown: overlayShownProps } = _param, restProps = _object_without_properties(_param, [
    "className",
    "getRootRef",
    "disableInteractive",
    "overlayShown"
  ]);
  const rootRef = useExternRef(getRootRef);
  const { shown: overlayShown, onClick: onOverlayClick } = useNonInteractiveOverlayProps(rootRef);
  return (0, import_jsx_runtime23.jsx)("div", _object_spread_props(_object_spread({}, restProps), {
    ref: rootRef,
    className: clsx((overlayShown || overlayShownProps) && "vkuiImageBaseOverlay--visible", className),
    onClick: onOverlayClick
  }));
};
var ImageBaseOverlay = (_param) => {
  var { className, theme: themeProp, visibility: visibilityProp } = _param, restProps = _object_without_properties(_param, [
    "className",
    "theme",
    "visibility"
  ]);
  const appearance = useAppearance();
  const hasPointer = useAdaptivityHasPointer();
  const theme = themeProp !== null && themeProp !== void 0 ? themeProp : appearance;
  const visibility = visibilityProp !== null && visibilityProp !== void 0 ? visibilityProp : hasPointer ? "on-hover" : "always";
  const commonClassNames = clsx("vkuiImageBaseOverlay", theme === "light" && "vkuiImageBaseOverlay--theme-light", theme === "dark" && "vkuiImageBaseOverlay--theme-dark", className);
  const commonProps = {
    className: commonClassNames,
    overlayShown: visibility === "always"
  };
  if (restProps.disableInteractive) {
    return (0, import_jsx_runtime23.jsx)(ImageBaseOverlayNonInteractive, _object_spread({}, restProps, commonProps));
  }
  return (0, import_jsx_runtime23.jsx)(ImageBaseOverlayInteractive, _object_spread({}, restProps, commonProps));
};
ImageBaseOverlay.displayName = "ImageBaseOverlay";

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBase.js
var defaultSize = 24;
var getObjectFitClassName = (objectFit) => {
  switch (objectFit) {
    case "contain":
      return "vkuiImageBase__img--objectFit-contain";
    case "cover":
      return "vkuiImageBase__img--objectFit-cover";
    case "none":
      return "vkuiImageBase__img--objectFit-none";
    case "scale-down":
      return "vkuiImageBase__img--objectFit-scaleDown";
  }
  return void 0;
};
var parsePx = (value) => {
  if (value.endsWith("px")) {
    return parseInt(value);
  }
  return void 0;
};
var sizeToNumber = (size4) => {
  if (typeof size4 === "string") {
    return parsePx(size4);
  }
  return size4;
};
var ImageBase = (_param) => {
  var { alt, crossOrigin, decoding, loading, referrerPolicy, sizes, src, srcSet, useMap, fetchPriority, getRef, size: sizeProp, width: widthImg, height: heightImg, widthSize, heightSize, style, noBorder = false, fallbackIcon: fallbackIconProp, children, onLoad, onError, withTransparentBackground, objectFit = "cover", keepAspectRatio = false } = _param, restProps = _object_without_properties(_param, [
    "alt",
    "crossOrigin",
    "decoding",
    "loading",
    "referrerPolicy",
    "sizes",
    "src",
    "srcSet",
    "useMap",
    "fetchPriority",
    "getRef",
    "size",
    "width",
    "height",
    "widthSize",
    "heightSize",
    "style",
    "noBorder",
    "fallbackIcon",
    "children",
    "onLoad",
    "onError",
    "withTransparentBackground",
    "objectFit",
    "keepAspectRatio"
  ]);
  const size4 = sizeProp !== null && sizeProp !== void 0 ? sizeProp : minOr([
    sizeToNumber(widthSize),
    sizeToNumber(heightSize)
  ], defaultSize);
  const width = widthSize !== null && widthSize !== void 0 ? widthSize : keepAspectRatio ? void 0 : size4;
  const height = heightSize !== null && heightSize !== void 0 ? heightSize : keepAspectRatio ? void 0 : size4;
  const [loaded, setLoaded] = React34.useState(false);
  const [failed, setFailed] = React34.useState(false);
  const hasSrc = src || srcSet;
  const needShowFallbackIcon = (failed || !hasSrc) && React34.isValidElement(fallbackIconProp);
  const fallbackIcon = needShowFallbackIcon ? fallbackIconProp : null;
  if (true) {
    validateSize(size4);
    if (fallbackIcon) {
      validateFallbackIcon(size4, {
        name: "fallbackIcon",
        value: fallbackIcon
      });
    }
  }
  const handleImageLoad = (event) => {
    if (loaded) {
      return;
    }
    setLoaded(true);
    setFailed(false);
    onLoad === null || onLoad === void 0 ? void 0 : onLoad(event);
  };
  const handleImageError = (event) => {
    setLoaded(false);
    setFailed(true);
    onError === null || onError === void 0 ? void 0 : onError(event);
  };
  const imgRef = useExternRef(getRef);
  const isOnLoadStatusCheckedRef = React34.useRef(false);
  React34.useEffect(function dispatchLoadEventForAlreadyLoadedResourceIfReactInitializedLater() {
    if (isOnLoadStatusCheckedRef.current) {
      return;
    }
    isOnLoadStatusCheckedRef.current = true;
    if (imgRef.current && imgRef.current.complete && !loaded) {
      const event = new Event("load");
      imgRef.current.dispatchEvent(event);
    }
  }, [
    imgRef,
    loaded
  ]);
  return (0, import_jsx_runtime24.jsx)(ImageBaseContext.Provider, {
    value: {
      size: size4
    },
    children: (0, import_jsx_runtime24.jsxs)(Clickable, _object_spread_props(_object_spread({
      style: _object_spread({
        width,
        height
      }, style),
      baseClassName: clsx("vkuiImageBase", loaded && "vkuiImageBase--loaded", withTransparentBackground && "vkuiImageBase--transparent-background")
    }, restProps), {
      children: [
        hasSrc && (0, import_jsx_runtime24.jsx)("img", _object_spread({
          ref: imgRef,
          alt,
          className: clsx("vkuiImageBase__img", getObjectFitClassName(objectFit), keepAspectRatio && "vkuiImageBase__img--keepRatio"),
          crossOrigin,
          decoding,
          loading,
          referrerPolicy,
          style: keepAspectRatio ? {
            width: widthImg || width,
            height: heightImg || height
          } : void 0,
          sizes,
          src,
          srcSet,
          useMap,
          width: widthImg,
          height: heightImg,
          onLoad: handleImageLoad,
          onError: handleImageError
        }, getFetchPriorityProp(fetchPriority))),
        fallbackIcon && (0, import_jsx_runtime24.jsx)("div", {
          className: "vkuiImageBase__fallback",
          children: fallbackIcon
        }),
        children && (0, import_jsx_runtime24.jsx)("div", {
          className: "vkuiImageBase__children",
          children
        }),
        !noBorder && (0, import_jsx_runtime24.jsx)("div", {
          "aria-hidden": true,
          className: "vkuiImageBase__border"
        })
      ]
    }))
  });
};
ImageBase.displayName = "ImageBase";
ImageBase.Badge = ImageBaseBadge;
ImageBase.Badge.displayName = "ImageBase.Badge";
ImageBase.Overlay = ImageBaseOverlay;
ImageBase.Overlay.displayName = "ImageBase.Overlay";

// node_modules/@vkontakte/vkui/dist/components/Button/Button.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime());
var React38 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Spinner/Spinner.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime());
var React37 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/animation/useCSSKeyframesAnimationController.js
var import_react6 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/usePrevious.js
var React35 = __toESM(require_react());
function usePrevious(value) {
  const ref = React35.useRef();
  React35.useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}

// node_modules/@vkontakte/vkui/dist/lib/animation/useCSSKeyframesAnimationController.js
var useCSSKeyframesAnimationController = (stateProp, { onEnter: onEnterProp, onEntering, onEntered, onExit: onExitProp, onExiting, onExited } = {}, disableInitAnimation = false) => {
  const [state, setState] = (0, import_react6.useState)(() => disableInitAnimation ? stateProp === "enter" ? "entered" : "exited" : stateProp);
  const prevState = usePrevious(stateProp);
  const onAnimationStart = () => {
    if (state === "enter") {
      setState("entering");
      if (onEntering) {
        onEntering();
      }
    } else if (state === "exit") {
      setState("exiting");
      if (onExiting) {
        onExiting();
      }
    }
  };
  const onAnimationEnd = () => {
    if (state === "entering") {
      setState("entered");
      if (onEntered) {
        onEntered();
      }
    } else if (state === "exiting") {
      setState("exited");
      if (onExited) {
        onExited();
      }
    }
  };
  const onEnter = useStableCallback(onEnterProp || noop);
  const onExit = useStableCallback(onExitProp || noop);
  useIsomorphicLayoutEffect(function updateState() {
    if (prevState === stateProp) {
      return;
    }
    switch (stateProp) {
      case "enter":
        if (state === "entering" || state === "entered") {
          break;
        }
        setState("enter");
        onEnter();
        break;
      case "exit":
        if (state === "exiting" || state === "exited") {
          break;
        }
        setState("exit");
        onExit();
        break;
    }
  }, [
    state,
    prevState,
    stateProp,
    onEnter,
    onExit
  ]);
  return [
    state,
    {
      onAnimationStart,
      onAnimationEnd
    }
  ];
};

// node_modules/@vkontakte/vkui/dist/lib/animation/useReducedMotion.js
var React36 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/matchMedia.js
function matchMediaListAddListener(mediaQueryList, listener) {
  mediaQueryList.addEventListener ? mediaQueryList.addEventListener("change", listener) : mediaQueryList.addListener(listener);
}
function matchMediaListRemoveListener(mediaQueryList, listener) {
  mediaQueryList.removeEventListener ? mediaQueryList.removeEventListener("change", listener) : mediaQueryList.removeListener(listener);
}

// node_modules/@vkontakte/vkui/dist/lib/animation/useReducedMotion.js
var REDUCE_MOTION_MEDIA_QUERY = "screen and (prefers-reduced-motion: reduce)";
var useReducedMotion = () => {
  const { window: window2 } = useDOM();
  const initial = React36.useMemo(() => window2 ? window2.matchMedia(REDUCE_MOTION_MEDIA_QUERY).matches : (
    /* istanbul ignore next: на текущий момент, покрытие данного кейса неинтересно  */
    false
  ), [
    window2
  ]);
  const reducedMotion = React36.useRef(initial);
  useIsomorphicLayoutEffect(() => {
    if (!window2) {
      return;
    }
    const match2 = window2.matchMedia(REDUCE_MOTION_MEDIA_QUERY);
    reducedMotion.current = match2.matches;
    const handleMediaQueryChange = (event) => {
      reducedMotion.current = event.matches;
    };
    matchMediaListAddListener(match2, handleMediaQueryChange);
    return () => matchMediaListRemoveListener(match2, handleMediaQueryChange);
  }, [
    window2
  ]);
  return reducedMotion.current;
};

// node_modules/@vkontakte/vkui/dist/lib/animation/rubberbandIfOutOfBounds.js
function rubberband(distance, dimension, constant) {
  if (dimension === 0 || Math.abs(dimension) === Infinity) {
    return Math.pow(distance, constant * 5);
  }
  return distance * dimension * constant / (dimension + constant * distance);
}
function rubberbandIfOutOfBounds(position, min3, max3, constant = 0.15) {
  if (constant === 0) {
    return clamp2(position, min3, max3);
  }
  if (position < min3) {
    return -rubberband(min3 - position, max3 - min3, constant) + min3;
  }
  if (position > max3) {
    return +rubberband(position - max3, max3 - min3, constant) + max3;
  }
  return position;
}

// node_modules/@vkontakte/vkui/dist/lib/animation/fades.js
var animationFadeClassNames = {
  in: "vkui-anim-fade-in",
  out: "vkui-anim-fade-out"
};

// node_modules/@vkontakte/vkui/dist/lib/animation/transformOrigin.js
var transformOriginClassNames = {
  "top": "vkui-anim-transform-origin-top",
  "top-start": "vkui-anim-transform-origin-top-start",
  "top-end": "vkui-anim-transform-origin-top-end",
  "right": "vkui-anim-transform-origin-right",
  "right-start": "vkui-anim-transform-origin-right-start",
  "right-end": "vkui-anim-transform-origin-right-end",
  "bottom": "vkui-anim-transform-origin-bottom",
  "bottom-start": "vkui-anim-transform-origin-bottom-start",
  "bottom-end": "vkui-anim-transform-origin-bottom-end",
  "left": "vkui-anim-transform-origin-left",
  "left-start": "vkui-anim-transform-origin-left-start",
  "left-end": "vkui-anim-transform-origin-left-end"
};

// node_modules/@vkontakte/vkui/dist/components/VisuallyHidden/VisuallyHidden.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime());
var VisuallyHidden = (_param) => {
  var { Component: Component3 = "span", baseClassName } = _param, restProps = _object_without_properties(_param, [
    "Component",
    "baseClassName"
  ]);
  return (0, import_jsx_runtime25.jsx)(RootComponent, _object_spread_props(_object_spread({
    Component: Component3
  }, restProps), {
    baseClassName: clsx(baseClassName, "vkuiVisuallyHidden", Component3 === "input" && "vkuiVisuallyHidden--focusable-input")
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Spinner/Spinner.js
var Spinner = React37.memo((_param) => {
  var { size: size4 = "regular", children = "Загружается...", disableAnimation = false, noColor = false } = _param, restProps = _object_without_properties(_param, [
    "size",
    "children",
    "disableAnimation",
    "noColor"
  ]);
  const isReducedMotion = useReducedMotion();
  const SpinnerIcon = {
    small: Icon16Spinner,
    regular: Icon24Spinner,
    medium: Icon32Spinner,
    large: Icon44Spinner
  }[size4];
  let svgAnimateElement = null;
  const [isReadyForSetSVGAnimateElement, setIsReadyForSetSVGAnimateElement] = React37.useState(disableAnimation ? true : false);
  React37.useEffect(function waitReactHydrationBeforeSetSVGAnimateElement() {
    setIsReadyForSetSVGAnimateElement(true);
  }, []);
  if (isReadyForSetSVGAnimateElement && !disableAnimation) {
    if (isReducedMotion) {
      svgAnimateElement = (0, import_jsx_runtime26.jsx)("animate", {
        attributeName: "opacity",
        keyTimes: "0; 0.5; 1",
        values: "1; 0.1; 1",
        begin: "0s",
        dur: "2s",
        repeatCount: "indefinite"
      });
    } else {
      const center = {
        small: 8,
        regular: 12,
        medium: 16,
        large: 22
      }[size4];
      svgAnimateElement = (0, import_jsx_runtime26.jsx)("animateTransform", {
        attributeType: "XML",
        attributeName: "transform",
        type: "rotate",
        from: `0 ${center} ${center}`,
        to: `360 ${center} ${center}`,
        dur: "0.7s",
        repeatCount: "indefinite"
      });
    }
  }
  return (0, import_jsx_runtime26.jsxs)(RootComponent, _object_spread_props(_object_spread({
    Component: "span",
    role: "status"
  }, restProps), {
    baseClassName: clsx("vkuiSpinner", noColor && "vkuiSpinner--no-color"),
    children: [
      (0, import_jsx_runtime26.jsx)(SpinnerIcon, {
        children: svgAnimateElement
      }),
      hasReactNode(children) && (0, import_jsx_runtime26.jsx)(VisuallyHidden, {
        children
      })
    ]
  }));
});
Spinner.displayName = "Spinner";

// node_modules/@vkontakte/vkui/dist/components/Button/Button.js
var stylesSize = {
  s: "vkuiButton--size-s",
  m: "vkuiButton--size-m",
  l: "vkuiButton--size-l"
};
var stylesMode = {
  primary: "vkuiButton--mode-primary",
  secondary: "vkuiButton--mode-secondary",
  tertiary: "vkuiButton--mode-tertiary",
  outline: "vkuiButton--mode-outline",
  link: "vkuiButton--mode-link"
};
var stylesAppearance = {
  "accent": "vkuiButton--appearance-accent",
  "positive": "vkuiButton--appearance-positive",
  "negative": "vkuiButton--appearance-negative",
  "neutral": "vkuiButton--appearance-neutral",
  "overlay": "vkuiButton--appearance-overlay",
  "accent-invariable": "vkuiButton--appearance-accent-invariable"
};
var stylesAlign = {
  left: "vkuiButton--align-left",
  center: "vkuiButton--align-center",
  right: "vkuiButton--align-right"
};
var sizeYClassNames9 = {
  none: "vkuiButton--sizeY-none",
  regular: "vkuiButton--sizeY-regular"
};
var Button = (_param) => {
  var { size: size4 = "s", mode = "primary", appearance = "accent", stretched = false, align = "center", children, before, after, getRootRef, loading, onClick, className, disableSpinnerAnimation, rounded } = _param, restProps = _object_without_properties(_param, [
    "size",
    "mode",
    "appearance",
    "stretched",
    "align",
    "children",
    "before",
    "after",
    "getRootRef",
    "loading",
    "onClick",
    "className",
    "disableSpinnerAnimation",
    "rounded"
  ]);
  const hasIcons = Boolean(before || after);
  const hasIconOnly = !children && Boolean(after) !== Boolean(before);
  const { sizeY = "none" } = useAdaptivity();
  const platform3 = usePlatform();
  return (0, import_jsx_runtime27.jsxs)(Tappable, _object_spread_props(_object_spread({
    hoverMode: "vkuiButton--hover",
    activeMode: "vkuiButton--active",
    Component: restProps.href ? "a" : "button",
    focusVisibleMode: "outside"
  }, restProps), {
    onClick: loading ? void 0 : onClick,
    className: clsx(className, "vkuiButton", stylesSize[size4], stylesMode[mode], stylesAppearance[appearance], stylesAlign[align], sizeY !== "compact" && sizeYClassNames9[sizeY], platform3 === "ios" && "vkuiButton--ios", stretched && "vkuiButton--stretched", hasIcons && "vkuiButton--with-icon", hasIconOnly && !stretched && "vkuiButton--singleIcon", loading && "vkuiButton--loading", rounded && "vkuiButton--rounded"),
    getRootRef,
    children: [
      loading && (0, import_jsx_runtime27.jsx)(Spinner, {
        size: "small",
        className: "vkuiButton__spinner",
        disableAnimation: disableSpinnerAnimation
      }),
      (0, import_jsx_runtime27.jsxs)("span", {
        className: "vkuiButton__in",
        children: [
          hasReactNode(before) && (0, import_jsx_runtime27.jsx)("span", {
            className: "vkuiButton__before",
            role: "presentation",
            "data-testid": false ? "before" : void 0,
            children: before
          }),
          hasReactNode(children) && (0, import_jsx_runtime27.jsx)("span", {
            className: "vkuiButton__content",
            "data-testid": false ? "children" : void 0,
            children
          }),
          hasReactNode(after) && (0, import_jsx_runtime27.jsx)("span", {
            className: "vkuiButton__after",
            role: "presentation",
            "data-testid": false ? "after" : void 0,
            children: after
          })
        ]
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/IconButton/IconButton.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime());
var sizeYClassNames10 = {
  none: "vkuiIconButton--sizeY-none",
  compact: "vkuiIconButton--sizeY-compact"
};
var warn = warnOnce("IconButton");
var IconButton = (_param) => {
  var { label, children, className } = _param, restProps = _object_without_properties(_param, [
    "label",
    "children",
    "className"
  ]);
  const platform3 = usePlatform();
  const { sizeY = "none" } = useAdaptivity();
  if (true) {
    const isAccessible = hasAccessibleName(_object_spread({
      children: [
        children,
        label
      ]
    }, restProps));
    if (!isAccessible) {
      warn(COMMON_WARNINGS.a11y[restProps.href ? "link-name" : "button-name"], "error");
    }
  }
  return (0, import_jsx_runtime28.jsxs)(Tappable, _object_spread_props(_object_spread({
    activeEffectDelay: 200,
    activeMode: "background",
    Component: restProps.href ? "a" : "button"
  }, restProps), {
    className: clsx("vkuiIconButton", sizeY !== "regular" && sizeYClassNames10[sizeY], platform3 === "ios" && "vkuiIconButton--ios", className),
    children: [
      label && (0, import_jsx_runtime28.jsx)(VisuallyHidden, {
        children: label
      }),
      children
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ToolButton/ToolButton.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime());

// node_modules/@vkontakte/vkui/dist/components/AdaptiveIconRenderer/AdaptiveIconRenderer.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime());
var React40 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivityConditionalRender/useAdaptivityConditionalRender.js
var React39 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivityConditionalRender/constants.js
var sizeXCompactClassNames = {
  mq: {
    className: "vkui-sizeX--compact-mq"
  },
  compact: {
    className: "vkui-sizeX--compact-forced"
  }
};
var sizeXRegularClassNames = {
  mq: {
    className: "vkui-sizeX--regular-mq"
  },
  regular: {
    className: "vkui-sizeX--regular-forced"
  }
};
var sizeYCompactClassNames = {
  mq: {
    className: "vkui-sizeY--compact-mq"
  },
  compact: {
    className: "vkui-sizeY--compact-forced"
  }
};
var sizeYRegularClassNames = {
  mq: {
    className: "vkui-sizeY--regular-mq"
  },
  regular: {
    className: "vkui-sizeY--regular-forced"
  }
};
var viewWidthClassNames = {
  tabletMinus: {
    mq: {
      className: "vkui-viewWidth--tabletMinus-mq"
    },
    forced: {
      className: "vkui-viewWidth--tabletMinus-forced"
    }
  },
  tabletPlus: {
    mq: {
      className: "vkui-viewWidth--tabletPlus-mq"
    },
    forced: {
      className: "vkui-viewWidth--tabletPlus-forced"
    }
  }
};
var deviceTypeClassNames = {
  mobile: {
    mq: {
      className: "vkui-deviceType--mobile-mq"
    },
    forced: {
      className: "vkui-deviceType--mobile-forced"
    }
  },
  desktop: {
    mq: {
      className: "vkui-deviceType--desktop-mq"
    },
    forced: {
      className: "vkui-deviceType--desktop-forced"
    }
  }
};

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivityConditionalRender/helpers.js
var getAdaptiveSizeType = (type, compactClassNames, regularClassNames) => {
  return {
    compact: type === void 0 ? compactClassNames.mq : type === "compact" ? compactClassNames[type] : false,
    regular: type === void 0 ? regularClassNames.mq : type === "regular" ? regularClassNames[type] : false
  };
};
var getAdaptiveViewWidth = (viewWidth, viewWidthClassNames2) => {
  return {
    tabletMinus: viewWidth === void 0 ? viewWidthClassNames2.tabletMinus.mq : viewWidth < ViewWidth.TABLET ? viewWidthClassNames2.tabletMinus.forced : false,
    tabletPlus: viewWidth === void 0 ? viewWidthClassNames2.tabletPlus.mq : viewWidth >= ViewWidth.TABLET ? viewWidthClassNames2.tabletPlus.forced : false
  };
};
var getAdaptiveDeviceType = (viewWidth, viewHeight, hasPointer, platform3, deviceTypeClassNames2) => {
  const isDesktop = tryToCheckIsDesktop(viewWidth, viewHeight, hasPointer, platform3);
  if (isDesktop === null) {
    return {
      mobile: deviceTypeClassNames2.mobile.mq,
      desktop: deviceTypeClassNames2.desktop.mq
    };
  }
  if (isDesktop) {
    return {
      mobile: false,
      desktop: deviceTypeClassNames2.desktop.forced
    };
  }
  return {
    mobile: deviceTypeClassNames2.mobile.forced,
    desktop: false
  };
};

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivityConditionalRender/useAdaptivityConditionalRender.js
var useAdaptivityConditionalRender = () => {
  const { sizeX: sizeXContext, sizeY: sizeYContext, viewWidth: viewWidthContext, viewHeight: viewHeightContext, hasPointer: hasPointerContext } = React39.useContext(AdaptivityContext);
  const platform3 = usePlatform();
  return React39.useMemo(() => {
    const sizeX = getAdaptiveSizeType(sizeXContext, sizeXCompactClassNames, sizeXRegularClassNames);
    const sizeY = getAdaptiveSizeType(sizeYContext, sizeYCompactClassNames, sizeYRegularClassNames);
    const viewWidth = getAdaptiveViewWidth(viewWidthContext, viewWidthClassNames);
    const deviceType = getAdaptiveDeviceType(viewWidthContext, viewHeightContext, hasPointerContext, platform3, deviceTypeClassNames);
    return {
      sizeX,
      sizeY,
      viewWidth,
      deviceType
    };
  }, [
    sizeXContext,
    sizeYContext,
    viewWidthContext,
    viewHeightContext,
    hasPointerContext,
    platform3
  ]);
};

// node_modules/@vkontakte/vkui/dist/components/AdaptiveIconRenderer/AdaptiveIconRenderer.js
var AdaptiveIconRenderer = ({ IconCompact, IconRegular }) => {
  const { sizeY } = useAdaptivityConditionalRender();
  return (0, import_jsx_runtime29.jsxs)(React40.Fragment, {
    children: [
      sizeY.compact && (0, import_jsx_runtime29.jsx)(IconCompact, {
        className: sizeY.compact.className
      }),
      sizeY.regular && (0, import_jsx_runtime29.jsx)(IconRegular, {
        className: sizeY.regular.className
      })
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/ToolButton/ToolButton.js
var stylesMode2 = {
  primary: "vkuiToolButton--mode-primary",
  secondary: "vkuiToolButton--mode-secondary",
  tertiary: "vkuiToolButton--mode-tertiary",
  outline: "vkuiToolButton--mode-outline"
};
var stylesAppearance2 = {
  accent: "vkuiToolButton--appearance-accent",
  neutral: "vkuiToolButton--appearance-neutral"
};
var stylesDirection = {
  row: "vkuiToolButton--direction-row",
  column: "vkuiToolButton--direction-column"
};
var sizeYClassNames11 = {
  none: "vkuiToolButton--sizeY-none",
  regular: "vkuiToolButton--sizeY-regular"
};
var ToolButton = (_param) => {
  var { mode = "primary", appearance = "accent", direction = "row", className, children, IconCompact, IconRegular, rounded } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "appearance",
    "direction",
    "className",
    "children",
    "IconCompact",
    "IconRegular",
    "rounded"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const hasChildren = hasReactNode(children);
  return (0, import_jsx_runtime30.jsxs)(Tappable, _object_spread_props(_object_spread({
    hoverMode: "vkuiToolButton--hover",
    activeMode: "vkuiToolButton--active",
    Component: restProps.href ? "a" : "button",
    focusVisibleMode: "outside",
    className: clsx(className, "vkuiToolButton", rounded && getRoundedClassName(direction, hasChildren), hasChildren && direction === "row" && "vkuiToolButton--withFakeEndIcon", stylesMode2[mode], stylesAppearance2[appearance], stylesDirection[direction], sizeY !== "compact" && sizeYClassNames11[sizeY])
  }, restProps), {
    children: [
      (0, import_jsx_runtime30.jsx)(AdaptiveIconRenderer, {
        IconCompact,
        IconRegular
      }),
      hasChildren && (0, import_jsx_runtime30.jsx)("span", {
        className: "vkuiToolButton__text",
        children
      })
    ]
  }));
};
function getRoundedClassName(direction, hasChildren) {
  switch (direction) {
    case "row":
      return "vkuiToolButton--rounded";
    case "column":
      return hasChildren ? void 0 : "vkuiToolButton--rounded";
  }
}

// node_modules/@vkontakte/vkui/dist/components/Root/Root.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime());
var React43 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/getNavId.js
function getNavId(props, warn26) {
  const id = props.nav || props.id;
  if (!id && warn26) {
    warn26('Навигационный элемент должен иметь свойство "nav" или "id"', "error");
  }
  return id;
}

// node_modules/@vkontakte/vkui/dist/components/NavTransitionContext/NavTransitionContext.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime());
var React41 = __toESM(require_react());
var TransitionContext = React41.createContext({
  entering: false
});
var useNavTransition = () => React41.useContext(TransitionContext);
var NavTransitionProvider = ({ children, entering }) => {
  const parentContext = useNavTransition();
  const contextValue = useObjectMemo({
    entering: parentContext.entering || entering
  });
  return (0, import_jsx_runtime31.jsx)(TransitionContext.Provider, {
    value: contextValue,
    children
  });
};

// node_modules/@vkontakte/vkui/dist/components/NavTransitionDirectionContext/NavTransitionDirectionContext.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime());
var React42 = __toESM(require_react());
var TransitionDirectionContext = React42.createContext(void 0);
var NavTransitionDirectionProvider = ({ children, isBack: isBackProp }) => {
  const parentIsBack = React42.useContext(TransitionDirectionContext);
  const isBack = isBackProp !== void 0 ? isBackProp : parentIsBack;
  const [isBackOnMount] = React42.useState(isBack);
  return (0, import_jsx_runtime32.jsx)(TransitionDirectionContext.Provider, {
    value: isBackOnMount,
    children
  });
};
var useNavDirection = () => {
  const isBack = React42.useContext(TransitionDirectionContext);
  const transitionDirection = isBack === void 0 ? void 0 : isBack ? "backwards" : "forwards";
  return transitionDirection;
};

// node_modules/@vkontakte/vkui/dist/components/Root/Root.js
var warn2 = warnOnce("Root");
var Root = (_param) => {
  var { children, activeView: _activeView, onTransition, nav } = _param, restProps = _object_without_properties(_param, [
    "children",
    "activeView",
    "onTransition",
    "nav"
  ]);
  const scroll = React43.useContext(ScrollContext);
  const platform3 = usePlatform();
  const { document: document2 } = useDOM();
  const scrolls = React43.useRef({}).current;
  const viewNodes = React43.useRef({}).current;
  const { transitionMotionEnabled = true } = useConfigProvider();
  const { animate: animate3 } = React43.useContext(SplitColContext);
  const disableAnimation = !transitionMotionEnabled || !animate3;
  const views = React43.Children.toArray(children);
  const [{ prevView, activeView, transition, isBack }, _setState] = React43.useState({
    activeView: _activeView,
    transition: false
  });
  const transitionTo = (panel) => {
    if (panel !== activeView) {
      const viewIds = views.map((view) => getNavId(view.props, warn2));
      const isBack2 = viewIds.indexOf(panel) < viewIds.indexOf(activeView);
      scrolls[activeView] = scroll.getScroll().y;
      _setState({
        activeView: panel,
        prevView: activeView,
        transition: !disableAnimation,
        isBack: isBack2
      });
    }
  };
  const finishTransition = React43.useCallback(() => _setState({
    activeView,
    prevView,
    isBack,
    transition: false
  }), [
    activeView,
    isBack,
    prevView
  ]);
  useIsomorphicLayoutEffect(() => {
    document2.activeElement.blur();
  }, [
    activeView
  ]);
  useIsomorphicLayoutEffect(() => transitionTo(_activeView), [
    _activeView
  ]);
  useIsomorphicLayoutEffect(() => {
    if (!transition && prevView) {
      scroll.scrollTo(0, isBack ? scrolls[activeView] : 0);
      onTransition && onTransition({
        isBack: Boolean(isBack),
        from: prevView,
        to: activeView
      });
    }
  }, [
    transition,
    prevView
  ]);
  React43.useEffect(function onAnimationEndFallback() {
    if (transition && disableAnimation) {
      finishTransition();
    }
  }, [
    transition,
    disableAnimation,
    finishTransition
  ]);
  const onAnimationEnd = () => {
    finishTransition();
  };
  return (0, import_jsx_runtime33.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiRoot", platform3 === "ios" && "vkuiRoot--ios", transition && "vkuiRoot--transition"),
    children: views.map((view) => {
      const viewId = getNavId(view.props, warn2);
      if (viewId !== activeView && !(transition && viewId === prevView)) {
        return null;
      }
      const isTransitionTarget = transition && viewId === (isBack ? prevView : activeView);
      const compensateScroll = transition && (viewId === prevView || isBack && viewId === activeView);
      var _scrolls_viewId;
      return (0, import_jsx_runtime33.jsx)("div", {
        ref: (e) => viewId && (viewNodes[viewId] = e),
        onAnimationEnd: isTransitionTarget ? onAnimationEnd : void 0,
        className: clsx("vkuiRoot__view", transition && viewId === prevView && isBack && "vkuiRoot__view--hide-back", transition && viewId === prevView && !isBack && "vkuiRoot__view--hide-forward", transition && viewId === activeView && isBack && "vkuiRoot__view--show-back", transition && viewId === activeView && !isBack && "vkuiRoot__view--show-forward"),
        children: (0, import_jsx_runtime33.jsx)(NavTransitionDirectionProvider, {
          isBack,
          children: (0, import_jsx_runtime33.jsx)(NavTransitionProvider, {
            entering: transition && viewId === activeView,
            children: (0, import_jsx_runtime33.jsx)("div", {
              className: "vkuiRoot__scrollCompensation",
              style: {
                marginTop: compensateScroll ? viewId && -((_scrolls_viewId = scrolls[viewId]) !== null && _scrolls_viewId !== void 0 ? _scrolls_viewId : 0) : void 0
              },
              children: view
            })
          })
        })
      }, viewId);
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/View/View.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime());
var React51 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/NavIdContext/NavIdContext.js
var React44 = __toESM(require_react());
var NavViewIdContext = React44.createContext(void 0);
var NavPanelIdContext = React44.createContext(void 0);

// node_modules/@vkontakte/vkui/dist/components/Touch/Touch.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime());
var React45 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/touch/functions.js
var coordX = (event) => {
  if ("clientX" in event) {
    return event.clientX;
  }
  return event.changedTouches && event.changedTouches[0].clientX;
};
var coordY = (event) => {
  if ("clientY" in event) {
    return event.clientY;
  }
  return event.changedTouches && event.changedTouches[0].clientY;
};
var touchEnabled = () => canUseDOM && "ontouchstart" in window;
function rubber(offset4, dimension, resistanceRate, isAndroid) {
  if (isAndroid || offset4 < 0) {
    return offset4;
  }
  const offsettedResistance = offset4 * resistanceRate;
  return offsettedResistance * dimension / (offsettedResistance + dimension);
}

// node_modules/@vkontakte/vkui/dist/lib/touch/UIPanGestureRecognizer.js
var DEFAULT_INITIAL_TIME = 0;
var MILLISECONDS = 1e3;
var UIPanGestureRecognizer = class {
  setInitialTimeOnce() {
    if (this.initialTime === DEFAULT_INITIAL_TIME) {
      this.initialTime = Date.now();
    }
  }
  setStartCoords(event) {
    const { clientX, clientY } = getFirstTouchEventData(event);
    this.x1 = clientX;
    this.y1 = clientY;
  }
  setEndCoords(event) {
    const { clientX, clientY } = getFirstTouchEventData(event);
    this.x2 = clientX;
    this.y2 = clientY;
  }
  delta() {
    return {
      x: this.x2 - this.x1,
      y: this.y2 - this.y1
    };
  }
  distance() {
    const { x, y } = this.delta();
    return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
  }
  velocity() {
    const deltaTime = (Date.now() - this.initialTime) / MILLISECONDS;
    if (deltaTime <= 0) {
      return {
        x: 0,
        y: 0
      };
    }
    const { x, y } = this.delta();
    return {
      x: x / deltaTime,
      y: y / deltaTime
    };
  }
  angle() {
    const deltaX = this.x2 - this.x1;
    const deltaY = this.y2 - this.y1;
    const radians = Math.atan2(deltaY, deltaX);
    const degrees = radians * 180 / Math.PI;
    return degrees < 0 ? 360 + degrees : degrees;
  }
  reset() {
    this.initialTime = DEFAULT_INITIAL_TIME;
    this.x1 = this.y1 = 0;
    this.x2 = this.y2 = 0;
  }
  constructor() {
    _define_property(this, "initialTime", DEFAULT_INITIAL_TIME);
    _define_property(this, "x1", 0);
    _define_property(this, "y1", 0);
    _define_property(this, "x2", 0);
    _define_property(this, "y2", 0);
  }
};

// node_modules/@vkontakte/vkui/dist/components/Touch/Touch.js
var Touch = (_param) => {
  var { onStart, onStartX, onStartY, onMove, onMoveX, onMoveY, onEnter, onLeave, onEnd, onEndX, onEndY, onClickCapture, usePointerHover, slideThreshold = 5, useCapture = false, Component: Component3 = "div", getRootRef, noSlideClick = false, stopPropagation: stopPropagation3 = false } = _param, restProps = _object_without_properties(_param, [
    "onStart",
    "onStartX",
    "onStartY",
    "onMove",
    "onMoveX",
    "onMoveY",
    "onEnter",
    "onLeave",
    "onEnd",
    "onEndX",
    "onEndY",
    "onClickCapture",
    "usePointerHover",
    "slideThreshold",
    "useCapture",
    "Component",
    "getRootRef",
    "noSlideClick",
    "stopPropagation"
  ]);
  const [isTouchEnabled] = React45.useState(touchEnabled);
  const gestureRef = React45.useRef(null);
  const didSlide = React45.useRef(false);
  const disposeTargetNativeGestureEvents = React45.useRef(null);
  const cleanupTargetNativeGestureEvents = () => {
    gestureRef.current = null;
    if (disposeTargetNativeGestureEvents.current) {
      disposeTargetNativeGestureEvents.current();
      disposeTargetNativeGestureEvents.current = null;
    }
  };
  React45.useEffect(() => cleanupTargetNativeGestureEvents, []);
  const handleNativePointerUp = useStableCallback((event) => {
    const gesture = gestureRef.current;
    if (!gesture) {
      return;
    }
    if (gesture.isPressed) {
      dispatchUserHandlers(event, gesture, [
        onEnd,
        onEndX,
        onEndY
      ], stopPropagation3);
    }
    if (isTouchEnabled) {
      if (gesture.isSlide) {
        didSlide.current = false;
      }
      if (onLeave) {
        onLeave(event);
      }
    } else {
      didSlide.current = Boolean(gesture.isSlide);
    }
    cleanupTargetNativeGestureEvents();
  });
  const handleNativePointerMove = useStableCallback((event) => {
    const gesture = gestureRef.current;
    if (!gesture) {
      return;
    }
    const clientX = coordX(event);
    const clientY = coordY(event);
    const shiftX = clientX - gesture.startX;
    const shiftY = clientY - gesture.startY;
    const shiftXAbs = Math.abs(shiftX);
    const shiftYAbs = Math.abs(shiftY);
    if ("touches" in event && event.touches.length > 1) {
      return handleNativePointerUp(event);
    }
    if (!gesture.isX && !gesture.isY) {
      const willBeX = shiftXAbs >= slideThreshold && shiftXAbs > shiftYAbs;
      const willBeY = shiftYAbs >= slideThreshold && shiftYAbs > shiftXAbs;
      const willBeSlidedX = willBeX && (!!onMoveX || !!onMove);
      const willBeSlidedY = willBeY && (!!onMoveY || !!onMove);
      gesture.isY = willBeY;
      gesture.isX = willBeX;
      gesture.isSlideX = willBeSlidedX;
      gesture.isSlideY = willBeSlidedY;
      gesture.isSlide = willBeSlidedX || willBeSlidedY;
    }
    if (gesture.isSlide) {
      gesture.clientX = clientX;
      gesture.clientY = clientY;
      gesture.shiftX = shiftX;
      gesture.shiftY = shiftY;
      gesture.shiftXAbs = shiftXAbs;
      gesture.shiftYAbs = shiftYAbs;
      dispatchUserHandlers(event, gesture, [
        onMove,
        onMoveX,
        onMoveY
      ], stopPropagation3);
    }
  });
  const handlePointerDown = (event) => {
    const nativeEvent = event.nativeEvent;
    gestureRef.current = initGesture(coordX(nativeEvent), coordY(nativeEvent));
    const shouldCallDirectionHandlerOnlyIsSlide = false;
    dispatchUserHandlers(event, gestureRef.current, [
      onStart,
      onStartX,
      onStartY
    ], stopPropagation3, shouldCallDirectionHandlerOnlyIsSlide);
    const eventOptions2 = {
      capture: useCapture,
      passive: false
    };
    if (isTouchEnabled) {
      if (isHTMLElement(event.target)) {
        const target = event.target;
        target.addEventListener("touchmove", handleNativePointerMove, eventOptions2);
        target.addEventListener("touchend", handleNativePointerUp, eventOptions2);
        target.addEventListener("touchcancel", handleNativePointerUp, eventOptions2);
        disposeTargetNativeGestureEvents.current = () => {
          target.removeEventListener("touchmove", handleNativePointerMove, eventOptions2);
          target.removeEventListener("touchend", handleNativePointerUp, eventOptions2);
          target.removeEventListener("touchcancel", handleNativePointerUp, eventOptions2);
        };
      }
    } else {
      const doc = getWindow(event.currentTarget).document;
      doc.addEventListener("mousemove", handleNativePointerMove, eventOptions2);
      doc.addEventListener("mouseup", handleNativePointerUp, eventOptions2);
      doc.addEventListener("mouseleave", handleNativePointerUp, eventOptions2);
      disposeTargetNativeGestureEvents.current = () => {
        doc.removeEventListener("mousemove", handleNativePointerMove, eventOptions2);
        doc.removeEventListener("mouseup", handleNativePointerUp, eventOptions2);
        doc.removeEventListener("mouseleave", handleNativePointerUp, eventOptions2);
      };
    }
  };
  const handlePointerEnter = onEnter ? (event) => onEnter(event.nativeEvent) : void 0;
  const handlePointerLeave = onLeave ? (event) => onLeave(event.nativeEvent) : void 0;
  const handleDragStart = (event) => {
    const target = event.target;
    if (target.tagName === "A" || target.tagName === "IMG") {
      event.preventDefault();
    }
  };
  const handleClickCapture = (event) => {
    if (!didSlide.current) {
      return onClickCapture && onClickCapture(event);
    }
    if (noSlideClick) {
      event.stopPropagation();
      event.preventDefault();
    } else {
      onClickCapture && onClickCapture(event);
    }
    didSlide.current = false;
  };
  return (0, import_jsx_runtime34.jsx)(Component3, _object_spread_props(_object_spread({}, restProps), {
    ref: getRootRef,
    onDragStart: handleDragStart,
    onClickCapture: handleClickCapture,
    // onEnter
    onPointerEnter: usePointerHover ? handlePointerEnter : void 0,
    onMouseEnter: !usePointerHover ? handlePointerEnter : void 0,
    // onLeave
    onPointerLeave: usePointerHover ? handlePointerLeave : void 0,
    onMouseLeave: !usePointerHover ? handlePointerLeave : void 0,
    // handlePointerDown
    onTouchStartCapture: isTouchEnabled && useCapture ? handlePointerDown : void 0,
    onTouchStart: isTouchEnabled && !useCapture ? handlePointerDown : void 0,
    onMouseDownCapture: !isTouchEnabled && useCapture ? handlePointerDown : void 0,
    onMouseDown: !isTouchEnabled && !useCapture ? handlePointerDown : void 0
  }));
};
function initGesture(startX, startY) {
  return {
    startX,
    startY,
    startT: /* @__PURE__ */ new Date(),
    duration: 0,
    isPressed: true,
    isY: false,
    isX: false,
    isSlideX: false,
    isSlideY: false,
    isSlide: false,
    clientX: 0,
    clientY: 0,
    shiftX: 0,
    shiftY: 0,
    shiftXAbs: 0,
    shiftYAbs: 0
  };
}
function dispatchUserHandlers(event, gesture, [handler, handlerX, handlerY], stopPropagation3, shouldCallDirectionHandlerOnlyIsSlide = true) {
  if (stopPropagation3) {
    event.stopPropagation();
  }
  const data = _object_spread_props(_object_spread({}, gesture), {
    originalEvent: event,
    duration: Date.now() - gesture.startT.getTime()
  });
  if (handler) {
    handler(data);
  }
  if (handlerX) {
    if (shouldCallDirectionHandlerOnlyIsSlide) {
      if (gesture.isSlideX) {
        handlerX(data);
      }
    } else {
      handlerX(data);
    }
  }
  if (handlerY) {
    if (shouldCallDirectionHandlerOnlyIsSlide) {
      if (gesture.isSlideY) {
        handlerY(data);
      }
    } else {
      handlerY(data);
    }
  }
}

// node_modules/@vkontakte/vkui/dist/components/View/useLayoutEffectCall.js
var React46 = __toESM(require_react());
var _fns = /* @__PURE__ */ new WeakMap();
var LayoutEffectCall = class {
  /**
  * Выполняет переданные функции
  */
  run() {
    for (const fn of _class_private_field_get(this, _fns)) {
      fn();
    }
    _class_private_field_set(this, _fns, []);
  }
  constructor() {
    _class_private_field_init(this, _fns, {
      writable: true,
      value: []
    });
    _define_property(this, "add", (fn) => {
      _class_private_field_get(this, _fns).push(fn);
    });
  }
};
function useLayoutEffectCall() {
  const ref = React46.useRef(null);
  if (!ref.current) {
    ref.current = new LayoutEffectCall();
  }
  useIsomorphicLayoutEffect(() => {
    ref.current.run();
  });
  return ref.current.add;
}

// node_modules/@vkontakte/vkui/dist/lib/floating/functions.js
function checkIsNotAutoPlacement(placement) {
  return !placement.startsWith("auto");
}
function getAutoPlacementAlign(placement) {
  const align = placement.replace(/auto-|auto/, "");
  return align === "start" || align === "end" ? align : null;
}
function convertFloatingDataToReactCSSProperties(strategy, x, y, initialWidth = "max-content", middlewareData) {
  const styles = {
    position: strategy,
    top: y,
    right: "auto",
    bottom: "auto",
    left: x
  };
  if (initialWidth !== null) {
    styles.width = initialWidth;
  }
  if (middlewareData) {
    const hide4 = middlewareData.hide;
    if (hide4 && hide4.referenceHidden) {
      styles["visibility"] = "hidden";
    }
  }
  return styles;
}
var getArrowCoordsByMiddlewareData = (middlewareData) => {
  const coords = {
    x: 0,
    y: 0
  };
  if (middlewareData.arrow) {
    const { x = 0, y = 0 } = middlewareData.arrow;
    coords.x = x;
    coords.y = y;
  }
  return coords;
};

// node_modules/@swc/helpers/esm/_array_with_holes.js
function _array_with_holes(arr) {
  if (Array.isArray(arr)) return arr;
}

// node_modules/@swc/helpers/esm/_iterable_to_array_limit.js
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}

// node_modules/@swc/helpers/esm/_non_iterable_rest.js
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@swc/helpers/esm/_sliced_to_array.js
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement2(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition2 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform3
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform3.isRTL == null ? void 0 : platform3.isRTL(floating));
  let rects = await platform3.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement2(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform3,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform3.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement2(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform3,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform3.getClippingRect({
    element: ((_await$platform$isEle = await (platform3.isElement == null ? void 0 : platform3.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform3.getDocumentElement == null ? void 0 : platform3.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform3.getOffsetParent == null ? void 0 : platform3.getOffsetParent(elements.floating));
  const offsetScale = await (platform3.isElement == null ? void 0 : platform3.isElement(offsetParent)) ? await (platform3.getScale == null ? void 0 : platform3.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform3.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform3.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform3,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform3.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform3.getOffsetParent == null ? void 0 : platform3.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform3.isElement == null ? void 0 : platform3.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max3 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset4 = clamp(min$1, center, max3);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max3 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset4,
        centerOffset: center - offset4 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
var autoPlacement = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "autoPlacement",
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform: platform3,
        elements
      } = state;
      const {
        crossAxis = false,
        alignment,
        allowedPlacements = placements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      const placements$1 = alignment !== void 0 || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements$1[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform3.isRTL == null ? void 0 : platform3.isRTL(elements.floating)));
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements$1[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
      const allOverflows = [...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements$1[currentIndex + 1];
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByMostSpace = allOverflows.map((d) => {
        const alignment2 = getAlignment(d.placement);
        return [d.placement, alignment2 && crossAxis ? (
          // Check along the mainAxis and main crossAxis side.
          d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0)
        ) : (
          // Check only the mainAxis.
          d.overflows[0]
        ), d.overflows];
      }).sort((a, b) => a[1] - b[1]);
      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d) => d[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        getAlignment(d[0]) ? 2 : 3
      ).every((v) => v <= 0));
      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform3,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform3.isRTL == null ? void 0 : platform3.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform3,
    elements
  } = state;
  const rtl = await (platform3.isRTL == null ? void 0 : platform3.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min3 = mainAxisCoord + overflow[minSide];
        const max3 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min3, mainAxisCoord, max3);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min3 = crossAxisCoord + overflow[minSide];
        const max3 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min3, crossAxisCoord, max3);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform3,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform3.isRTL == null ? void 0 : platform3.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform3.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName2(node) {
  if (isNode2(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow2(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement2(node) {
  var _ref;
  return (_ref = (isNode2(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow2(value).Node;
}
function isElement2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow2(value).Element;
}
function isHTMLElement2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow2(value).HTMLElement;
}
function isShadowRoot2(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow2(value).ShadowRoot;
}
function isOverflowElement2(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle3(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName2(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement2(elementOrCss) ? getComputedStyle3(elementOrCss) : elementOrCss;
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode2(element);
  while (isHTMLElement2(currentNode) && !isLastTraversableNode2(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode2(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode2(node) {
  return ["html", "body", "#document"].includes(getNodeName2(node));
}
function getComputedStyle3(element) {
  return getWindow2(element).getComputedStyle(element);
}
function getNodeScroll2(element) {
  if (isElement2(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode2(node) {
  if (getNodeName2(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot2(node) && node.host || // Fallback.
    getDocumentElement2(node)
  );
  return isShadowRoot2(result) ? result.host : result;
}
function getNearestOverflowAncestor3(node) {
  const parentNode = getParentNode2(node);
  if (isLastTraversableNode2(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement2(parentNode) && isOverflowElement2(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor3(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor3(node);
  const isBody2 = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow2(scrollableAncestor);
  if (isBody2) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement2(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle3(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement2(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement2(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement2(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow2(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow2(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect2(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement2(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow2(domElement);
    const offsetWin = offsetParent && isElement2(offsetParent) ? getWindow2(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle3(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow2(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll2(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect2(getDocumentElement2(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement2(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement2(documentElement)) {
      scroll = getNodeScroll2(offsetParent);
    }
    if (isHTMLElement2(offsetParent)) {
      const offsetRect = getBoundingClientRect2(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement2(element);
  const scroll = getNodeScroll2(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle3(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow2(element);
  const html = getDocumentElement2(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect2(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement2(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement2(element));
  } else if (isElement2(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode2(element);
  if (parentNode === stopNode || !isElement2(parentNode) || isLastTraversableNode2(parentNode)) {
    return false;
  }
  return getComputedStyle3(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement2(el) && getNodeName2(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle3(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode2(element) : element;
  while (isElement2(currentNode) && !isLastTraversableNode2(currentNode)) {
    const computedStyle = getComputedStyle3(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement2(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode2(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement2(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect2(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement2(documentElement)) {
      scroll = getNodeScroll2(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect2(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle3(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement2(element) || getComputedStyle3(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement2(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow2(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement2(element)) {
    let svgOffsetParent = getParentNode2(element);
    while (svgOffsetParent && !isLastTraversableNode2(svgOffsetParent)) {
      if (isElement2(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode2(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode2(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle3(element).direction === "rtl";
}
var platform2 = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement: getDocumentElement2,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: isElement2,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement2(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect2(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect2(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var autoPlacement2 = autoPlacement;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var computePosition3 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform: platform2,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition2(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@vkontakte/vkui-floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React47 = __toESM(require_react(), 1);
var import_react7 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var index = typeof document !== "undefined" ? import_react7.useLayoutEffect : import_react7.useEffect;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if ((typeof a === "undefined" ? "undefined" : _type_of(a)) !== (typeof b === "undefined" ? "undefined" : _type_of(b))) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  var length;
  var i;
  var keys;
  if (a && b && (typeof a === "undefined" ? "undefined" : _type_of(a)) === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      var key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  var win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  var dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  var ref = React47.useRef(value);
  index(function() {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  var _options_placement = options.placement, placement = _options_placement === void 0 ? "bottom" : _options_placement, _options_strategy = options.strategy, strategy = _options_strategy === void 0 ? "absolute" : _options_strategy, _options_middleware = options.middleware, middleware = _options_middleware === void 0 ? [] : _options_middleware, platform3 = options.platform, tmp = options.elements, _ref = tmp === void 0 ? {} : tmp, externalReference = _ref.reference, externalFloating = _ref.floating, _options_transform = options.transform, transform = _options_transform === void 0 ? true : _options_transform, whileElementsMounted2 = options.whileElementsMounted, open = options.open;
  var _React_useState = _sliced_to_array(React47.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  }), 2), data = _React_useState[0], setData = _React_useState[1];
  var _React_useState1 = _sliced_to_array(React47.useState(middleware), 2), latestMiddleware = _React_useState1[0], setLatestMiddleware = _React_useState1[1];
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  var _React_useState2 = _sliced_to_array(React47.useState(null), 2), _reference = _React_useState2[0], _setReference = _React_useState2[1];
  var _React_useState3 = _sliced_to_array(React47.useState(null), 2), _floating = _React_useState3[0], _setFloating = _React_useState3[1];
  var setReference = React47.useCallback(function(node) {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  var setFloating = React47.useCallback(function(node) {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  var referenceEl = externalReference || _reference;
  var floatingEl = externalFloating || _floating;
  var referenceRef = React47.useRef(null);
  var floatingRef = React47.useRef(null);
  var dataRef = React47.useRef(data);
  var hasWhileElementsMounted = whileElementsMounted2 != null;
  var whileElementsMountedRef = useLatestRef(whileElementsMounted2);
  var platformRef = useLatestRef(platform3);
  var openRef = useLatestRef(open);
  var update = React47.useCallback(function() {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    var config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition3(referenceRef.current, floatingRef.current, config).then(function(data2) {
      var fullData = _object_spread_props(_object_spread({}, data2), {
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      });
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(function() {
          setData(fullData);
        });
      }
    });
  }, [
    latestMiddleware,
    placement,
    strategy,
    platformRef,
    openRef
  ]);
  index(function() {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData(function(data2) {
        return _object_spread_props(_object_spread({}, data2), {
          isPositioned: false
        });
      });
    }
  }, [
    open
  ]);
  var isMountedRef = React47.useRef(false);
  index(function() {
    isMountedRef.current = true;
    return function() {
      isMountedRef.current = false;
    };
  }, []);
  index(function() {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [
    referenceEl,
    floatingEl,
    update,
    whileElementsMountedRef,
    hasWhileElementsMounted
  ]);
  var refs = React47.useMemo(function() {
    return {
      reference: referenceRef,
      floating: floatingRef,
      setReference,
      setFloating
    };
  }, [
    setReference,
    setFloating
  ]);
  var elements = React47.useMemo(function() {
    return {
      reference: referenceEl,
      floating: floatingEl
    };
  }, [
    referenceEl,
    floatingEl
  ]);
  var floatingStyles = React47.useMemo(function() {
    var initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    var x = roundByDPR(elements.floating, data.x);
    var y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return _object_spread(_object_spread_props(_object_spread({}, initialStyles), {
        transform: "translate(" + x + "px, " + y + "px)"
      }), getDPR(elements.floating) >= 1.5 && {
        willChange: "transform"
      });
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [
    strategy,
    transform,
    elements.floating,
    data.x,
    data.y
  ]);
  return React47.useMemo(function() {
    return _object_spread_props(_object_spread({}, data), {
      update,
      refs,
      elements,
      floatingStyles
    });
  }, [
    data,
    update,
    refs,
    elements,
    floatingStyles
  ]);
}
var arrow$1 = function(options) {
  var isRef = function isRef2(value) {
    return {}.hasOwnProperty.call(value, "current");
  };
  return {
    name: "arrow",
    options,
    fn: function fn(state) {
      var _ref = typeof options === "function" ? options(state) : options, element = _ref.element, padding = _ref.padding;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = function(options, deps) {
  return _object_spread_props(_object_spread({}, offset2(options)), {
    options: [
      options,
      deps
    ]
  });
};
var shift3 = function(options, deps) {
  return _object_spread_props(_object_spread({}, shift2(options)), {
    options: [
      options,
      deps
    ]
  });
};
var flip3 = function(options, deps) {
  return _object_spread_props(_object_spread({}, flip2(options)), {
    options: [
      options,
      deps
    ]
  });
};
var size3 = function(options, deps) {
  return _object_spread_props(_object_spread({}, size2(options)), {
    options: [
      options,
      deps
    ]
  });
};
var autoPlacement3 = function(options, deps) {
  return _object_spread_props(_object_spread({}, autoPlacement2(options)), {
    options: [
      options,
      deps
    ]
  });
};
var hide3 = function(options, deps) {
  return _object_spread_props(_object_spread({}, hide2(options)), {
    options: [
      options,
      deps
    ]
  });
};
var arrow3 = function(options, deps) {
  return _object_spread_props(_object_spread({}, arrow$1(options)), {
    options: [
      options,
      deps
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/lib/floating/adapters.js
var defaultOptions = {
  ancestorScroll: true,
  ancestorResize: true,
  // По умолчанию отключаем, т.к. навешивать `CustomResizeObserver` может быть дорого.
  // В `autoUpdateLib` по умолчанию опция включена. Там используется ResizeObserver, но и он не менее дорогостоящий.
  // https://github.com/floating-ui/floating-ui/blob/0a34fe9cc2c7483976785a71bd0777cd7c3f2a6a/packages/dom/src/autoUpdate.ts#L6-L33
  elementResize: false,
  animationFrame: false
};
function autoUpdateFloatingElement(reference, floating, update, options = defaultOptions) {
  const { elementResize = false } = options, restOptions = _object_without_properties(options, [
    "elementResize"
  ]);
  const canUseResizeObserver = window.ResizeObserver !== void 0;
  const autoUpdateLibDisposer = autoUpdate(reference, floating, update, _object_spread_props(_object_spread({}, restOptions), {
    elementResize: elementResize && canUseResizeObserver
  }));
  let observer = null;
  if (elementResize && !canUseResizeObserver) {
    observer = new CustomResizeObserver(update);
    if (isHTMLElement(reference)) {
      observer.observe(reference);
    }
    observer.observe(floating);
    observer.appendToTheDOM();
  }
  return () => {
    if (observer) {
      observer.disconnect();
      observer = null;
    }
    autoUpdateLibDisposer();
  };
}

// node_modules/@vkontakte/vkui/dist/lib/floating/useFloatingMiddlewaresBootstrap/index.js
var React48 = __toESM(require_react());
var useFloatingMiddlewaresBootstrap = ({ placement = "bottom-start", arrowRef = null, arrow: arrow4, arrowHeight, arrowPadding, sameWidth, offsetByMainAxis = 0, offsetByCrossAxis = 0, customMiddlewares, hideWhenReferenceHidden, disableFlipMiddleware = false }) => {
  return React48.useMemo(() => {
    const isAutoPlacement = !checkIsNotAutoPlacement(placement);
    const middlewares = [
      offset3({
        crossAxis: offsetByCrossAxis,
        mainAxis: arrow4 && arrowHeight ? offsetByMainAxis + arrowHeight : offsetByMainAxis
      })
    ];
    if (isAutoPlacement) {
      middlewares.push(autoPlacement3({
        alignment: getAutoPlacementAlign(placement)
      }));
    } else if (!disableFlipMiddleware) {
      middlewares.push(flip3({
        fallbackAxisSideDirection: "start"
      }));
    }
    middlewares.push(shift3());
    if (sameWidth) {
      middlewares.push(size3({
        apply({ rects, elements }) {
          Object.assign(elements.floating.style, {
            width: `${rects.reference.width}px`
          });
        }
      }));
    }
    if (customMiddlewares) {
      middlewares.push(...customMiddlewares);
    }
    if (arrow4) {
      middlewares.push(arrow3({
        element: arrowRef,
        padding: arrowPadding
      }));
    }
    if (hideWhenReferenceHidden) {
      middlewares.push(hide3());
    }
    return {
      middlewares,
      strictPlacement: isAutoPlacement ? void 0 : placement
    };
  }, [
    offsetByCrossAxis,
    arrowRef,
    arrow4,
    arrowHeight,
    arrowPadding,
    offsetByMainAxis,
    sameWidth,
    customMiddlewares,
    placement,
    hideWhenReferenceHidden,
    disableFlipMiddleware
  ]);
};

// node_modules/@vkontakte/vkui/dist/lib/floating/useFloatingWithInteractions/useFloatingWithInteractions.js
var React50 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useEnsuredControl.js
var React49 = __toESM(require_react());
function useEnsuredControl(_param) {
  var { onChange: onChangeProp, disabled } = _param, props = _object_without_properties(_param, [
    "onChange",
    "disabled"
  ]);
  const [value, onChangeValue] = useCustomEnsuredControl(props);
  const onChange = React49.useCallback((e) => {
    if (disabled) {
      return;
    }
    onChangeValue(e.target.value);
    onChangeProp && onChangeProp(e);
  }, [
    onChangeValue,
    onChangeProp,
    disabled
  ]);
  return [
    value,
    onChange
  ];
}
var warn3 = warnOnce("useCustomEnsuredControl");
function useCustomEnsuredControl({ value, defaultValue, disabled, onChange: onChangeProp }) {
  const isControlled = value !== void 0;
  const [localValue, setLocalValue] = React49.useState(defaultValue);
  const preservedControlledValueRef = React49.useRef();
  useIsomorphicLayoutEffect(() => {
    preservedControlledValueRef.current = value;
  });
  const currentFallbackValueRef = React49.useRef(value);
  currentFallbackValueRef.current = value;
  const onChange = React49.useCallback((nextValue) => {
    if (disabled) {
      return;
    }
    if (isFunction(nextValue)) {
      if (!isControlled) {
        setLocalValue((prevValue) => {
          const resolvedValue = nextValue(prevValue);
          if (onChangeProp) {
            onChangeProp(resolvedValue);
          }
          return resolvedValue;
        });
      } else if (onChangeProp) {
        if (true) {
          if (preservedControlledValueRef.current === void 0) {
            warn3(`Похоже, что при вызове onChange с аргументом nextValue в виде коллбэка, состояние компонента было переведено из неконтролируемого ("undefined") в контролируемое. Пожалуйста, старайтесь сохранять либо неконтролируемое состояние, либо контролируемое на всём промежутке жизненного цикла компонента, чтобы получать предсказуемое значение prevValue в коллбэке nextValue((prevValue: V) => V)`, "error");
          }
        }
        const prevValue = preservedControlledValueRef.current === void 0 ? currentFallbackValueRef.current : preservedControlledValueRef.current;
        if (prevValue !== void 0) {
          const resolvedValue = nextValue(prevValue);
          onChangeProp(resolvedValue);
        }
      }
    } else {
      if (onChangeProp) {
        onChangeProp(nextValue);
      }
      if (!isControlled) {
        setLocalValue(nextValue);
      }
    }
  }, [
    disabled,
    isControlled,
    onChangeProp
  ]);
  return [
    isControlled ? value : localValue,
    onChange
  ];
}

// node_modules/@vkontakte/vkui/dist/hooks/useGlobalOnClickOutside.js
var useGlobalOnClickOutside = (callback, ...refs) => {
  const { document: document2 } = useDOM();
  useIsomorphicLayoutEffect(() => {
    const someRefNotNull = refs.some((ref) => ref && ref.current !== null);
    if (!document2 || !someRefNotNull) {
      return;
    }
    const handleClick = (event) => {
      const targetEl = event.target;
      const someRefHasTargetEl = isElement(targetEl) && refs.some((ref) => ref && ref.current && ref.current.contains(targetEl));
      if (!someRefHasTargetEl) {
        callback(event);
      }
    };
    document2.addEventListener("click", handleClick, {
      passive: true,
      capture: true
    });
    return () => {
      document2.removeEventListener("click", handleClick, true);
    };
  }, [
    document2,
    callback,
    ...refs
  ]);
};

// node_modules/@vkontakte/vkui/dist/lib/floating/useFloatingWithInteractions/constants.js
var DEFAULT_TRIGGER = "click";

// node_modules/@vkontakte/vkui/dist/lib/floating/useFloatingWithInteractions/useResolveTriggerType.js
var useResolveTriggerType = (triggerProp) => (typeof triggerProp === "string" ? [
  triggerProp
] : triggerProp).reduce((result, trigger) => {
  switch (trigger) {
    case "click":
      result.triggerOnClick = true;
      return result;
    case "hover":
      result.triggerOnHover = true;
      return result;
    case "focus":
      result.triggerOnFocus = true;
      return result;
    case "manual":
      return result;
  }
}, {
  triggerOnFocus: false,
  triggerOnClick: false,
  triggerOnHover: false
});

// node_modules/@vkontakte/vkui/dist/lib/floating/useFloatingWithInteractions/useFloatingWithInteractions.js
var whileElementsMounted = (...args) => (
  /* istanbul ignore next: не знаю как проверить */
  autoUpdateFloatingElement(...args, {
    elementResize: true
  })
);
var useFloatingWithInteractions = ({
  trigger = DEFAULT_TRIGGER,
  // UseFloating
  placement: placementProp = "bottom",
  middlewares,
  hoverDelay = 0,
  closeAfterClick = false,
  // disables
  disabled = false,
  disableInteractive = false,
  disableCloseOnClickOutside = false,
  disableCloseOnEscKey = false,
  // uncontrolled
  defaultShown = false,
  // controlled
  shown: shownProp,
  onShownChange: onShownChangeProp,
  onShownChanged: onShownChangedProp
}) => {
  const memoizedValue = React50.useMemo(() => shownProp !== void 0 ? {
    shown: shownProp
  } : void 0, [
    shownProp
  ]);
  const [shownLocalState, setShownLocalState] = useCustomEnsuredControl({
    value: memoizedValue,
    disabled,
    defaultValue: {
      shown: defaultShown
    },
    onChange: useStableCallback(({ shown, reason }) => {
      if (onShownChangeProp) {
        onShownChangeProp(shown, reason);
      }
    })
  });
  const onShownChanged = useStableCallback(onShownChangedProp ? onShownChangedProp : noop);
  const [shownFinalState, setShownFinalState] = React50.useState(() => shownLocalState.shown);
  const [willBeHide, setWillBeHide] = React50.useState(false);
  const hasCSSAnimation = React50.useRef(false);
  const blockMouseEnterRef = React50.useRef(false);
  const blockFocusRef = React50.useRef(false);
  const blurTimeoutRef = React50.useRef();
  const handleCloseOnReferenceClickOutsideDisabled = disabled || disableCloseOnClickOutside || willBeHide || !shownLocalState.shown;
  const handleCloseOnFloatingClickOutsideDisabled = disableInteractive || handleCloseOnReferenceClickOutsideDisabled;
  const { triggerOnFocus, triggerOnClick, triggerOnHover } = useResolveTriggerType(trigger);
  const { placement, x, y, strategy, refs, middlewareData } = useFloating({
    strategy: "fixed",
    placement: placementProp,
    middleware: middlewares,
    whileElementsMounted
  });
  const commitShownLocalState = React50.useCallback((nextShown, reason) => {
    setShownLocalState((prevState) => {
      if (prevState.shown !== nextShown || prevState.reason !== reason) {
        return {
          shown: nextShown,
          reason
        };
      }
      return prevState;
    });
  }, [
    setShownLocalState
  ]);
  const [mouseEnterDelay, mouseLeaveDelay] = typeof hoverDelay === "number" ? [
    hoverDelay,
    hoverDelay
  ] : hoverDelay;
  const showWithDelay = React50.useMemo(() => debounce(() => commitShownLocalState(true, "hover"), mouseEnterDelay), [
    mouseEnterDelay,
    commitShownLocalState
  ]);
  const hideWithDelay = React50.useMemo(() => debounce(() => commitShownLocalState(false, "hover"), mouseLeaveDelay), [
    mouseLeaveDelay,
    commitShownLocalState
  ]);
  const handleFocusOnReference = useStableCallback(() => {
    if (shownLocalState.shown) {
      if (!closeAfterClick && shownLocalState.reason === "hover") {
        return;
      }
      commitShownLocalState(false, "focus");
      return;
    }
    if (blockFocusRef.current) {
      blockFocusRef.current = false;
      return;
    }
    commitShownLocalState(true, "focus");
  });
  const handleBlurOnReference = useStableCallback((event) => {
    blockFocusRef.current = false;
    blockMouseEnterRef.current = false;
    if (!shownLocalState.shown) {
      clearTimeout(blurTimeoutRef.current);
      return;
    }
    const relatedTarget = event.relatedTarget;
    blurTimeoutRef.current = setTimeout(function waitWindowBlurFire() {
      const reference = refs.reference.current;
      if (!relatedTarget && getActiveElementByAnotherElement(reference) === reference) {
        return;
      }
      if (contains(refs.floating.current, relatedTarget) || contains(reference, relatedTarget)) {
        return;
      }
      commitShownLocalState(false, "focus");
    });
  });
  const handleClickOnReference = useStableCallback(() => {
    if (shownLocalState.reason === "focus") {
      commitShownLocalState(shownLocalState.shown, "click");
      return;
    }
    commitShownLocalState(!shownLocalState.shown, "click");
  });
  const handleClickOnReferenceForOnlyClose = useStableCallback(() => {
    blockMouseEnterRef.current = true;
    commitShownLocalState(false, "click");
  });
  const handleMouseEnterOnBoth = useStableCallback((event) => {
    if (willBeHide && event.currentTarget === refs.floating.current) {
      return;
    }
    showWithDelay.cancel();
    hideWithDelay.cancel();
    if (!blockMouseEnterRef.current && !shownLocalState.shown) {
      showWithDelay();
    }
  });
  const handleMouseLeaveOnBothForHoverAndFocusStates = useStableCallback((event) => {
    if (willBeHide && event.currentTarget === refs.floating.current) {
      return;
    }
    blockFocusRef.current = false;
    blockMouseEnterRef.current = false;
    if (triggerOnHover) {
      showWithDelay.cancel();
      hideWithDelay.cancel();
      hideWithDelay();
    }
  });
  const handleFloatingAnimationStart = () => {
    hasCSSAnimation.current = true;
  };
  const handleFloatingAnimationEnd = () => {
    if (willBeHide) {
      setShownFinalState(false);
      setWillBeHide(false);
      onShownChanged(false, shownLocalState.reason);
    }
  };
  const handleOnClose = React50.useCallback(() => {
    blockFocusRef.current = true;
    commitShownLocalState(false, "callback");
  }, [
    commitShownLocalState
  ]);
  const handleRestoreFocus = React50.useCallback((restoreFocus = true) => {
    if (!restoreFocus) {
      return false;
    }
    if (restoreFocus === true) {
      return triggerOnFocus ? blockFocusRef.current : true;
    } else if (restoreFocus === "anchor-element") {
      return refs.reference.current;
    } else if (restoreFocus instanceof HTMLElement) {
      return restoreFocus;
    }
    return false;
  }, [
    refs.reference,
    triggerOnFocus
  ]);
  const handleEscapeKeyDown = React50.useCallback(() => {
    blockFocusRef.current = true;
    commitShownLocalState(false, "escape-key");
  }, [
    commitShownLocalState
  ]);
  const handleClickOutside = React50.useCallback(() => {
    blockFocusRef.current = true;
    commitShownLocalState(false, "click-outside");
  }, [
    commitShownLocalState
  ]);
  useGlobalOnClickOutside(handleClickOutside, handleCloseOnReferenceClickOutsideDisabled ? null : refs.reference, handleCloseOnFloatingClickOutsideDisabled ? null : refs.floating);
  useIsomorphicLayoutEffect(
    /**
    * Если пользователь покинул активное окно и:
    * 1. целевой элемент был в состоянии фокуса;
    * 2. всплывающий элемент был закрытом состоянии;
    * то фокус должен быть заблокирован, когда пользователь вернётся обратно. Иначе покажется
    * всплывающий элемент.
    */
    function setGlobalBlurForTriggerOnFocus() {
      if (!triggerOnFocus || !refs.reference.current) {
        return;
      }
      const handleGlobalBlur = () => {
        const reference = refs.reference.current;
        if (!shownLocalState.shown && isHTMLElement(reference) && reference === getActiveElementByAnotherElement(reference)) {
          blockFocusRef.current = true;
        }
      };
      const win = getWindow(refs.reference.current);
      win.addEventListener("blur", handleGlobalBlur);
      return () => {
        win.removeEventListener("blur", handleGlobalBlur);
      };
    },
    [
      triggerOnFocus,
      refs.reference,
      shownLocalState
    ]
  );
  useIsomorphicLayoutEffect(function resolveShownStates() {
    if (willBeHide || shownLocalState.shown === shownFinalState) {
      return;
    }
    if (shownLocalState.shown) {
      setShownFinalState(true);
      onShownChanged(true, shownLocalState.reason);
    } else if (hasCSSAnimation.current && !willBeHide) {
      setWillBeHide(true);
    } else {
      setShownFinalState(false);
    }
    return () => {
      clearTimeout(blurTimeoutRef.current);
    };
  }, [
    shownLocalState,
    shownFinalState,
    willBeHide,
    onShownChanged
  ]);
  const referencePropsRef = React50.useRef({});
  const floatingPropsRef = React50.useRef({
    style: {}
  });
  if (shownFinalState) {
    floatingPropsRef.current.style = convertFloatingDataToReactCSSProperties(strategy, x, y, void 0, middlewareData);
    if (disableInteractive) {
      floatingPropsRef.current.style.pointerEvents = "none";
    }
  }
  if (triggerOnFocus) {
    referencePropsRef.current.onFocus = handleFocusOnReference;
    referencePropsRef.current.onBlur = handleBlurOnReference;
  }
  if (triggerOnClick) {
    referencePropsRef.current.onClick = handleClickOnReference;
  }
  if (triggerOnHover) {
    referencePropsRef.current.onMouseOver = handleMouseEnterOnBoth;
    if (closeAfterClick && !triggerOnClick) {
      referencePropsRef.current.onClick = handleClickOnReferenceForOnlyClose;
    }
    if (!disableInteractive) {
      floatingPropsRef.current.onMouseOver = handleMouseEnterOnBoth;
    }
  }
  if (triggerOnHover || triggerOnFocus) {
    referencePropsRef.current.onMouseLeave = handleMouseLeaveOnBothForHoverAndFocusStates;
    if (!disableInteractive) {
      floatingPropsRef.current.onMouseLeave = handleMouseLeaveOnBothForHoverAndFocusStates;
    }
  }
  if (shownFinalState) {
    floatingPropsRef.current.onAnimationStart = handleFloatingAnimationStart;
    floatingPropsRef.current.onAnimationEnd = handleFloatingAnimationEnd;
  }
  return {
    placement,
    shown: shownFinalState,
    willBeHide,
    refs,
    referenceProps: referencePropsRef.current,
    floatingProps: floatingPropsRef.current,
    middlewareData,
    onClose: handleOnClose,
    // FocusTrap уже определяет нажатие на ESC, поэтому название события содержит конкретный код
    // кнопки вместо просто onKeyDown.
    onEscapeKeyDown: !shownFinalState || disableCloseOnEscKey ? void 0 : handleEscapeKeyDown,
    // [Обход баги с FocusTrap]
    //
    // Если сфокусироваться на целевой элемент через нажатие, а потом нажать в область за пределами
    // целевого и всплывающего элемента, то появляется моргание из-за того, что FocusTrap
    // восстанавливает фокус, из-за чего всплывающий элемент снова показывается за счёт
    // `handleFocusOnReference`, а потом скрывается за счёт `handleBlurOnReference`.
    onRestoreFocus: handleRestoreFocus
  };
};

// node_modules/@vkontakte/vkui/dist/lib/floating/usePlacementChangeCallback.js
function usePlacementChangeCallback(initialPlacement, resolvedPlacement, onPlacementChange) {
  const prevPlacement = usePrevious(resolvedPlacement);
  useIsomorphicLayoutEffect(() => {
    if (!onPlacementChange) {
      return;
    }
    const isInitialPlacementChanged = prevPlacement === void 0 && initialPlacement !== resolvedPlacement;
    const isResolvedPlacementChanged = prevPlacement !== void 0 && prevPlacement !== resolvedPlacement;
    if (isInitialPlacementChanged || isResolvedPlacementChanged) {
      onPlacementChange(resolvedPlacement);
    }
  }, [
    prevPlacement,
    initialPlacement,
    resolvedPlacement,
    onPlacementChange
  ]);
}

// node_modules/@vkontakte/vkui/dist/components/View/utils.js
var swipeBackExcludedSelector = "input, textarea, [data-vkui-swipe-back=false]";
function swipeBackExcluded(e) {
  var _target_closest;
  const target = e.originalEvent.target;
  return Boolean(target === null || target === void 0 ? void 0 : (_target_closest = target.closest) === null || _target_closest === void 0 ? void 0 : _target_closest.call(target, swipeBackExcludedSelector));
}
function hasHorizontalScrollableElementWithScrolledToLeft(node) {
  return getOverflowAncestors(node).some((node2) => "scrollLeft" in node2 ? node2.scrollLeft > 0 : false);
}
var SWIPE_BACK_EDGE_SIZE_THRESHOLD = 20;
var SWIPE_BACK_SHIFT_THRESHOLD = 10;
var getSwipeBackPredicates = (startX, shiftX, innerWidth) => {
  const swipedToOpposite = shiftX < 0;
  const swipeBackTriggered = shiftX >= SWIPE_BACK_SHIFT_THRESHOLD;
  const viewportStartEdgeTouched = startX <= SWIPE_BACK_EDGE_SIZE_THRESHOLD;
  const viewportEndEdgeTouched = startX >= innerWidth - SWIPE_BACK_EDGE_SIZE_THRESHOLD;
  return {
    swipedToOpposite,
    swipeBackTriggered,
    viewportStartEdgeTouched,
    viewportEndEdgeTouched
  };
};

// node_modules/@vkontakte/vkui/dist/components/View/View.js
var scrollsCache = {};
var warn4 = warnOnce("View");
var View = (_param) => {
  var { activePanel: activePanelProp, history, nav, onTransition, onSwipeBack, onSwipeBackStart, onSwipeBackCancel: onSwipeBackCancelProp, children, className } = _param, restProps = _object_without_properties(_param, [
    "activePanel",
    "history",
    "nav",
    "onTransition",
    "onSwipeBack",
    "onSwipeBackStart",
    "onSwipeBackCancel",
    "children",
    "className"
  ]);
  const id = getNavId({
    nav,
    id: restProps.id
  });
  const scrolls = React51.useRef(scrollsCache[id] || {});
  const layoutEffectCall = useLayoutEffectCall();
  React51.useEffect(() => () => {
    if (id) {
      scrollsCache[id] = scrolls.current;
    }
  });
  const panelNodes = React51.useRef({});
  const { window: window2, document: document2 } = useDOM();
  const scroll = useScroll();
  const configProvider = useConfigProvider();
  const splitCol = useSplitCol();
  const platform3 = usePlatform();
  const [animated, setAnimated] = React51.useState(false);
  const [visiblePanels, setVisiblePanels] = React51.useState([
    activePanelProp
  ]);
  const [activePanel, setActivePanel] = React51.useState(activePanelProp);
  const [isBack, setIsBack] = React51.useState(void 0);
  const [prevPanel, setPrevPanel] = React51.useState(null);
  const [nextPanel, setNextPanel] = React51.useState(null);
  const swipeBackPrevented = React51.useRef(false);
  const [swipingBack, setSwipingBack] = React51.useState(void 0);
  const [swipeBackStartX, setSwipeBackStartX] = React51.useState(0);
  const [swipeBackShift, setSwipeBackShift] = React51.useState(0);
  const [swipeBackNextPanel, setSwipeBackNextPanel] = React51.useState(null);
  const [swipeBackPrevPanel, setSwipeBackPrevPanel] = React51.useState(null);
  const [swipeBackResult, setSwipeBackResult] = React51.useState(null);
  const [browserSwipe, setBrowserSwipe] = React51.useState(false);
  const prevActivePanel = usePrevious(activePanelProp);
  const prevSwipingBack = usePrevious(swipingBack);
  const prevBrowserSwipe = usePrevious(browserSwipe);
  const prevSwipeBackResult = usePrevious(swipeBackResult);
  const prevSwipeBackShift = usePrevious(swipeBackShift);
  const prevSwipeBackPrevPanel = usePrevious(swipeBackPrevPanel);
  const prevOnTransition = usePrevious(onTransition);
  const panels = React51.Children.toArray(children).filter((panel) => {
    const panelId = getNavId(panel.props, warn4);
    return panelId !== void 0 && visiblePanels.includes(panelId) || panelId === swipeBackPrevPanel || panelId === swipeBackNextPanel;
  });
  const disableAnimation = !configProvider.transitionMotionEnabled || !splitCol.animate || platform3 === "vkcom";
  const iOSSwipeBackSimulationEnabled = !disableAnimation && platform3 === "ios" && configProvider.isWebView && Boolean(onSwipeBack);
  const flushTransition = React51.useCallback((prevPanel2, isBackTransition) => {
    if (isBackTransition) {
      scrolls.current[prevPanel2] = 0;
    }
    setPrevPanel(null);
    setNextPanel(null);
    setVisiblePanels([
      activePanelProp
    ]);
    setActivePanel(activePanelProp);
    setAnimated(false);
    setIsBack(isBackTransition);
    layoutEffectCall(() => {
      scroll === null || scroll === void 0 ? void 0 : scroll.scrollTo(0, isBackTransition ? scrolls.current[activePanelProp] : 0);
      onTransition && onTransition({
        isBack: isBackTransition,
        from: prevPanel2,
        to: activePanelProp
      });
    });
  }, [
    activePanelProp,
    layoutEffectCall,
    onTransition,
    scroll
  ]);
  const handleAnimatedTargetAnimationEnd = () => {
    if (prevPanel !== null) {
      flushTransition(prevPanel, Boolean(isBack));
    }
  };
  const onSwipeBackSuccess = React51.useCallback(() => {
    onSwipeBack && onSwipeBack();
  }, [
    onSwipeBack
  ]);
  const onSwipeBackCancel = React51.useCallback(() => {
    onSwipeBackCancelProp && onSwipeBackCancelProp();
    setSwipeBackPrevPanel(null);
    setSwipeBackNextPanel(null);
    setSwipingBack(false);
    setSwipeBackResult(null);
    setSwipeBackStartX(0);
    setSwipeBackShift(0);
  }, [
    onSwipeBackCancelProp
  ]);
  const swipingBackTransitionEndHandler = React51.useCallback(() => {
    switch (swipeBackResult) {
      case "fail":
        onSwipeBackCancel();
        break;
      case "success":
        onSwipeBackSuccess();
    }
  }, [
    onSwipeBackCancel,
    onSwipeBackSuccess,
    swipeBackResult
  ]);
  const handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext = (event) => {
    if (browserSwipe) {
      return;
    }
    const { swipeBackTriggered, viewportStartEdgeTouched, viewportEndEdgeTouched } = getSwipeBackPredicates(event.startX, event.shiftX, window2.innerWidth);
    if ((viewportStartEdgeTouched || viewportEndEdgeTouched) && swipeBackTriggered) {
      setBrowserSwipe(true);
    }
  };
  const handleTouchMoveXForIOSSwipeBackSimulation = (event) => {
    if (swipeBackPrevented.current || swipeBackExcluded(event)) {
      return;
    }
    const { swipedToOpposite, swipeBackTriggered, viewportStartEdgeTouched } = getSwipeBackPredicates(event.startX, event.shiftX, window2.innerWidth);
    if (animated && swipeBackTriggered) {
      return;
    }
    if (!swipingBack && history && history.length > 1) {
      if (swipedToOpposite) {
        swipeBackPrevented.current = true;
        return;
      }
      if (!swipeBackTriggered) {
        return;
      }
      if (!viewportStartEdgeTouched && hasHorizontalScrollableElementWithScrolledToLeft(event.originalEvent.target)) {
        swipeBackPrevented.current = true;
        return;
      }
      if (onSwipeBackStart) {
        const payload = onSwipeBackStart(activePanel);
        if (payload === "prevent") {
          swipeBackPrevented.current = true;
          return;
        }
      }
      if (activePanel !== null) {
        blurActiveElement(document2);
        scrolls.current[activePanel] = scroll === null || scroll === void 0 ? void 0 : scroll.getScroll().y;
      }
      setSwipingBack(true);
      setSwipeBackStartX(event.startX);
      setSwipeBackPrevPanel(activePanel);
      setSwipeBackNextPanel(history.slice(-2)[0]);
    }
    if (swipingBack) {
      if (event.shiftX < 0) {
        setSwipeBackShift(0);
      } else if (event.shiftX > window2.innerWidth - swipeBackStartX) {
        setSwipeBackShift(window2.innerWidth);
      } else {
        setSwipeBackShift(event.shiftX);
      }
    }
  };
  const handleTouchEndForIOSSwipeBackSimulation = (event) => {
    swipeBackPrevented.current = false;
    if (swipingBack) {
      const speed = swipeBackShift / event.duration * 1e3;
      var _window_innerWidth;
      if (swipeBackShift === 0) {
        onSwipeBackCancel();
      } else if (swipeBackShift >= ((_window_innerWidth = window2.innerWidth) !== null && _window_innerWidth !== void 0 ? _window_innerWidth : 0)) {
        onSwipeBackSuccess();
      } else if (speed > 250 || swipeBackShift >= window2.innerWidth / 2) {
        setSwipeBackResult("success");
      } else {
        setSwipeBackResult("fail");
      }
    }
  };
  const calcPanelSwipeStyles = (isPrev, isNext) => {
    if (!isPrev && !isNext || swipeBackResult) {
      return {};
    }
    if (isNext) {
      return window2 ? {
        transform: `translate3d(${-50 + swipeBackShift * 100 / window2.innerWidth / 2}%, 0, 0)`
      } : {};
    }
    if (isPrev) {
      return {
        transform: `translate3d(${swipeBackShift}px, 0, 0)`
      };
    }
    return {};
  };
  const calcPanelSwipeBackOverlayStyles = (isNext) => {
    if (!window2 || !isNext) {
      return {};
    }
    const opacityOnSwipeEnd = swipeBackResult === "success" ? 0 : swipeBackResult === "fail" ? 1 : null;
    return {
      display: "block",
      opacity: opacityOnSwipeEnd === null ? 1 - swipeBackShift / window2.innerWidth : opacityOnSwipeEnd
    };
  };
  const handleSwipeBackTargetTransitionEnd = (event) => {
    if (event.propertyName.includes("transform")) {
      swipingBackTransitionEndHandler();
    }
  };
  React51.useEffect(() => {
    if (prevActivePanel && prevActivePanel !== activePanelProp && !prevSwipingBack && !prevBrowserSwipe) {
      const firstLayerId = React51.Children.toArray(children).map((panel) => getNavId(panel.props, warn4)).find((id2) => id2 === prevActivePanel || id2 === activePanelProp);
      const isBackTransition = firstLayerId === activePanelProp;
      scrolls.current[prevActivePanel] = scroll === null || scroll === void 0 ? void 0 : scroll.getScroll({
        compensateKeyboardHeight: false
      }).y;
      if (disableAnimation) {
        flushTransition(prevActivePanel, isBackTransition);
      } else {
        blurActiveElement(document2);
        setVisiblePanels([
          prevActivePanel,
          activePanelProp
        ]);
        setPrevPanel(prevActivePanel);
        setNextPanel(activePanelProp);
        setActivePanel(null);
        setAnimated(true);
        setIsBack(isBackTransition);
      }
    }
    if (prevActivePanel && prevActivePanel !== activePanelProp && prevSwipingBack) {
      const nextPanel2 = activePanelProp;
      const prevPanel2 = prevActivePanel;
      if (prevSwipeBackPrevPanel) {
        scrolls.current[prevSwipeBackPrevPanel] = 0;
      }
      setSwipeBackPrevPanel(null);
      setSwipeBackNextPanel(null);
      setSwipingBack(false);
      setSwipeBackResult(null);
      setSwipeBackStartX(0);
      setSwipeBackShift(0);
      setActivePanel(nextPanel2);
      setVisiblePanels([
        nextPanel2
      ]);
      setIsBack(true);
      layoutEffectCall(() => {
        if (nextPanel2 !== null) {
          scroll === null || scroll === void 0 ? void 0 : scroll.scrollTo(0, scrolls.current[nextPanel2]);
        }
        prevOnTransition && prevOnTransition({
          isBack: true,
          from: prevPanel2,
          to: nextPanel2
        });
      });
    }
    if (prevActivePanel !== activePanelProp && browserSwipe) {
      setBrowserSwipe(false);
      setNextPanel(null);
      setPrevPanel(null);
      setAnimated(false);
      setVisiblePanels([
        activePanelProp
      ]);
      setActivePanel(activePanelProp);
    }
  }, [
    activePanelProp,
    activePanel,
    browserSwipe,
    children,
    disableAnimation,
    document2,
    flushTransition,
    prevActivePanel,
    prevBrowserSwipe,
    prevOnTransition,
    prevSwipeBackPrevPanel,
    prevSwipeBackResult,
    prevSwipingBack,
    scroll,
    swipeBackNextPanel,
    swipeBackResult,
    layoutEffectCall
  ]);
  React51.useEffect(function restoreScrollPositionWhenSwipeBackIsCancelled() {
    const swipeBackCancelledInTheMiddleOfAction = prevSwipeBackResult === "fail" && !swipeBackResult;
    const swipeBackCancelledByMovingPanelBackToInitialPoint = prevSwipingBack && !swipingBack && prevSwipeBackShift === 0;
    if ((swipeBackCancelledInTheMiddleOfAction || swipeBackCancelledByMovingPanelBackToInitialPoint) && activePanel !== null) {
      scroll === null || scroll === void 0 ? void 0 : scroll.scrollTo(0, scrolls.current[activePanel]);
    }
  }, [
    prevSwipeBackResult,
    swipeBackResult,
    prevSwipingBack,
    swipingBack,
    prevSwipeBackShift,
    activePanel,
    scroll
  ]);
  return (0, import_jsx_runtime35.jsx)(NavViewIdContext.Provider, {
    value: id,
    children: (0, import_jsx_runtime35.jsx)(Touch, _object_spread_props(_object_spread({
      Component: "section"
    }, restProps), {
      className: clsx("vkuiView", platform3 === "ios" && clsx("vkuiView--ios", "vkuiInternalView--ios"), !disableAnimation && animated && "vkuiView--animated", !disableAnimation && swipingBack && "vkuiView--swiping-back", disableAnimation && "vkuiView--no-motion", className),
      onMoveX: iOSSwipeBackSimulationEnabled ? handleTouchMoveXForIOSSwipeBackSimulation : platform3 === "ios" ? handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext : void 0,
      onEnd: iOSSwipeBackSimulationEnabled ? handleTouchEndForIOSSwipeBackSimulation : void 0,
      children: (0, import_jsx_runtime35.jsx)("div", {
        className: "vkuiView__panels",
        children: panels.map((panel) => {
          const panelId = getNavId(panel.props, warn4);
          const isPanelActive = panelId === activePanel;
          const isPanelPrev = panelId === prevPanel;
          const isPanelNext = panelId === nextPanel;
          const isAnimatedTarget = animated && (isBack ? isPanelPrev : isPanelNext);
          const isSwipeBackPrev = panelId === swipeBackPrevPanel;
          const isSwipeBackNext = panelId === swipeBackNextPanel;
          const isSwipeBackTarget = swipeBackResult && isSwipeBackPrev;
          let scrollCompensateStyle = void 0;
          if (isPanelPrev || isPanelNext && isBack || isSwipeBackPrev || isSwipeBackNext) {
            const marginTop = scrolls.current[panelId];
            if (marginTop !== void 0) {
              scrollCompensateStyle = {
                marginTop: -1 * marginTop
              };
            }
          }
          return (0, import_jsx_runtime35.jsxs)("div", {
            className: clsx("vkuiView__panel", isPanelActive && "vkuiView__panel--active", isPanelPrev && "vkuiView__panel--prev", isPanelNext && "vkuiView__panel--next", isSwipeBackPrev && "vkuiView__panel--swipe-back-prev", isSwipeBackNext && "vkuiView__panel--swipe-back-next", swipeBackResult === "success" && "vkuiView__panel--swipe-back-success", swipeBackResult === "fail" && "vkuiView__panel--swipe-back-failed"),
            onTransitionEnd: isSwipeBackTarget ? handleSwipeBackTargetTransitionEnd : void 0,
            onAnimationEnd: isAnimatedTarget ? handleAnimatedTargetAnimationEnd : void 0,
            ref: (el) => panelId !== void 0 && (panelNodes.current[panelId] = el),
            style: calcPanelSwipeStyles(isSwipeBackPrev, isSwipeBackNext),
            children: [
              platform3 === "ios" && (0, import_jsx_runtime35.jsx)("div", {
                className: "vkuiView__panel-overlay",
                style: calcPanelSwipeBackOverlayStyles(isSwipeBackNext)
              }),
              (0, import_jsx_runtime35.jsx)("div", {
                className: "vkuiView__panel-in",
                style: scrollCompensateStyle,
                children: (0, import_jsx_runtime35.jsx)(NavTransitionDirectionProvider, {
                  isBack: swipingBack || isBack,
                  children: (0, import_jsx_runtime35.jsx)(NavTransitionProvider, {
                    entering: panelId === nextPanel || panelId === swipeBackNextPanel,
                    children: panel
                  })
                })
              })
            ]
          }, panelId);
        })
      })
    }))
  });
};

// node_modules/@vkontakte/vkui/dist/components/Panel/Panel.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime());
var React52 = __toESM(require_react());
var sizeXClassNames2 = {
  none: "vkuiPanel--sizeX-none",
  compact: "vkuiPanel--sizeX-compact",
  regular: "vkuiPanel--sizeX-regular"
};
var stylesMode3 = {
  none: "vkuiPanel--mode-none",
  plain: "vkuiPanel--mode-plain",
  card: "vkuiPanel--mode-card"
};
var Panel = (_param) => {
  var { centered = false, children, nav, mode: modeProp, disableBackground } = _param, restProps = _object_without_properties(_param, [
    "centered",
    "children",
    "nav",
    "mode",
    "disableBackground"
  ]);
  const { sizeX = "none" } = useAdaptivity();
  const mode = usePanelMode(modeProp, sizeX);
  return (0, import_jsx_runtime36.jsx)(NavPanelIdContext.Provider, {
    value: restProps.id || nav,
    children: (0, import_jsx_runtime36.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
      baseClassName: clsx("vkuiPanel", sizeXClassNames2[sizeX], centered && "vkuiInternalPanel--centered", disableBackground && "vkuiPanel--disableBackground", stylesMode3[mode]),
      children: (0, import_jsx_runtime36.jsxs)(Touch, {
        Component: OnboardingTooltipContainer,
        className: clsx("vkuiPanel__in", "vkuiInternalPanel__in"),
        children: [
          (0, import_jsx_runtime36.jsx)("div", {
            className: "vkuiPanel__in-before"
          }),
          centered ? (0, import_jsx_runtime36.jsx)("div", {
            className: "vkuiPanel__centered",
            children
          }) : children,
          (0, import_jsx_runtime36.jsx)("div", {
            className: "vkuiPanel__in-after"
          })
        ]
      })
    }))
  });
};
function usePanelMode(modeProp, sizeX) {
  const { layout } = React52.useContext(AppRootContext);
  if (modeProp) {
    return modeProp;
  }
  if (layout) {
    return layout;
  }
  if (sizeX !== "none") {
    return sizeX === "regular" ? "card" : "plain";
  }
  return "none";
}

// node_modules/@vkontakte/vkui/dist/components/PanelHeaderButton/PanelHeaderButton.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime());
var React53 = __toESM(require_react());
var platformClassNames = {
  ios: "vkuiPanelHeaderButton--ios",
  android: "vkuiPanelHeaderButton--android",
  vkcom: "vkuiPanelHeaderButton--vkcom"
};
var ButtonTypography = ({ primary, children }) => {
  const platform3 = usePlatform();
  if (platform3 === "ios") {
    return (0, import_jsx_runtime37.jsx)(Title, {
      Component: "span",
      level: "3",
      weight: primary ? "1" : "3",
      children
    });
  }
  return (0, import_jsx_runtime37.jsx)(Text, {
    weight: platform3 === "vkcom" ? void 0 : "2",
    children
  });
};
var warn5 = warnOnce("PanelHeaderButton");
var PanelHeaderButton = (_param) => {
  var { children, primary = false, label, className } = _param, restProps = _object_without_properties(_param, [
    "children",
    "primary",
    "label",
    "className"
  ]);
  const isPrimitive = isPrimitiveReactNode(children);
  const isPrimitiveLabel = isPrimitiveReactNode(label);
  const platform3 = usePlatform();
  let hoverMode;
  let activeMode;
  switch (platform3) {
    case "ios":
      hoverMode = "background";
      activeMode = "opacity";
      break;
    case "vkcom":
      hoverMode = "vkuiPanelHeaderButton--hover";
      activeMode = "vkuiPanelHeaderButton--active";
      break;
    default:
      hoverMode = "background";
      activeMode = "background";
  }
  if (true) {
    const isAccessible = hasAccessibleName(_object_spread({
      children: [
        children,
        label
      ]
    }, restProps));
    if (!isAccessible) {
      warn5(COMMON_WARNINGS.a11y[restProps.href ? "link-name" : "button-name"], "error");
    }
  }
  return (0, import_jsx_runtime37.jsxs)(Tappable, _object_spread_props(_object_spread({
    Component: restProps.href ? "a" : "button"
  }, restProps), {
    hoverMode,
    activeEffectDelay: 200,
    activeMode,
    className: clsx("vkuiPanelHeaderButton", platformClassNames.hasOwnProperty(platform3) ? platformClassNames[platform3] : platformClassNames.android, isPrimitive && "vkuiPanelHeaderButton--primitive", !isPrimitive && !isPrimitiveLabel && "vkuiPanelHeaderButton--notPrimitive", className),
    children: [
      isPrimitive ? (0, import_jsx_runtime37.jsx)(ButtonTypography, {
        primary,
        children
      }) : children,
      isPrimitiveLabel ? (0, import_jsx_runtime37.jsx)(ButtonTypography, {
        primary,
        className: "vkuiPanelHeaderButton__label",
        children: label
      }) : label
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/PanelHeader/PanelHeader.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime());
var React56 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/ModalRootContext.js
var React54 = __toESM(require_react());
var ModalRootContext = React54.createContext({
  updateModalHeight: () => void 0,
  registerModal: () => void 0,
  isInsideModal: false
});
function useModalRegistry(id, type) {
  const modalContext = React54.useContext(ModalRootContext);
  const elements = React54.useRef({}).current;
  useIsomorphicLayoutEffect(() => {
    if (id !== void 0) {
      modalContext.registerModal(_object_spread_props(_object_spread({}, elements), {
        type,
        id
      }));
      const reset = Object.keys(elements).reduce((acc, k) => _object_spread_props(_object_spread({}, acc), {
        [k]: null
      }), {
        type,
        id
      });
      return () => modalContext.registerModal(reset);
    }
    return void 0;
  }, []);
  const refs = React54.useRef({
    modalElement: (e) => elements.modalElement = e,
    innerElement: (e) => elements.innerElement = e,
    headerElement: (e) => elements.headerElement = e,
    contentElement: (e) => elements.contentElement = e,
    bottomInset: (e) => elements.bottomInset = e
  }).current;
  return {
    refs
  };
}

// node_modules/@vkontakte/vkui/dist/components/Separator/Separator.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime());
var modeClassNames = {
  "primary": "vkuiSeparator--mode-primary",
  "secondary": "vkuiSeparator--mode-secondary",
  "primary-alpha": "vkuiSeparator--mode-primaryAlpha"
};
var Separator = (_param) => {
  var { wide, mode = "primary" } = _param, restProps = _object_without_properties(_param, [
    "wide",
    "mode"
  ]);
  return (0, import_jsx_runtime38.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx(!wide && "vkuiSeparator--padded", modeClassNames[mode]),
    children: (0, import_jsx_runtime38.jsx)("hr", {
      className: "vkuiSeparator__in"
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Spacing/Spacing.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime());
var React55 = __toESM(require_react());
var CUSTOM_CSS_TOKEN_FOR_USER_GAP = "--vkui_internal--Spacing_gap";
var sizesClassNames = {
  "3xs": "vkuiSpacing--3xs",
  "2xs": "vkuiSpacing--2xs",
  "xs": "vkuiSpacing--xs",
  "s": "vkuiSpacing--s",
  "m": "vkuiSpacing--m",
  "l": "vkuiSpacing--l",
  "xl": "vkuiSpacing--xl",
  "2xl": "vkuiSpacing--2xl",
  "3xl": "vkuiSpacing--3xl",
  "4xl": "vkuiSpacing--4xl"
};
var Spacing = (_param) => {
  var { size: size4 = "m", style } = _param, restProps = _object_without_properties(_param, [
    "size",
    "style"
  ]);
  return (0, import_jsx_runtime39.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    style: _object_spread({}, typeof size4 === "number" && {
      [CUSTOM_CSS_TOKEN_FOR_USER_GAP]: `${size4}px`
    }, style),
    baseClassName: clsx("vkuiSpacing", typeof size4 === "string" && sizesClassNames[size4])
  }));
};

// node_modules/@vkontakte/vkui/dist/components/PanelHeader/PanelHeader.js
var platformClassNames2 = {
  ios: "vkuiPanelHeader--ios",
  android: "vkuiPanelHeader--android",
  vkcom: clsx("vkuiPanelHeader--vkcom", "vkuiInternalPanelHeader--vkcom")
};
var sizeXClassNames3 = {
  none: "vkuiPanelHeader--sizeX-none",
  regular: "vkuiPanelHeader--sizeX-regular"
};
var sizeYClassNames12 = {
  none: "vkuiPanelHeader--sizeY-none",
  compact: "vkuiPanelHeader--sizeY-compact"
};
var PanelHeaderIn = ({ before, after, children, typographyProps = {} }) => {
  const { Component: Component3 = "span" } = typographyProps, restProps = _object_without_properties(typographyProps, [
    "Component"
  ]);
  const { hasCustomPanelHeaderAfter, customPanelHeaderAfterMinWidth } = useConfigProvider();
  const { isInsideModal } = React56.useContext(ModalRootContext);
  const platform3 = usePlatform();
  const afterSlotProps = !hasCustomPanelHeaderAfter || isInsideModal ? {
    children: after
  } : {
    style: {
      minWidth: customPanelHeaderAfterMinWidth
    }
  };
  const typographyNode = platform3 === "vkcom" ? (0, import_jsx_runtime40.jsx)(Text, _object_spread_props(_object_spread({
    weight: "2",
    Component: Component3
  }, restProps), {
    children
  })) : (0, import_jsx_runtime40.jsx)(Component3, _object_spread_props(_object_spread({
    className: "vkuiPanelHeader__content-in"
  }, restProps), {
    children
  }));
  return (0, import_jsx_runtime40.jsxs)(OnboardingTooltipContainer, {
    fixed: true,
    className: "vkuiPanelHeader__in",
    children: [
      (0, import_jsx_runtime40.jsx)("div", {
        className: clsx("vkuiPanelHeader__before", "vkuiInternalPanelHeader__before"),
        children: before
      }),
      (0, import_jsx_runtime40.jsx)("div", {
        className: "vkuiPanelHeader__content",
        children: typographyNode
      }),
      (0, import_jsx_runtime40.jsx)("div", _object_spread({
        className: clsx("vkuiPanelHeader__after", "vkuiInternalPanelHeader__after")
      }, afterSlotProps))
    ]
  });
};
var PanelHeader = (_param) => {
  var { before, children, after, float = false, transparent = false, delimiter = "auto", shadow, getRef, getRootRef, fixed, typographyProps } = _param, restProps = _object_without_properties(_param, [
    "before",
    "children",
    "after",
    "float",
    "transparent",
    "delimiter",
    "shadow",
    "getRef",
    "getRootRef",
    "fixed",
    "typographyProps"
  ]);
  const platform3 = usePlatform();
  const { sizeX = "none", sizeY = "none" } = useAdaptivity();
  const { sizeX: adaptiveSizeX } = useAdaptivityConditionalRender();
  const isVKCOM = platform3 === "vkcom";
  const isFixed = fixed !== void 0 ? fixed : !isVKCOM;
  const separatorVisible = delimiter === "auto" || delimiter === "separator";
  const staticSeparatorVisible = !float && separatorVisible;
  const staticSpacingVisible = !float && (delimiter === "auto" || delimiter === "spacing");
  return (0, import_jsx_runtime40.jsxs)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiPanelHeader", "vkuiInternalPanelHeader", platformClassNames2.hasOwnProperty(platform3) ? platformClassNames2[platform3] : platformClassNames2.android, transparent && "vkuiPanelHeader--trnsp", shadow && "vkuiPanelHeader--shadow", !float && clsx("vkuiPanelHeader--static", "vkuiInternalPanelHeader--static"), staticSeparatorVisible && clsx("vkuiPanelHeader--sep", "vkuiInternalPanelHeader--sep"), !before && clsx("vkuiPanelHeader--no-before", "vkuiInternalPanelHeader--no-before"), !after && "vkuiPanelHeader--no-after", isFixed && "vkuiPanelHeader--fixed", sizeX !== "compact" && sizeXClassNames3[sizeX], sizeY !== "regular" && sizeYClassNames12[sizeY]),
    getRootRef: isFixed ? getRootRef : getRef,
    children: [
      isFixed ? (0, import_jsx_runtime40.jsx)(FixedLayout, {
        className: clsx("vkuiPanelHeader__fixed", "vkuiInternalPanelHeader__fixed"),
        vertical: "top",
        getRootRef: getRef,
        children: (0, import_jsx_runtime40.jsx)(PanelHeaderIn, {
          before,
          after,
          typographyProps,
          children
        })
      }) : (0, import_jsx_runtime40.jsx)(PanelHeaderIn, {
        before,
        after,
        typographyProps,
        children
      }),
      !isVKCOM && (0, import_jsx_runtime40.jsxs)(import_jsx_runtime40.Fragment, {
        children: [
          staticSeparatorVisible && adaptiveSizeX.compact && (0, import_jsx_runtime40.jsx)(Separator, {
            className: adaptiveSizeX.compact.className
          }),
          staticSpacingVisible && adaptiveSizeX.regular && (0, import_jsx_runtime40.jsx)(Spacing, {
            className: adaptiveSizeX.regular.className,
            size: 16
          })
        ]
      }),
      separatorVisible && isVKCOM && (0, import_jsx_runtime40.jsx)(Separator, {
        className: "vkuiPanelHeader__separator",
        wide: true
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/PanelHeaderContent/PanelHeaderContent.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime());
var React57 = __toESM(require_react());
var platformClassNames3 = {
  ios: "vkuiPanelHeaderContent--ios",
  android: "vkuiPanelHeaderContent--android",
  vkcom: "vkuiPanelHeaderContent--vkcom"
};
var sizeYClassNames13 = {
  none: "vkuiPanelHeaderContent--sizeY-none",
  compact: "vkuiPanelHeaderContent--sizeY-compact"
};
var PanelHeaderChildren = ({ hasStatus, hasBefore, children }) => {
  const platform3 = usePlatform();
  return hasStatus || hasBefore ? (0, import_jsx_runtime41.jsx)(Text, {
    className: "vkuiPanelHeaderContent__childrenText",
    Component: "div",
    weight: platform3 === "vkcom" ? "2" : void 0,
    children
  }) : (0, import_jsx_runtime41.jsx)("div", {
    className: "vkuiPanelHeaderContent__children-in",
    children
  });
};
var PanelHeaderContent = (_param) => {
  var { aside, status, before, children, onClick } = _param, restProps = _object_without_properties(_param, [
    "aside",
    "status",
    "before",
    "children",
    "onClick"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const InComponent = onClick ? Tappable : "div";
  const rootProps = onClick ? {} : restProps;
  const platform3 = usePlatform();
  const inProps = onClick ? _object_spread_props(_object_spread({}, restProps), {
    onClick,
    activeEffectDelay: 200,
    hasActive: platform3 === "ios",
    activeMode: "opacity"
  }) : {};
  return (0, import_jsx_runtime41.jsxs)(RootComponent, _object_spread_props(_object_spread({}, rootProps), {
    baseClassName: clsx("vkuiPanelHeaderContent", platformClassNames3.hasOwnProperty(platform3) ? platformClassNames3[platform3] : platformClassNames3.android, sizeY !== "regular" && sizeYClassNames13[sizeY]),
    children: [
      hasReactNode(before) && (0, import_jsx_runtime41.jsx)("div", {
        className: "vkuiPanelHeaderContent__before",
        children: before
      }),
      (0, import_jsx_runtime41.jsxs)(InComponent, _object_spread_props(_object_spread({}, inProps), {
        className: clsx("vkuiPanelHeaderContent__in", !before && platform3 !== "android" && "vkuiPanelHeaderContent__in--centered"),
        children: [
          hasReactNode(status) && (0, import_jsx_runtime41.jsx)(Footnote, {
            className: "vkuiPanelHeaderContent__status",
            children: status
          }),
          (0, import_jsx_runtime41.jsxs)("div", {
            className: "vkuiPanelHeaderContent__children",
            children: [
              (0, import_jsx_runtime41.jsx)(PanelHeaderChildren, {
                hasStatus: hasReactNode(status),
                hasBefore: hasReactNode(before),
                children
              }),
              hasReactNode(aside) && (0, import_jsx_runtime41.jsx)("div", {
                className: "vkuiPanelHeaderContent__aside",
                children: aside
              })
            ]
          }),
          hasReactNode(before) && (0, import_jsx_runtime41.jsx)("div", {
            className: "vkuiPanelHeaderContent__width"
          })
        ]
      }))
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/PanelHeaderContext/PanelHeaderContext.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime());
var React58 = __toESM(require_react());
var sizeXClassNames4 = {
  none: "vkuiPanelHeaderContext--sizeX-none",
  compact: "vkuiPanelHeaderContext--sizeX-compact",
  regular: "vkuiPanelHeaderContext--sizeX-regular"
};
var PanelHeaderContext = (_param) => {
  var { children, opened = false, className, onClose } = _param, restProps = _object_without_properties(_param, [
    "children",
    "opened",
    "className",
    "onClose"
  ]);
  const platform3 = usePlatform();
  const { sizeX = "none" } = useAdaptivity();
  const elementRef = React58.useRef(null);
  const [animationState, animationHandlers] = useCSSKeyframesAnimationController(opened ? "enter" : "exit", void 0, true);
  const visible = animationState !== "exited";
  useScrollLock(platform3 !== "vkcom" && visible);
  const handleGlobalOnClickOutside = React58.useCallback((event) => {
    if (opened) {
      event.stopPropagation();
      onClose();
    }
  }, [
    opened,
    onClose
  ]);
  useGlobalOnClickOutside(handleGlobalOnClickOutside, visible ? elementRef : null);
  if (!visible) {
    return null;
  }
  return (0, import_jsx_runtime42.jsxs)(FixedLayout, _object_spread_props(_object_spread({}, restProps), {
    className: clsx("vkuiPanelHeaderContext", platform3 === "ios" && "vkuiPanelHeaderContext--ios", opened ? "vkuiPanelHeaderContext--opened" : "vkuiPanelHeaderContext--closing", sizeXClassNames4[sizeX], className),
    vertical: "top",
    children: [
      (0, import_jsx_runtime42.jsx)("div", {
        onClick: (event) => {
          event.stopPropagation();
          onClose();
        },
        className: "vkuiPanelHeaderContext__fade"
      }),
      (0, import_jsx_runtime42.jsx)("div", _object_spread_props(_object_spread({
        "data-testid": false ? "content" : void 0,
        className: "vkuiPanelHeaderContext__in",
        ref: elementRef
      }, animationHandlers), {
        children: (0, import_jsx_runtime42.jsx)("div", {
          className: "vkuiPanelHeaderContext__content",
          children
        })
      }))
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/SplitLayout/SplitLayout.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime());
var React63 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/PopoutRoot/PopoutRoot.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime());
var React62 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/AppRoot/AppRootPortal.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime());
var React61 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/createPortal.js
var ReactDOM2 = __toESM(require_react_dom());
var createPortal2 = (children, container, key) => {
  const resolvedContainer = container ? container : getDocumentBody();
  return resolvedContainer && ReactDOM2.createPortal(children, resolvedContainer, key);
};

// node_modules/@vkontakte/vkui/dist/components/AppearanceProvider/AppearanceProvider.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime());
var React60 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ConfigProvider/ConfigProviderOverride.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime());
var React59 = __toESM(require_react());
function ConfigProviderOverride(_param) {
  var { children } = _param, contextValue = _object_without_properties(_param, [
    "children"
  ]);
  const parentConfig = useConfigProvider();
  const configContext = useObjectMemo(_object_spread({}, parentConfig, contextValue));
  return (0, import_jsx_runtime43.jsx)(ConfigProviderContext.Provider, {
    value: configContext,
    children
  });
}

// node_modules/@vkontakte/vkui/dist/components/AppearanceProvider/AppearanceProvider.js
var AppearanceProvider = ({ value, children }) => {
  return (0, import_jsx_runtime44.jsx)(ConfigProviderOverride, {
    appearance: value,
    children: (0, import_jsx_runtime44.jsx)(IconAppearanceProvider, {
      value,
      children: (0, import_jsx_runtime44.jsx)(TokensClassProvider, {
        children
      })
    })
  });
};

// node_modules/@vkontakte/vkui/dist/components/AppRoot/AppRootPortal.js
var AppRootPortal = ({ children, usePortal }) => {
  const { portalRoot, mode, disablePortal } = React61.useContext(AppRootContext);
  const appearance = useAppearance();
  const isClient = useIsClient();
  if (!isClient) {
    return null;
  }
  const portalContainer = resolvePortalContainer(usePortal, portalRoot.current);
  if (!portalContainer || shouldDisablePortal(usePortal, mode, Boolean(disablePortal))) {
    return (0, import_jsx_runtime45.jsx)(React61.Fragment, {
      children
    });
  }
  return createPortal2((0, import_jsx_runtime45.jsx)(AppearanceProvider, {
    value: appearance,
    children
  }), portalContainer);
};
function shouldDisablePortal(usePortal, mode, disablePortal) {
  if (usePortal !== void 0) {
    if (typeof usePortal !== "boolean") {
      return false;
    }
    return disablePortal || usePortal !== true;
  }
  return disablePortal || mode === "full";
}
function resolvePortalContainer(usePortal, portalRootFromContext) {
  if (usePortal === true || !usePortal) {
    return portalRootFromContext ? portalRootFromContext : null;
  }
  return isRefObject(usePortal) ? usePortal.current : usePortal;
}

// node_modules/@vkontakte/vkui/dist/components/PopoutRoot/PopoutRoot.js
var PopoutRootPopout = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  return (0, import_jsx_runtime46.jsx)("div", _object_spread({
    className: clsx("vkuiPopoutRoot__popout", className)
  }, restProps));
};
var PopoutRootModal = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  return (0, import_jsx_runtime46.jsx)("div", _object_spread({
    className: clsx("vkuiPopoutRoot__modal", className)
  }, restProps));
};
var PopoutRoot = (_param) => {
  var { popout, modal, children } = _param, restProps = _object_without_properties(_param, [
    "popout",
    "modal",
    "children"
  ]);
  return (0, import_jsx_runtime46.jsxs)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: "vkuiPopoutRoot",
    children: [
      children,
      (0, import_jsx_runtime46.jsxs)(AppRootPortal, {
        children: [
          !!popout && (0, import_jsx_runtime46.jsx)(PopoutRootPopout, {
            children: popout
          }),
          !!modal && (0, import_jsx_runtime46.jsx)(PopoutRootModal, {
            children: modal
          })
        ]
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/SplitLayout/SplitLayout.js
var SplitLayout = (_param) => {
  var { popout, modal, header, children, getRootRef, getRef, className, center } = _param, restProps = _object_without_properties(_param, [
    "popout",
    "modal",
    "header",
    "children",
    "getRootRef",
    "getRef",
    "className",
    "center"
  ]);
  const platform3 = usePlatform();
  return (0, import_jsx_runtime47.jsxs)(PopoutRoot, {
    className: clsx("vkuiSplitLayout", platform3 === "ios" && "vkuiSplitLayout--ios"),
    popout,
    modal,
    getRootRef,
    children: [
      header,
      (0, import_jsx_runtime47.jsx)("div", _object_spread_props(_object_spread({}, restProps), {
        ref: getRef,
        className: clsx("vkuiSplitLayout__inner", !!header && "vkuiSplitLayout__inner--header", center && "vkuiSplitLayout__inner--center", className),
        children
      }))
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/SplitCol/SplitCol.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime());
var React65 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useMediaQueries.js
var React64 = __toESM(require_react());
var mediaQueriesCache = /* @__PURE__ */ new WeakMap();
function getMediaQueries(matchMedia2) {
  return {
    desktopPlus: matchMedia2(MEDIA_QUERIES.DESKTOP_PLUS),
    smallTabletPlus: matchMedia2(MEDIA_QUERIES.SMALL_TABLET_PLUS),
    tablet: matchMedia2(MEDIA_QUERIES.TABLET),
    smallTablet: matchMedia2(MEDIA_QUERIES.SMALL_TABLET),
    mobile: matchMedia2(MEDIA_QUERIES.MOBILE),
    mediumHeight: matchMedia2(MEDIA_QUERIES.MEDIUM_HEIGHT),
    mobileLandscapeHeight: matchMedia2(MEDIA_QUERIES.MOBILE_LANDSCAPE_HEIGHT)
  };
}
var useMediaQueries = () => {
  const { window: window2 } = useDOM();
  return React64.useMemo(function initializeStoreOrUpdateStoreIfWindowChanges() {
    if (!window2) {
      return getMediaQueries(mediaQueryNull);
    }
    const storedMediaQueries = mediaQueriesCache.get(window2);
    if (storedMediaQueries) {
      return storedMediaQueries;
    }
    const mediaQueries = getMediaQueries(window2.matchMedia.bind(window2));
    mediaQueriesCache.set(window2, mediaQueries);
    return mediaQueries;
  }, [
    window2
  ]);
};

// node_modules/@vkontakte/vkui/dist/components/SplitCol/SplitCol.js
var breakpointClassNames = {
  none: clsx("vkuiSplitCol--viewWidth-none", "vkuiInternalSplitCol--viewWidth-none"),
  tabletMinus: "vkuiSplitCol--viewWidth-tabletMinus",
  smallTabletPlus: "vkuiSplitCol--viewWidth-smallTabletPlus",
  tabletPlus: "vkuiInternalSplitCol--viewWidth-tabletPlus"
};
function useTransitionAnimate(animateProp) {
  const { viewWidth } = useAdaptivity();
  const [animate3, setAnimate] = React65.useState(Boolean(animateProp));
  const mediaQueries = useMediaQueries();
  React65.useEffect(() => {
    if (animateProp !== void 0) {
      setAnimate(animateProp);
      return;
    }
    if (viewWidth !== void 0) {
      setAnimate(viewWidth < ViewWidth.TABLET);
      return;
    }
    const listener = () => setAnimate(!mediaQueries.smallTabletPlus.matches);
    listener();
    matchMediaListAddListener(mediaQueries.smallTabletPlus, listener);
    return () => {
      matchMediaListRemoveListener(mediaQueries.smallTabletPlus, listener);
    };
  }, [
    animateProp,
    viewWidth,
    mediaQueries
  ]);
  return animate3;
}
var SplitCol = (props) => {
  const { children, width, maxWidth, minWidth, animate: animateProp, fixed, style, autoSpaced, stretchedOnMobile, getRootRef } = props, restProps = _object_without_properties(props, [
    "children",
    "width",
    "maxWidth",
    "minWidth",
    "animate",
    "fixed",
    "style",
    "autoSpaced",
    "stretchedOnMobile",
    "getRootRef"
  ]);
  const baseRef = useExternRef(getRootRef);
  const { viewWidth } = useAdaptivity();
  const animate3 = useTransitionAnimate(animateProp);
  const contextValue = useObjectMemo({
    colRef: baseRef,
    animate: animate3
  });
  return (0, import_jsx_runtime48.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    style: _object_spread_props(_object_spread({}, style), {
      width,
      maxWidth,
      minWidth
    }),
    getRootRef: baseRef,
    baseClassName: clsx("vkuiSplitCol", viewWidthToClassName(breakpointClassNames, viewWidth), autoSpaced && clsx("vkuiSplitCol--spaced-auto", "vkuiInternalSplitCol--spaced-auto"), fixed && "vkuiSplitCol--fixed", stretchedOnMobile && "vkuiSplitCol--stretched-on-mobile"),
    children: (0, import_jsx_runtime48.jsx)(SplitColContext.Provider, {
      value: contextValue,
      children: fixed ? (0, import_jsx_runtime48.jsx)("div", {
        className: "vkuiSplitCol__fixedInner",
        children
      }) : children
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Epic/Epic.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime());
var React67 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Epic/ScrollSaver.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime());
var React66 = __toESM(require_react());
var ScrollSaver = ({ children, initialScroll, saveScroll }) => {
  const { getScroll, scrollTo } = React66.useContext(ScrollContext);
  useIsomorphicLayoutEffect(() => {
    if (typeof initialScroll === "number") {
      scrollTo(0, initialScroll);
    }
    return () => saveScroll(getScroll().y);
  }, []);
  return (0, import_jsx_runtime49.jsx)(React66.Fragment, {
    children
  });
};

// node_modules/@vkontakte/vkui/dist/components/Epic/Epic.js
var warn6 = warnOnce("Epic");
var Epic = (_param) => {
  var { activeStory, tabbar, children } = _param, restProps = _object_without_properties(_param, [
    "activeStory",
    "tabbar",
    "children"
  ]);
  const scroll = React67.useRef({}).current;
  var _React_Children_toArray_find;
  const story = (_React_Children_toArray_find = React67.Children.toArray(children).find((story2) => React67.isValidElement(story2) && getNavId(story2.props, warn6) === activeStory)) !== null && _React_Children_toArray_find !== void 0 ? _React_Children_toArray_find : null;
  return (0, import_jsx_runtime50.jsxs)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiEpic", tabbar && "vkuiInternalEpic--hasTabbar"),
    children: [
      (0, import_jsx_runtime50.jsx)(ScrollSaver, {
        initialScroll: scroll[activeStory] || 0,
        saveScroll: (value) => scroll[activeStory] = value,
        children: story
      }, activeStory),
      tabbar
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Tabbar/Tabbar.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime());
var React68 = __toESM(require_react());
var getItemsLayoutClassName = (itemsLayout, children) => {
  switch (itemsLayout) {
    case "horizontal":
      return "vkuiInternalTabbar--layout-horizontal";
    case "vertical":
      return "vkuiInternalTabbar--layout-vertical";
    default:
      return React68.Children.count(children) > 2 ? getItemsLayoutClassName("vertical", []) : getItemsLayoutClassName("horizontal", []);
  }
};
var Tabbar = (_param) => {
  var { plain = false, mode } = _param, restProps = _object_without_properties(_param, [
    "plain",
    "mode"
  ]);
  const platform3 = usePlatform();
  return (0, import_jsx_runtime51.jsx)(RootComponent, _object_spread({
    baseClassName: clsx("vkuiInternalTabbar", "vkuiTabbar", platform3 === "ios" && "vkuiTabbar--ios", getItemsLayoutClassName(mode, restProps.children), !plain && "vkuiTabbar--shadow")
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/TabbarItem/TabbarItem.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime());
var React69 = __toESM(require_react());
var warn7 = warnOnce("TabbarItem");
var TabbarItem = (_param) => {
  var { children, selected, indicator, text, href, Component: Component3 = href ? "a" : "button", disabled } = _param, restProps = _object_without_properties(_param, [
    "children",
    "selected",
    "indicator",
    "text",
    "href",
    "Component",
    "disabled"
  ]);
  const platform3 = usePlatform();
  if (true) {
    const hasAccessibleName2 = text || restProps["aria-label"] || restProps["aria-labelledby"];
    if (!hasAccessibleName2) {
      warn7(COMMON_WARNINGS.a11y[Component3 === "a" ? "link-name" : "button-name"], "error");
    }
  }
  return (0, import_jsx_runtime52.jsxs)(RootComponent, _object_spread_props(_object_spread({
    Component: Component3
  }, restProps), {
    disabled,
    href,
    baseClassName: clsx("vkuiTabbarItem", platform3 === "ios" && "vkuiTabbarItem--ios", platform3 === "android" && "vkuiTabbarItem--android", selected && "vkuiTabbarItem--selected"),
    children: [
      (0, import_jsx_runtime52.jsx)(Tappable, {
        role: "presentation",
        disabled,
        activeMode: platform3 === "ios" ? "vkuiTabbarItem__tappable--active" : "background",
        activeEffectDelay: platform3 === "ios" ? 0 : 300,
        hasHover: false,
        className: "vkuiTabbarItem__tappable",
        onClick: noop
      }),
      (0, import_jsx_runtime52.jsxs)("div", {
        className: "vkuiTabbarItem__in",
        children: [
          (0, import_jsx_runtime52.jsxs)("div", {
            className: "vkuiTabbarItem__icon",
            children: [
              children,
              (0, import_jsx_runtime52.jsx)("div", {
                className: "vkuiInternalTabbarItem__label",
                children: hasReactNode(indicator) && indicator
              })
            ]
          }),
          text && (0, import_jsx_runtime52.jsx)(Footnote, {
            Component: "div",
            className: "vkuiTabbarItem__text",
            weight: "2",
            children: text
          })
        ]
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ScrollArrow/ScrollArrow.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime());
var React70 = __toESM(require_react());
var stylesSize2 = {
  m: "vkuiScrollArrow--size-m",
  l: "vkuiScrollArrow--size-l"
};
var stylesDirection2 = {
  up: "vkuiScrollArrow--direction-up",
  right: "vkuiScrollArrow--direction-right",
  down: "vkuiScrollArrow--direction-down",
  left: "vkuiScrollArrow--direction-left"
};
var labelDirection = {
  up: "Назад",
  right: "Вперед",
  down: "Вперед",
  left: "Назад"
};
var ArrowIcon = ({ size: size4 }) => {
  let Icon = Icon24Chevron;
  if (size4 === "m") {
    Icon = Icon16Chevron;
  }
  return (0, import_jsx_runtime53.jsx)(Icon, {
    className: "vkuiScrollArrow__defaultIcon"
  });
};
var ScrollArrow = (_param) => {
  var { size: size4 = "l", offsetY, direction, label: labelProp, children = (0, import_jsx_runtime53.jsx)(ArrowIcon, {
    size: size4
  }) } = _param, restProps = _object_without_properties(_param, [
    "size",
    "offsetY",
    "direction",
    "label",
    "children"
  ]);
  const label = labelProp !== null && labelProp !== void 0 ? labelProp : labelDirection[direction];
  return (0, import_jsx_runtime53.jsxs)(RootComponent, _object_spread_props(_object_spread({
    Component: "button",
    type: "button",
    baseClassName: clsx("vkuiScrollArrow", stylesSize2[size4], stylesDirection2[direction])
  }, restProps), {
    children: [
      label && (0, import_jsx_runtime53.jsx)(VisuallyHidden, {
        children: label
      }),
      (0, import_jsx_runtime53.jsx)("span", {
        className: "vkuiScrollArrow__icon",
        style: offsetY ? {
          top: offsetY
        } : void 0,
        children
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/HorizontalScroll/HorizontalScroll.js
var import_jsx_runtime54 = __toESM(require_jsx_runtime());
var React72 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useDirection.js
var React71 = __toESM(require_react());
function useDirection() {
  const ref = React71.useRef(null);
  const [direction, setDirection] = React71.useState(void 0);
  const [writingMode, setWritingMode] = React71.useState(void 0);
  const { window: window2 } = useDOM();
  const update = () => {
    if (!window2 || !ref.current) {
      return;
    }
    const styleDeclaration = window2.getComputedStyle(ref.current);
    setDirection(styleDeclaration.direction);
    setWritingMode(styleDeclaration.writingMode);
  };
  useIsomorphicLayoutEffect(update, [
    window2
  ]);
  return [
    ref,
    direction,
    writingMode
  ];
}

// node_modules/@vkontakte/vkui/dist/lib/fx.js
function easeInOutSine(x) {
  return 0.5 * (1 - Math.cos(Math.PI * x));
}
function cubicBezier(x1, x2) {
  return function(progress) {
    const t = progress;
    const cx = 3 * x1;
    const bx = 3 * (x2 - x1) - cx;
    const ax = 1 - cx - bx;
    const x = ax * Math.pow(t, 3) + bx * Math.pow(t, 2) + cx * t;
    return x;
  };
}

// node_modules/@vkontakte/vkui/dist/components/HorizontalScroll/HorizontalScroll.js
function now() {
  return performance && performance.now ? performance.now() : Date.now();
}
function roundingAwayFromZero(value) {
  return value > 0 ? Math.ceil(value) : Math.floor(value);
}
var roundUpElementScrollLeft = (el) => roundingAwayFromZero(el.scrollLeft);
var SCROLL_ONE_FRAME_TIME = 250;
function doScroll({ scrollElement, getScrollPosition, animationQueue, onScrollToEndBorder, onScrollEnd, onScrollStart, initialScrollWidth, scrollAnimationDuration, textDirection }) {
  if (!scrollElement || !getScrollPosition) {
    return;
  }
  const extremeScrollLeft = (textDirection === "ltr" ? 1 : -1) * (initialScrollWidth - scrollElement.offsetWidth);
  let startScrollLeft = roundUpElementScrollLeft(scrollElement);
  let endScrollLeft = getScrollPosition(startScrollLeft);
  onScrollStart();
  if (startScrollLeft * endScrollLeft < 0) {
    endScrollLeft = 0;
  }
  if (Math.abs(endScrollLeft) >= Math.abs(extremeScrollLeft)) {
    onScrollToEndBorder();
    endScrollLeft = extremeScrollLeft;
  }
  const startTime = now();
  (function scroll() {
    const time = now();
    const elapsed = Math.min((time - startTime) / scrollAnimationDuration, 1);
    const value = easeInOutSine(elapsed);
    const currentScrollLeft = startScrollLeft + (endScrollLeft - startScrollLeft) * value;
    scrollElement.scrollLeft = roundingAwayFromZero(currentScrollLeft);
    const scrollEnd = textDirection === "ltr" ? Math.max(0, endScrollLeft) : Math.min(0, endScrollLeft);
    if (roundUpElementScrollLeft(scrollElement) !== scrollEnd && elapsed !== 1) {
      requestAnimationFrame(scroll);
      return;
    }
    onScrollEnd();
    animationQueue.shift();
    if (animationQueue.length > 0) {
      animationQueue[0]();
    }
  })();
}
var HorizontalScroll = (_param) => {
  var { children, getScrollToLeft, getScrollToRight, showArrows = true, arrowSize = "l", arrowOffsetY, scrollAnimationDuration = SCROLL_ONE_FRAME_TIME, getRef, scrollOnAnyWheel = false, inline: inline3 = false } = _param, restProps = _object_without_properties(_param, [
    "children",
    "getScrollToLeft",
    "getScrollToRight",
    "showArrows",
    "arrowSize",
    "arrowOffsetY",
    "scrollAnimationDuration",
    "getRef",
    "scrollOnAnyWheel",
    "inline"
  ]);
  const [canScrollLeft, setCanScrollLeft] = React72.useState(false);
  const [canScrollRight, setCanScrollRight] = React72.useState(false);
  const [directionRef, textDirection] = useDirection();
  const direction = textDirection || "ltr";
  const setCanScrollStart = direction === "ltr" ? setCanScrollLeft : setCanScrollRight;
  const setCanScrollEnd = direction === "ltr" ? setCanScrollRight : setCanScrollLeft;
  const isCustomScrollingRef = React72.useRef(false);
  const scrollerRef = useExternRef(getRef, directionRef);
  const animationQueue = React72.useRef([]);
  const hasPointer = useAdaptivityHasPointer();
  const scrollTo = React72.useCallback((getScrollPosition) => {
    const scrollElement = scrollerRef.current;
    animationQueue.current.push(() => {
      var _scrollElement_firstElementChild;
      return doScroll({
        scrollElement,
        getScrollPosition,
        animationQueue: animationQueue.current,
        onScrollToEndBorder: () => setCanScrollEnd(false),
        onScrollEnd: () => isCustomScrollingRef.current = false,
        onScrollStart: () => isCustomScrollingRef.current = true,
        initialScrollWidth: (scrollElement === null || scrollElement === void 0 ? void 0 : (_scrollElement_firstElementChild = scrollElement.firstElementChild) === null || _scrollElement_firstElementChild === void 0 ? void 0 : _scrollElement_firstElementChild.scrollWidth) || 0,
        scrollAnimationDuration,
        textDirection: direction
      });
    });
    if (animationQueue.current.length === 1) {
      animationQueue.current[0]();
    }
  }, [
    scrollerRef,
    scrollAnimationDuration,
    direction,
    setCanScrollEnd
  ]);
  const scrollToLeft = React72.useCallback(() => {
    const getScrollPosition = getScrollToLeft !== null && getScrollToLeft !== void 0 ? getScrollToLeft : (i) => i - scrollerRef.current.offsetWidth;
    scrollTo(getScrollPosition);
  }, [
    getScrollToLeft,
    scrollTo,
    scrollerRef
  ]);
  const scrollToRight = React72.useCallback(() => {
    const getScrollPosition = getScrollToRight !== null && getScrollToRight !== void 0 ? getScrollToRight : (i) => i + scrollerRef.current.offsetWidth;
    scrollTo(getScrollPosition);
  }, [
    getScrollToRight,
    scrollTo,
    scrollerRef
  ]);
  const calculateArrowsVisibility = React72.useCallback(() => {
    if (showArrows && hasPointer && scrollerRef.current && !isCustomScrollingRef.current) {
      const scrollElement = scrollerRef.current;
      setCanScrollStart(scrollElement.scrollLeft !== 0);
      setCanScrollEnd(Math.abs(roundUpElementScrollLeft(scrollElement)) + scrollElement.offsetWidth < scrollElement.scrollWidth);
    }
  }, [
    showArrows,
    hasPointer,
    scrollerRef,
    setCanScrollStart,
    setCanScrollEnd
  ]);
  React72.useEffect(calculateArrowsVisibility, [
    calculateArrowsVisibility,
    children
  ]);
  const _onWheel = React72.useCallback((e) => {
    scrollerRef.current.scrollBy({
      left: e.deltaX + e.deltaY,
      behavior: "auto"
    });
  }, [
    scrollerRef
  ]);
  const onScrollWheel = React72.useCallback((e) => {
    _onWheel(e);
    e.preventDefault();
  }, [
    _onWheel
  ]);
  const onArrowWheel = React72.useCallback((e) => {
    if (e.deltaX || e.deltaY && scrollOnAnyWheel) {
      _onWheel(e);
    }
  }, [
    _onWheel,
    scrollOnAnyWheel
  ]);
  return (0, import_jsx_runtime54.jsxs)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiHorizontalScroll", "vkuiInternalHorizontalScroll", showArrows === "always" && "vkuiHorizontalScroll--withConstArrows", inline3 && "vkuiHorizontalScroll--inline"),
    onMouseEnter: calculateArrowsVisibility,
    children: [
      showArrows && (hasPointer || hasPointer === void 0) && canScrollLeft && (0, import_jsx_runtime54.jsx)(ScrollArrow, {
        "data-testid": false ? "ScrollArrowLeft" : void 0,
        size: arrowSize,
        offsetY: arrowOffsetY,
        direction: "left",
        "aria-hidden": true,
        tabIndex: -1,
        className: clsx("vkuiHorizontalScroll__arrow", "vkuiHorizontalScroll__arrowLeft"),
        onClick: scrollToLeft,
        onWheel: onArrowWheel
      }),
      showArrows && (hasPointer || hasPointer === void 0) && canScrollRight && (0, import_jsx_runtime54.jsx)(ScrollArrow, {
        "data-testid": false ? "ScrollArrowRight" : void 0,
        size: arrowSize,
        offsetY: arrowOffsetY,
        direction: "right",
        "aria-hidden": true,
        tabIndex: -1,
        className: clsx("vkuiHorizontalScroll__arrow", "vkuiHorizontalScroll__arrowRight"),
        onClick: scrollToRight,
        onWheel: onArrowWheel
      }),
      (0, import_jsx_runtime54.jsx)("div", {
        className: "vkuiHorizontalScroll__in",
        ref: scrollerRef,
        onScroll: calculateArrowsVisibility,
        onWheel: scrollOnAnyWheel ? onScrollWheel : void 0,
        children: (0, import_jsx_runtime54.jsx)("div", {
          className: "vkuiHorizontalScroll__in-wrapper",
          children
        })
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/AspectRatio/AspectRatio.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime());
var React73 = __toESM(require_react());
function AspectRatio(_param) {
  var { ratio, mode = "stretch", style: styleProp } = _param, props = _object_without_properties(_param, [
    "ratio",
    "mode",
    "style"
  ]);
  const style = {
    "--vkui_internal--aspect_ratio": String(ratio)
  };
  return (0, import_jsx_runtime55.jsx)(RootComponent, _object_spread({
    baseClassName: clsx("vkuiAspectRatio", mode === "stretch" && "vkuiAspectRatio--mode-stretch"),
    style: _object_spread({}, styleProp, style)
  }, props));
}

// node_modules/@vkontakte/vkui/dist/components/Flex/Flex.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime());
var import_react8 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/layouts/gaps.js
var columnGapClassNames = {
  "2xs": "vkui-column-gap--2xs",
  "xs": "vkui-column-gap--xs",
  "s": "vkui-column-gap--s",
  "m": "vkui-column-gap--m",
  "l": "vkui-column-gap--l",
  "xl": "vkui-column-gap--xl",
  "2xl": "vkui-column-gap--2xl",
  "3xl": "vkui-column-gap--3xl",
  "4xl": "vkui-column-gap--4xl"
};
var rowGapClassNames = {
  "2xs": "vkui-row-gap--2xs",
  "xs": "vkui-row-gap--xs",
  "s": "vkui-row-gap--s",
  "m": "vkui-row-gap--m",
  "l": "vkui-row-gap--l",
  "xl": "vkui-row-gap--xl",
  "2xl": "vkui-row-gap--2xl",
  "3xl": "vkui-row-gap--3xl",
  "4xl": "vkui-row-gap--4xl"
};
function calculateGap(gap) {
  if (!gap) {
    return [
      void 0,
      void 0
    ];
  }
  if (typeof gap === "number" || typeof gap === "string") {
    return [
      gap,
      gap
    ];
  }
  return gap;
}

// node_modules/@vkontakte/vkui/dist/components/Flex/FlexItem/FlexItem.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime());
var flexClassNames = {
  grow: "vkuiFlexItem--flex-grow",
  shrink: "vkuiFlexItem--flex-shrink",
  content: "vkuiFlexItem--flex-content",
  fixed: "vkuiFlexItem--flex-fixed"
};
var alignSelfClassNames = {
  start: "vkuiFlexItem--align-self-start",
  end: "vkuiFlexItem--align-self-end",
  center: "vkuiFlexItem--align-self-center",
  baseline: "vkuiFlexItem--align-self-baseline",
  stretch: "vkuiFlexItem--align-self-stretch"
};
var FlexItem = (_param) => {
  var { children, alignSelf, flex, flexBasis, style } = _param, rest = _object_without_properties(_param, [
    "children",
    "alignSelf",
    "flex",
    "flexBasis",
    "style"
  ]);
  return (0, import_jsx_runtime56.jsx)(RootComponent, _object_spread_props(_object_spread({}, rest), {
    style: _object_spread({
      flexBasis
    }, style),
    baseClassName: clsx("vkuiFlexItem", alignSelf && alignSelfClassNames[alignSelf], flex && flexClassNames[flex]),
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Flex/Flex.js
var justifyClassNames = {
  "start": "vkuiFlex--justify-start",
  "end": "vkuiFlex--justify-end",
  "center": "vkuiFlex--justify-center",
  "space-around": "vkuiFlex--justify-space-around",
  "space-between": "vkuiFlex--justify-space-between",
  "space-evenly": "vkuiFlex--justify-space-evenly"
};
var alignClassNames = {
  start: "vkuiFlex--align-start",
  end: "vkuiFlex--align-end",
  center: "vkuiFlex--align-center",
  stretch: "vkuiFlex--align-stretch",
  baseline: "vkuiFlex--align-baseline"
};
var Flex = (_param) => {
  var { gap, align, justify, margin = "none", noWrap = false, direction = "row", style: styleProp, reverse = false, children } = _param, props = _object_without_properties(_param, [
    "gap",
    "align",
    "justify",
    "margin",
    "noWrap",
    "direction",
    "style",
    "reverse",
    "children"
  ]);
  const withGaps = import_react8.Children.count(children) > 1 && gap;
  const [columnGap, rowGap] = calculateGap(withGaps ? gap : void 0);
  return (0, import_jsx_runtime57.jsx)(RootComponent, _object_spread_props(_object_spread({}, props), {
    baseClassName: clsx("vkuiFlex", !noWrap && "vkuiFlex--wrap", reverse && "vkuiFlex--reverse", direction !== "row" && "vkuiFlex--direction-column", margin !== "none" && "vkuiFlex--margin-auto", align && alignClassNames[align], justify && justifyClassNames[justify], withGaps && "vkuiFlex--withGaps", withGaps && getGapsPresets(rowGap, columnGap)),
    style: withGaps ? _object_spread({}, getGapsByUser(rowGap, columnGap), styleProp) : styleProp,
    children
  }));
};
function getGapsPresets(rowGap, columnGap) {
  return clsx(typeof rowGap === "string" && rowGapClassNames[rowGap], typeof columnGap === "string" && columnGapClassNames[columnGap]);
}
function getGapsByUser(rowGap, columnGap) {
  const style = {};
  if (typeof rowGap === "number") {
    style["--vkui_internal--row_gap"] = `${rowGap}px`;
  }
  if (typeof columnGap === "number") {
    style["--vkui_internal--column_gap"] = `${columnGap}px`;
  }
  return style;
}
Flex.Item = FlexItem;

// node_modules/@vkontakte/vkui/dist/components/SimpleGrid/SimpleGrid.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime());
var marginClassNames = {
  "auto": "vkuiSimpleGrid--margin-auto",
  "auto-inline": "vkuiSimpleGrid--margin-auto-inline",
  "auto-block": "vkuiSimpleGrid--margin-auto-block"
};
var alignClassNames2 = {
  start: "vkuiSimpleGrid--align-start",
  end: "vkuiSimpleGrid--align-end",
  center: "vkuiSimpleGrid--align-center",
  stretch: "vkuiSimpleGrid--align-stretch",
  baseline: "vkuiSimpleGrid--align-baseline"
};
var SimpleGrid = (_param) => {
  var { columns = 1, gap, style: styleProp, margin = "none", minColWidth, align = "stretch" } = _param, props = _object_without_properties(_param, [
    "columns",
    "gap",
    "style",
    "margin",
    "minColWidth",
    "align"
  ]);
  const style = {};
  const [columnGap, rowGap] = calculateGap(gap);
  if (typeof rowGap === "number") {
    style["--vkui_internal--row_gap"] = `${rowGap}px`;
  }
  if (typeof columnGap === "number") {
    style["--vkui_internal--column_gap"] = `${columnGap}px`;
  }
  style["--vkui_internal--grid_columns"] = `${columns}`;
  if (minColWidth) {
    style["--vkui_internal--min_col_width"] = `${minColWidth}px`;
  }
  return (0, import_jsx_runtime58.jsx)(RootComponent, _object_spread_props(_object_spread({}, props), {
    baseClassName: clsx("vkuiSimpleGrid", margin !== "none" && marginClassNames[margin], alignClassNames2[align], minColWidth && "vkuiSimpleGrid--with-min-width", typeof columnGap === "string" && columnGapClassNames[columnGap], typeof rowGap === "string" && rowGapClassNames[rowGap]),
    style: _object_spread({}, style, styleProp)
  }));
};

// node_modules/@vkontakte/vkui/dist/components/PopoutWrapper/PopoutWrapper.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime());
var React74 = __toESM(require_react());
var stylesAlignX = {
  center: "vkuiPopoutWrapper--alignX-center",
  left: "vkuiPopoutWrapper--alignX-left",
  right: "vkuiPopoutWrapper--alignX-right"
};
var stylesAlignY = {
  center: "vkuiPopoutWrapper--alignY-center",
  top: "vkuiPopoutWrapper--alignY-top",
  bottom: "vkuiPopoutWrapper--alignY-bottom"
};
var PopoutWrapper = (_param) => {
  var { alignY = "center", alignX = "center", closing = false, noBackground = false, fixed = true, children, onClick } = _param, restProps = _object_without_properties(_param, [
    "alignY",
    "alignX",
    "closing",
    "noBackground",
    "fixed",
    "children",
    "onClick"
  ]);
  return (0, import_jsx_runtime59.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiPopoutWrapper", stylesAlignY[alignY], stylesAlignX[alignX], closing ? "vkuiPopoutWrapper--closing" : "vkuiPopoutWrapper--opened", fixed && "vkuiPopoutWrapper--fixed", !noBackground && "vkuiPopoutWrapper--masked"),
    children: (0, import_jsx_runtime59.jsxs)("div", {
      className: "vkuiPopoutWrapper__container",
      children: [
        (0, import_jsx_runtime59.jsx)("div", {
          className: "vkuiPopoutWrapper__overlay",
          onClick
        }),
        (0, import_jsx_runtime59.jsx)("div", {
          className: "vkuiPopoutWrapper__content",
          children
        })
      ]
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Alert/Alert.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime());
var React80 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivityWithJSMediaQueries.js
var React75 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/helpers/getOrDefault.js
function getOrDefault(value, defaultValue) {
  return value !== null && value !== void 0 ? value : defaultValue;
}

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivityWithJSMediaQueries.js
var useAdaptivityWithJSMediaQueries = () => {
  if (!canUseDOM) {
    console.error(`[useAdaptivityWithJSMediaQueries] Похоже, вы пытаетесь использовать хук вне браузера.

Постарайтесь этого избегать, чтобы не было ошибок при гидратации: при SSR нет информации о размерах экрана.

Используйте CSS Media Query или библиотеку по типу https://github.com/artsy/fresnel.`);
  }
  const { viewWidth: viewWidthContext, viewHeight: viewHeightContext, sizeX: sizeXContext, sizeY: sizeYContext, hasPointer: hasPointerContext, hasHover: hasHoverContext } = React75.useContext(AdaptivityContext);
  const platform3 = usePlatform();
  const mediaQueries = useMediaQueries();
  const [[viewWidthLocal, viewHeightLocal], setViewSizeLocal] = React75.useState(() => [
    getOrDefault(viewWidthContext, getViewWidthByMediaQueries(mediaQueries)),
    getOrDefault(viewHeightContext, getViewHeightByMediaQueries(mediaQueries))
  ]);
  const adaptivityProps = React75.useMemo(() => {
    const hasPointer = getOrDefault(hasPointerContext, hasMouse);
    const hasHover2 = getOrDefault(hasHoverContext, hasHover);
    const viewWidth = getOrDefault(viewWidthContext, viewWidthLocal);
    const viewHeight = getOrDefault(viewHeightContext, viewHeightLocal);
    const sizeX = getOrDefault(sizeXContext, getSizeX(viewWidth));
    const sizeY = getOrDefault(sizeYContext, getSizeY(viewWidth, viewHeight, hasPointer));
    const isDesktop = tryToCheckIsDesktop(viewWidth, viewHeight, hasPointer, platform3);
    return {
      viewWidth,
      viewHeight,
      sizeX,
      sizeY,
      hasPointer,
      hasHover: hasHover2,
      isDesktop
    };
  }, [
    viewWidthLocal,
    viewHeightLocal,
    viewWidthContext,
    viewHeightContext,
    sizeXContext,
    sizeYContext,
    hasPointerContext,
    hasHoverContext,
    platform3
  ]);
  React75.useEffect(() => {
    const handleMediaQuery = () => {
      setViewSizeLocal((prevSizeLocal) => {
        const newViewWidthLocal = getOrDefault(viewWidthContext, getViewWidthByMediaQueries(mediaQueries));
        const newViewHeightLocal = getOrDefault(viewHeightContext, getViewHeightByMediaQueries(mediaQueries));
        const [prevViewWidthLocal, prevViewHeightLocal] = prevSizeLocal;
        if (prevViewWidthLocal !== newViewWidthLocal || prevViewHeightLocal !== newViewHeightLocal) {
          return [
            newViewWidthLocal,
            newViewHeightLocal
          ];
        }
        return prevSizeLocal;
      });
    };
    if (!viewWidthContext) {
      [
        mediaQueries.desktopPlus,
        mediaQueries.tablet,
        mediaQueries.smallTablet,
        mediaQueries.mobile
      ].forEach((matchMediaListener) => matchMediaListAddListener(matchMediaListener, handleMediaQuery));
    }
    if (!viewHeightContext) {
      [
        mediaQueries.mediumHeight,
        mediaQueries.mobileLandscapeHeight
      ].forEach((matchMediaListener) => matchMediaListAddListener(matchMediaListener, handleMediaQuery));
    }
    return () => {
      [
        mediaQueries.desktopPlus,
        mediaQueries.tablet,
        mediaQueries.smallTablet,
        mediaQueries.mobile,
        mediaQueries.mediumHeight,
        mediaQueries.mobileLandscapeHeight
      ].forEach((matchMediaListener) => matchMediaListRemoveListener(matchMediaListener, handleMediaQuery));
    };
  }, [
    mediaQueries,
    viewWidthContext,
    viewHeightContext
  ]);
  return adaptivityProps;
};

// node_modules/@vkontakte/vkui/dist/components/FocusTrap/FocusTrap.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime());
var import_react9 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/helpers/array.js
function arraysEquals(arrA, arrB) {
  if (arrA.length !== arrB.length) {
    return false;
  }
  return arrA.every((item, index2) => item === arrB[index2]);
}

// node_modules/@vkontakte/vkui/dist/hooks/useMutationObserver.js
var useMutationObserver = (ref, callback) => {
  const stableCallback = useStableCallback(callback);
  useIsomorphicLayoutEffect(() => {
    if (!ref || !ref.current) {
      return;
    }
    const observer = new MutationObserver(stableCallback);
    observer.observe(ref.current, {
      subtree: true,
      childList: true
    });
    return () => observer.disconnect();
  }, [
    ref,
    stableCallback
  ]);
};

// node_modules/@vkontakte/vkui/dist/components/FocusTrap/FocusTrap.js
var FOCUSABLE_ELEMENTS = FOCUSABLE_ELEMENTS_LIST.join();
var useRestoreFocus = ({ restoreFocus, timeout, mount, ref }) => {
  const restoreFocusRef = (0, import_react9.useRef)(restoreFocus);
  restoreFocusRef.current = restoreFocus;
  const [restoreFocusTo, setRestoreFocusTo] = (0, import_react9.useState)(null);
  const restoreFocusImpl = useStableCallback(() => {
    const shouldRestoreFocus = typeof restoreFocusRef.current === "function" ? restoreFocusRef.current() : restoreFocusRef.current;
    if (!shouldRestoreFocus) {
      return;
    }
    setTimeout(() => {
      const restoreFocusElement = isHTMLElement(shouldRestoreFocus) && shouldRestoreFocus || isHTMLElement(restoreFocusTo) && restoreFocusTo || null;
      if (restoreFocusElement) {
        restoreFocusElement.focus();
        setRestoreFocusTo(null);
      }
    }, timeout);
  });
  useIsomorphicLayoutEffect(function calculateRestoreFocusTo() {
    if (!ref.current || !restoreFocusRef.current || !mount) {
      setRestoreFocusTo(null);
      return;
    }
    setRestoreFocusTo(getActiveElementByAnotherElement(ref.current));
  }, [
    ref,
    mount
  ]);
  useIsomorphicLayoutEffect(function tryToRestoreFocusOnUnmount() {
    return () => {
      restoreFocusImpl();
    };
  }, [
    restoreFocusImpl
  ]);
  useIsomorphicLayoutEffect(function tryToRestoreFocusWhenFakeUnmount() {
    if (!mount) {
      restoreFocusImpl();
    }
  }, [
    mount,
    restoreFocusImpl
  ]);
};
var FocusTrap = (_param) => {
  var { Component: Component3 = "div", onClose, autoFocus = true, restoreFocus = true, disabled = false, mount = true, timeout = 0, getRootRef, children } = _param, restProps = _object_without_properties(_param, [
    "Component",
    "onClose",
    "autoFocus",
    "restoreFocus",
    "disabled",
    "mount",
    "timeout",
    "getRootRef",
    "children"
  ]);
  const ref = useExternRef(getRootRef);
  const { document: document2 } = useDOM();
  const focusableNodesRef = (0, import_react9.useRef)([]);
  useRestoreFocus({
    restoreFocus,
    timeout,
    mount,
    ref
  });
  const focusNodeByIndex = (nodeIndex) => {
    const element = focusableNodesRef.current[nodeIndex];
    if (element) {
      element.focus({
        preventScroll: true
      });
    }
  };
  const recalculateFocusableNodesRef = (parentNode) => {
    const newFocusableElements = parentNode.querySelectorAll(FOCUSABLE_ELEMENTS);
    const nodes = [];
    newFocusableElements.forEach((focusableEl) => {
      const { display, visibility } = getComputedStyle(focusableEl);
      if (display !== "none" && visibility !== "hidden") {
        nodes.push(focusableEl);
      }
    });
    if (nodes.length === 0) {
      nodes.push(parentNode);
    }
    focusableNodesRef.current = nodes;
  };
  const onMutateParentHandler = (parentNode) => {
    const oldFocusableNodes = [
      ...focusableNodesRef.current
    ];
    recalculateFocusableNodesRef(parentNode);
    if (!autoFocus || arraysEquals(oldFocusableNodes, focusableNodesRef.current)) {
      return;
    }
    if (document2) {
      const activeElement = document2.activeElement;
      const currentElementIndex = Math.max(document2.activeElement ? focusableNodesRef.current.indexOf(activeElement) : -1, 0);
      focusNodeByIndex(currentElementIndex);
    }
  };
  useMutationObserver(ref, () => ref.current && onMutateParentHandler(ref.current));
  useIsomorphicLayoutEffect(() => {
    ref.current && recalculateFocusableNodesRef(ref.current);
  }, [
    ref
  ]);
  useIsomorphicLayoutEffect(function tryToAutoFocusToFirstNode() {
    if (!ref.current || !autoFocus || disabled) {
      return;
    }
    const autoFocusToNode = () => {
      if (!ref.current || !focusableNodesRef.current.length) {
        return;
      }
      const activeElement = getActiveElementByAnotherElement(ref.current);
      if (!contains(ref.current, activeElement)) {
        if (autoFocus === "root") {
          var _ref_current;
          (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.focus();
        } else {
          focusableNodesRef.current[0].focus();
        }
      }
    };
    const timeoutId = setTimeout(autoFocusToNode, timeout);
    return () => {
      clearTimeout(timeoutId);
    };
  }, [
    autoFocus,
    timeout,
    disabled
  ]);
  useIsomorphicLayoutEffect(() => {
    if (!ref.current) {
      return;
    }
    const onDocumentKeydown = (event) => {
      if (disabled) {
        return;
      }
      const pressedKeyResult = pressedKey(event);
      switch (pressedKeyResult) {
        case Keys.TAB: {
          if (!focusableNodesRef.current.length) {
            return false;
          }
          const lastIdx = focusableNodesRef.current.length - 1;
          const targetIdx = focusableNodesRef.current.findIndex((node) => node === event.target);
          const shouldFocusFirstNode = targetIdx === -1 || targetIdx === lastIdx && !event.shiftKey;
          if (shouldFocusFirstNode || targetIdx === 0 && event.shiftKey) {
            event.preventDefault();
            const node = focusableNodesRef.current[shouldFocusFirstNode ? 0 : lastIdx];
            if (node !== getActiveElementByAnotherElement(node)) {
              node.focus();
            }
            return false;
          }
          break;
        }
        case Keys.ESCAPE: {
          if (onClose) {
            event.preventDefault();
            onClose();
          }
        }
      }
      return true;
    };
    const doc = getWindow(ref.current).document;
    doc.addEventListener("keydown", onDocumentKeydown, {
      capture: true
    });
    return () => {
      doc.removeEventListener("keydown", onDocumentKeydown, true);
    };
  }, [
    onClose,
    ref,
    disabled
  ]);
  return (0, import_jsx_runtime60.jsx)(Component3, _object_spread_props(_object_spread({
    tabIndex: -1,
    ref
  }, restProps), {
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ModalDismissButton/ModalDismissButton.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime());
var React76 = __toESM(require_react());
var ModalDismissButton = (_param) => {
  var { children = "Закрыть", className } = _param, restProps = _object_without_properties(_param, [
    "children",
    "className"
  ]);
  return (0, import_jsx_runtime61.jsxs)(Tappable, _object_spread_props(_object_spread({
    className: clsx("vkuiModalDismissButton", className)
  }, restProps), {
    activeMode: "vkuiModalDismissButton--active",
    hoverMode: "vkuiModalDismissButton--hover",
    children: [
      children && (0, import_jsx_runtime61.jsx)(VisuallyHidden, {
        children
      }),
      (0, import_jsx_runtime61.jsx)(Icon20Cancel, {})
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Alert/AlertActions.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime());
var React78 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Alert/AlertAction.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime());
var React77 = __toESM(require_react());
var AlertActionIos = (_param) => {
  var { mode } = _param, restProps = _object_without_properties(_param, [
    "mode"
  ]);
  return (0, import_jsx_runtime62.jsx)(Tappable, _object_spread({
    Component: restProps.href ? "a" : "button",
    className: clsx("vkuiAlert__action", mode === "destructive" && "vkuiAlert__action--mode-destructive", mode === "cancel" && "vkuiAlert__action--mode-cancel")
  }, restProps));
};
var AlertActionBase = (_param) => {
  var { mode } = _param, restProps = _object_without_properties(_param, [
    "mode"
  ]);
  const platform3 = usePlatform();
  let buttonMode = "tertiary";
  if (platform3 === "vkcom") {
    buttonMode = mode === "cancel" ? "secondary" : "primary";
  }
  return (0, import_jsx_runtime62.jsx)(Button, _object_spread({
    className: clsx("vkuiAlert__button", mode === "cancel" && "vkuiAlert__button--mode-cancel"),
    mode: buttonMode,
    size: "m"
  }, restProps));
};
var AlertAction = (props) => {
  const platform3 = usePlatform();
  if (platform3 === "ios") {
    return (0, import_jsx_runtime62.jsx)(AlertActionIos, _object_spread({}, props));
  }
  return (0, import_jsx_runtime62.jsx)(AlertActionBase, _object_spread({}, props));
};

// node_modules/@vkontakte/vkui/dist/components/Alert/AlertActions.js
var alignStyles = {
  left: "vkuiAlert__actions--align-left",
  center: "vkuiAlert__actions--align-center",
  right: "vkuiAlert__actions--align-right"
};
var directionStyles = {
  vertical: "vkuiAlert__actions--direction-vertical",
  horizontal: "vkuiAlert__actions--direction-horizontal"
};
var AlertActions = ({ actions = [], renderAction = (props) => (0, import_jsx_runtime63.jsx)(AlertAction, _object_spread({}, props)), onItemClick, actionsAlign, actionsLayout }) => {
  const platform3 = usePlatform();
  const direction = platform3 === "vkcom" ? "horizontal" : actionsLayout;
  return (0, import_jsx_runtime63.jsx)("div", {
    className: clsx("vkuiAlert__actions", actionsAlign && alignStyles[actionsAlign], direction && directionStyles[direction]),
    children: actions.map((action, i) => {
      const { title: children, action: _, autoCloseDisabled } = action, restProps = _object_without_properties(action, [
        "title",
        "action",
        "autoCloseDisabled"
      ]);
      return (0, import_jsx_runtime63.jsx)(React78.Fragment, {
        children: renderAction(_object_spread({
          children,
          onClick: () => onItemClick(action)
        }, restProps))
      }, i);
    })
  });
};

// node_modules/@vkontakte/vkui/dist/components/Alert/AlertTypography.js
var import_jsx_runtime64 = __toESM(require_jsx_runtime());
var React79 = __toESM(require_react());
var AlertHeader = (props) => {
  const platform3 = usePlatform();
  switch (platform3) {
    case "ios":
      return (0, import_jsx_runtime64.jsx)(Title, _object_spread({
        className: "vkuiAlert__header",
        weight: "1",
        level: "3"
      }, props));
    default:
      return (0, import_jsx_runtime64.jsx)(Title, _object_spread({
        className: "vkuiAlert__header",
        weight: "2",
        level: "2"
      }, props));
  }
};
var AlertText = (props) => {
  const platform3 = usePlatform();
  switch (platform3) {
    case "vkcom":
      return (0, import_jsx_runtime64.jsx)(Footnote, _object_spread({
        className: "vkuiAlert__text"
      }, props));
    case "ios":
      return (0, import_jsx_runtime64.jsx)(Caption, _object_spread({
        className: "vkuiAlert__text"
      }, props));
    default:
      return (0, import_jsx_runtime64.jsx)(Text, _object_spread({
        Component: "span",
        className: "vkuiAlert__text",
        weight: "3"
      }, props));
  }
};

// node_modules/@vkontakte/vkui/dist/components/Alert/Alert.js
var Alert = (_param) => {
  var { actions, actionsLayout = "horizontal", children, className, style, text, header, onClose, dismissLabel = "Закрыть предупреждение", renderAction, actionsAlign, dismissButtonMode = "outside", dismissButtonTestId, getRootRef } = _param, restProps = _object_without_properties(_param, [
    "actions",
    "actionsLayout",
    "children",
    "className",
    "style",
    "text",
    "header",
    "onClose",
    "dismissLabel",
    "renderAction",
    "actionsAlign",
    "dismissButtonMode",
    "dismissButtonTestId",
    "getRootRef"
  ]);
  const generatedId = React80.useId();
  const headerId = `vkui-alert-${generatedId}-header`;
  const textId = `vkui-alert-${generatedId}-text`;
  const platform3 = usePlatform();
  const { isDesktop } = useAdaptivityWithJSMediaQueries();
  const [closing, setClosing] = React80.useState(false);
  const itemActionCallbackRef = React80.useRef(noop);
  const [animationState, animationHandlers] = useCSSKeyframesAnimationController(closing ? "exit" : "enter", {
    onExited() {
      itemActionCallbackRef.current();
      itemActionCallbackRef.current = noop;
      onClose();
    }
  });
  const isDismissButtonVisible = isDesktop && platform3 !== "ios";
  const elementRef = React80.useRef(null);
  const close = React80.useCallback(() => {
    setClosing(true);
  }, []);
  const onItemClick = React80.useCallback((item) => {
    const { action: itemAction, autoCloseDisabled = false } = item;
    if (autoCloseDisabled) {
      itemAction && itemAction({
        close
      });
    } else {
      if (itemAction) {
        itemActionCallbackRef.current = itemAction;
      }
      setClosing(true);
    }
  }, [
    close
  ]);
  useScrollLock();
  return (0, import_jsx_runtime65.jsx)(PopoutWrapper, {
    className,
    closing,
    style,
    onClick: close,
    getRootRef,
    children: (0, import_jsx_runtime65.jsxs)(FocusTrap, _object_spread_props(_object_spread({}, restProps, animationHandlers), {
      getRootRef: elementRef,
      onClick: stopPropagation,
      onClose: close,
      autoFocus: animationState === "entered",
      className: clsx("vkuiAlert", platform3 === "ios" && "vkuiAlert--ios", platform3 === "vkcom" && "vkuiAlert--vkcom", closing ? "vkuiAlert--closing" : "vkuiAlert--opening", isDesktop && "vkuiAlert--desktop"),
      role: "alertdialog",
      "aria-modal": true,
      "aria-labelledby": headerId,
      "aria-describedby": textId,
      children: [
        (0, import_jsx_runtime65.jsxs)("div", {
          className: clsx("vkuiAlert__content", dismissButtonMode === "inside" && "vkuiAlert__content--withButton"),
          children: [
            hasReactNode(header) && (0, import_jsx_runtime65.jsx)(AlertHeader, {
              id: headerId,
              children: header
            }),
            hasReactNode(text) && (0, import_jsx_runtime65.jsx)(AlertText, {
              id: textId,
              children: text
            }),
            children,
            isDismissButtonVisible && dismissButtonMode === "inside" && (0, import_jsx_runtime65.jsx)(IconButton, {
              label: dismissLabel,
              className: clsx("vkuiAlert__dismiss", "vkuiInternalAlert__dismiss"),
              onClick: close,
              hoverMode: "opacity",
              activeMode: "opacity",
              "data-testid": dismissButtonTestId,
              children: (0, import_jsx_runtime65.jsx)(Icon20Cancel, {})
            })
          ]
        }),
        (0, import_jsx_runtime65.jsx)(AlertActions, {
          actions,
          actionsAlign,
          actionsLayout,
          renderAction,
          onItemClick
        }),
        isDismissButtonVisible && dismissButtonMode === "outside" && (0, import_jsx_runtime65.jsx)(ModalDismissButton, {
          onClick: close,
          "data-testid": dismissButtonTestId,
          children: dismissLabel
        })
      ]
    }))
  });
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheet.js
var import_jsx_runtime74 = __toESM(require_jsx_runtime());
var React89 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheetContext.js
var React81 = __toESM(require_react());
var ActionSheetContext = React81.createContext({});

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheetDefaultIosCloseItem.js
var import_jsx_runtime68 = __toESM(require_jsx_runtime());

// node_modules/@vkontakte/vkui/dist/components/ActionSheetItem/ActionSheetItem.js
var import_jsx_runtime67 = __toESM(require_jsx_runtime());
var React83 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ActionSheetItem/helpers.js
var isRealClickEvent = (event) => {
  return event.type === "click" && event.clientX !== 0 && event.clientY !== 0;
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheetItem/subcomponents/Radio/Radio.js
var import_jsx_runtime66 = __toESM(require_jsx_runtime());
var React82 = __toESM(require_react());
var adaptiveIcon = (0, import_jsx_runtime66.jsx)(AdaptiveIconRenderer, {
  IconCompact: Icon20CheckCircleOn,
  IconRegular: Icon24CheckCircleOn
});
var Radio = (_param) => {
  var { children = adaptiveIcon, getRootRef, getRef, className, style } = _param, restProps = _object_without_properties(_param, [
    "children",
    "getRootRef",
    "getRef",
    "className",
    "style"
  ]);
  return (0, import_jsx_runtime66.jsxs)(RootComponent, {
    getRootRef,
    className,
    style,
    children: [
      (0, import_jsx_runtime66.jsx)(VisuallyHidden, _object_spread({
        Component: "input",
        getRootRef: getRef,
        type: "radio",
        className: "vkuiActionSheetItemRadio__input"
      }, restProps)),
      children
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheetItem/ActionSheetItem.js
var ActionSheetItem = (_param) => {
  var { children, autoCloseDisabled = false, mode = "default", meta, subtitle, before, after, selectable, value, name, checked, defaultChecked, onChange, onClick, onImmediateClick, multiline = false, iconChecked, className, isCancelItem } = _param, restProps = _object_without_properties(_param, [
    "children",
    "autoCloseDisabled",
    "mode",
    "meta",
    "subtitle",
    "before",
    "after",
    "selectable",
    "value",
    "name",
    "checked",
    "defaultChecked",
    "onChange",
    "onClick",
    "onImmediateClick",
    "multiline",
    "iconChecked",
    "className",
    "isCancelItem"
  ]);
  const platform3 = usePlatform();
  const { onItemClick = () => noop, mode: actionSheetMode, onClose: onActionSheetClose } = React83.useContext(ActionSheetContext);
  const { sizeY } = useAdaptivityWithJSMediaQueries();
  const Component3 = selectable ? "label" : void 0;
  const isRich = subtitle || meta || selectable;
  const isCentered = !isRich && !before && platform3 === "ios";
  const onItemClickHandler = React83.useCallback((e) => {
    var _onItemClick;
    (_onItemClick = onItemClick({
      action: onClick,
      immediateAction: onImmediateClick,
      autoClose: !autoCloseDisabled,
      isCancelItem: Boolean(isCancelItem)
    })) === null || _onItemClick === void 0 ? void 0 : _onItemClick(e);
  }, [
    autoCloseDisabled,
    isCancelItem,
    onClick,
    onImmediateClick,
    onItemClick
  ]);
  const onKeyDown = React83.useCallback((event) => {
    if (pressedKey(event) === Keys.ENTER) {
      onActionSheetClose === null || onActionSheetClose === void 0 ? void 0 : onActionSheetClose();
    }
  }, [
    onActionSheetClose
  ]);
  const onItemClickImpl = React83.useCallback((event) => {
    if (selectable) {
      if (isRealClickEvent(event)) {
        onItemClickHandler(event);
      }
    } else {
      onItemClickHandler(event);
    }
  }, [
    onItemClickHandler,
    selectable
  ]);
  return (0, import_jsx_runtime67.jsxs)(Tappable, _object_spread_props(_object_spread({}, Component3 && {
    Component: Component3
  }, restProps), {
    onClick: onItemClickImpl,
    activeMode: platform3 === "ios" ? "vkuiActionSheetItem--active" : void 0,
    className: clsx("vkuiActionSheetItem", platform3 === "ios" && "vkuiActionSheetItem--ios", mode === "cancel" && "vkuiActionSheetItem--mode-cancel", mode === "destructive" && "vkuiActionSheetItem--mode-destructive", sizeY === "compact" && "vkuiActionSheetItem--sizeY-compact", isRich && "vkuiActionSheetItem--rich", actionSheetMode === "menu" && "vkuiActionSheetItem--menu", selectable && "vkuiActionSheetItem--selectable", className),
    onKeyDown,
    children: [
      before && (0, import_jsx_runtime67.jsx)("div", {
        className: "vkuiActionSheetItem__before",
        children: before
      }),
      (0, import_jsx_runtime67.jsxs)("div", {
        className: clsx("vkuiActionSheetItem__container", !multiline && "vkuiActionSheetItem--ellipsis"),
        children: [
          (0, import_jsx_runtime67.jsxs)("div", {
            className: clsx("vkuiActionSheetItem__content", isCentered && "vkuiActionSheetItem--centered"),
            children: [
              platform3 === "ios" ? (0, import_jsx_runtime67.jsx)(Title, {
                className: "vkuiActionSheetItem__children",
                weight: mode === "cancel" ? "2" : "3",
                level: isCentered ? "2" : "3",
                children
              }) : (0, import_jsx_runtime67.jsx)(Text, {
                className: "vkuiActionSheetItem__children",
                children
              }),
              meta && (0, import_jsx_runtime67.jsx)(Text, {
                className: "vkuiActionSheetItem__meta",
                children: meta
              })
            ]
          }),
          subtitle && (0, import_jsx_runtime67.jsx)(Subhead, {
            className: "vkuiActionSheetItem__subtitle",
            children: subtitle
          })
        ]
      }),
      (selectable || after) && (0, import_jsx_runtime67.jsxs)("div", {
        className: "vkuiActionSheetItem__after",
        children: [
          after,
          selectable && (0, import_jsx_runtime67.jsx)(Radio, {
            name,
            value,
            onChange,
            defaultChecked,
            checked,
            disabled: restProps.disabled,
            children: iconChecked
          })
        ]
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheetDefaultIosCloseItem.js
var ActionSheetDefaultIosCloseItem = (props) => {
  return (0, import_jsx_runtime68.jsx)(ActionSheetItem, _object_spread_props(_object_spread({
    mode: "cancel",
    isCancelItem: true
  }, props), {
    children: "Отмена"
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheetDropdownMenu.js
var import_jsx_runtime72 = __toESM(require_jsx_runtime());
var React87 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useEffectDev.js
var import_react10 = __toESM(require_react());
var useEffectDev = true ? import_react10.useEffect : noop;

// node_modules/@vkontakte/vkui/dist/components/Popper/Popper.js
var import_jsx_runtime71 = __toESM(require_jsx_runtime());
var React86 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/FloatingArrow/DefaultIcon.js
var import_jsx_runtime69 = __toESM(require_jsx_runtime());
var React84 = __toESM(require_react());
var DEFAULT_ARROW_WIDTH = 20;
var DEFAULT_ARROW_HEIGHT = 8;
var DEFAULT_ARROW_PADDING = 10;
var PLATFORM_HEIGHT = 1;
var ARROW_HEIGHT_WITH_WHITE_SPACE = DEFAULT_ARROW_HEIGHT + PLATFORM_HEIGHT;
var DefaultIcon = (props) => {
  return (0, import_jsx_runtime69.jsx)("svg", _object_spread_props(_object_spread({
    width: DEFAULT_ARROW_WIDTH,
    height: ARROW_HEIGHT_WITH_WHITE_SPACE,
    viewBox: `0 0 ${DEFAULT_ARROW_WIDTH} ${ARROW_HEIGHT_WITH_WHITE_SPACE}`,
    xmlns: "http://www.w3.org/2000/svg"
  }, props), {
    children: (0, import_jsx_runtime69.jsx)("path", {
      d: "M10 0c3 0 6 8 10 8v1H0V8c3.975 0 7-8 10-8Z",
      fill: "currentColor"
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/FloatingArrow/FloatingArrow.js
var import_jsx_runtime70 = __toESM(require_jsx_runtime());
var React85 = __toESM(require_react());
var placementClassNames = {
  right: "vkuiFloatingArrow--placement-right",
  bottom: "vkuiFloatingArrow--placement-bottom",
  left: "vkuiFloatingArrow--placement-left"
};
var FloatingArrow = (_param) => {
  var { offset: offset4, isStaticOffset, coords, iconStyle, iconClassName, placement = "bottom", getRootRef, Icon = DefaultIcon } = _param, restProps = _object_without_properties(_param, [
    "offset",
    "isStaticOffset",
    "coords",
    "iconStyle",
    "iconClassName",
    "placement",
    "getRootRef",
    "Icon"
  ]);
  const [arrowPlacement, arrowStyles] = getArrowPositionData(placement, coords, offset4, isStaticOffset);
  return (0, import_jsx_runtime70.jsx)("div", _object_spread_props(_object_spread({
    ref: getRootRef,
    style: arrowStyles,
    className: clsx("vkuiFloatingArrow", arrowPlacement && placementClassNames[arrowPlacement])
  }, restProps), {
    children: (0, import_jsx_runtime70.jsx)(Icon, {
      className: clsx("vkuiFloatingArrow__in", iconClassName),
      style: iconStyle
    })
  }));
};
function getArrowPositionData(placement, coords = {
  x: 0,
  y: 0
}, offset4 = 0, isStaticOffset = false) {
  const withOffset = (isVerticalPlacement) => {
    const parsedCoords = {
      x: coords.x || 0,
      y: coords.y || 0
    };
    if (isVerticalPlacement) {
      return isStaticOffset ? offset4 : parsedCoords.y + offset4;
    } else {
      return isStaticOffset ? offset4 : parsedCoords.x + offset4;
    }
  };
  if (placement.startsWith("top")) {
    const xOffsetProp = getXOffsetProp(placement, isStaticOffset);
    return [
      "bottom",
      {
        top: "100%",
        [xOffsetProp]: withOffset(false)
      }
    ];
  } else if (placement.startsWith("right")) {
    const yOffsetProp = getYOffsetProp(placement, isStaticOffset);
    return [
      "left",
      {
        [yOffsetProp]: withOffset(true),
        left: 0
      }
    ];
  } else if (placement.startsWith("bottom")) {
    const xOffsetProp = getXOffsetProp(placement, isStaticOffset);
    return [
      void 0,
      {
        bottom: "100%",
        [xOffsetProp]: withOffset(false)
      }
    ];
  } else {
    const yOffsetProp = getYOffsetProp(placement, isStaticOffset);
    return [
      "right",
      {
        [yOffsetProp]: withOffset(true),
        right: 0
      }
    ];
  }
}
function getXOffsetProp(placement, isStaticOffset) {
  return placement.endsWith("end") && isStaticOffset ? "right" : "left";
}
function getYOffsetProp(placement, isStaticOffset) {
  return placement.endsWith("end") && isStaticOffset ? "bottom" : "top";
}

// node_modules/@vkontakte/vkui/dist/components/Popper/Popper.js
var Popper = (_param) => {
  var {
    // UseFloatingMiddlewaresBootstrapProps
    placement: placementProp = "bottom-start",
    sameWidth,
    hideWhenReferenceHidden,
    offsetByMainAxis = 8,
    offsetByCrossAxis = 0,
    arrow: arrow4,
    arrowHeight = DEFAULT_ARROW_HEIGHT,
    arrowPadding = DEFAULT_ARROW_PADDING,
    customMiddlewares,
    disableFlipMiddleware = false,
    // UseFloatingProps
    autoUpdateOnTargetResize = false,
    // ArrowProps
    arrowProps,
    ArrowIcon: ArrowIcon2 = DefaultIcon,
    // rest
    targetRef,
    getRootRef,
    children,
    usePortal = true,
    style: styleProp,
    onPlacementChange
  } = _param, restProps = _object_without_properties(_param, [
    "placement",
    "sameWidth",
    "hideWhenReferenceHidden",
    "offsetByMainAxis",
    "offsetByCrossAxis",
    "arrow",
    "arrowHeight",
    "arrowPadding",
    "customMiddlewares",
    "disableFlipMiddleware",
    "autoUpdateOnTargetResize",
    "arrowProps",
    "ArrowIcon",
    "targetRef",
    "getRootRef",
    "children",
    "usePortal",
    "style",
    "onPlacementChange"
  ]);
  const [arrowRef, setArrowRef] = React86.useState(null);
  const { strictPlacement, middlewares } = useFloatingMiddlewaresBootstrap({
    placement: placementProp,
    sameWidth,
    arrow: arrow4,
    arrowRef,
    arrowHeight,
    arrowPadding,
    offsetByMainAxis,
    offsetByCrossAxis,
    hideWhenReferenceHidden,
    customMiddlewares,
    disableFlipMiddleware
  });
  const { x: floatingDataX, y: floatingDataY, strategy: floatingPositionStrategy, placement: resolvedPlacement, refs, middlewareData } = useFloating({
    placement: strictPlacement,
    middleware: middlewares,
    whileElementsMounted(...args) {
      return autoUpdateFloatingElement(...args, {
        elementResize: autoUpdateOnTargetResize
      });
    }
  });
  usePlacementChangeCallback(placementProp, resolvedPlacement, onPlacementChange);
  const { arrow: arrowCoords } = middlewareData;
  const handleRootRef = useExternRef(refs.setFloating, getRootRef);
  useIsomorphicLayoutEffect(() => {
    refs.setReference("current" in targetRef ? targetRef.current : targetRef);
  }, [
    refs.setReference,
    targetRef
  ]);
  const dropdown = (0, import_jsx_runtime71.jsxs)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: "vkuiPopper",
    getRootRef: handleRootRef,
    style: _object_spread({}, styleProp, convertFloatingDataToReactCSSProperties(floatingPositionStrategy, floatingDataX, floatingDataY, sameWidth ? null : void 0, middlewareData)),
    children: [
      arrow4 && (0, import_jsx_runtime71.jsx)(FloatingArrow, _object_spread_props(_object_spread({}, arrowProps), {
        coords: arrowCoords,
        placement: resolvedPlacement,
        getRootRef: setArrowRef,
        Icon: ArrowIcon2
      })),
      children
    ]
  }));
  return (0, import_jsx_runtime71.jsx)(AppRootPortal, {
    usePortal,
    children: dropdown
  });
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheetDropdownMenu.js
var warn8 = warnOnce("ActionSheet");
function getEl(ref) {
  return ref && "current" in ref ? ref.current : ref;
}
var ActionSheetDropdownMenu = (_param) => {
  var { children, toggleRef, closing, onClose, className, style, popupOffsetDistance = 0, placement, onAnimationStart, onAnimationEnd } = _param, restProps = _object_without_properties(_param, [
    "children",
    "toggleRef",
    "closing",
    "onClose",
    "className",
    "style",
    "popupOffsetDistance",
    "placement",
    "onAnimationStart",
    "onAnimationEnd"
  ]);
  const { document: document2 } = useDOM();
  const platform3 = usePlatform();
  const { sizeY } = useAdaptivityWithJSMediaQueries();
  const elementRef = React87.useRef(null);
  useEffectDev(() => {
    const toggleEl = getEl(toggleRef);
    if (!toggleEl) {
      warn8(`Свойство "toggleRef" не передано`, "error");
    }
  }, [
    toggleRef
  ]);
  const bodyClickListener = useEventListener("click", (e) => {
    const dropdownElement = elementRef === null || elementRef === void 0 ? void 0 : elementRef.current;
    if (dropdownElement && !dropdownElement.contains(e.target)) {
      onClose === null || onClose === void 0 ? void 0 : onClose();
    }
  });
  React87.useEffect(() => {
    setTimeout(() => {
      bodyClickListener.add(document2.body);
    });
  }, [
    bodyClickListener,
    document2
  ]);
  const onClick = React87.useCallback((e) => e.stopPropagation(), []);
  const targetRef = React87.useMemo(() => {
    if (isRefObject(toggleRef)) {
      return toggleRef;
    }
    return {
      current: toggleRef
    };
  }, [
    toggleRef
  ]);
  return (0, import_jsx_runtime72.jsx)(Popper, {
    targetRef,
    offsetByMainAxis: popupOffsetDistance,
    placement,
    className: clsx("vkuiActionSheet", platform3 === "ios" && "vkuiActionSheet--ios", "vkuiActionSheet--menu", closing ? "vkuiActionSheet--closing" : "vkuiActionSheet--opening", sizeY === "compact" && "vkuiActionSheet--sizeY-compact", className),
    style,
    getRootRef: elementRef,
    usePortal: false,
    onAnimationStart,
    onAnimationEnd,
    children: (0, import_jsx_runtime72.jsx)(FocusTrap, _object_spread_props(_object_spread({
      onClose
    }, restProps), {
      onClick,
      children
    }))
  });
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheetDropdownSheet.js
var import_jsx_runtime73 = __toESM(require_jsx_runtime());
var React88 = __toESM(require_react());
var stopPropagation2 = (e) => e.stopPropagation();
var ActionSheetDropdownSheet = (_param) => {
  var {
    children,
    closing,
    // these 2 props are only omitted - ActionSheetDesktop compat
    toggleRef,
    className
  } = _param, restProps = _object_without_properties(_param, [
    "children",
    "closing",
    "toggleRef",
    "className"
  ]);
  const { sizeY } = useAdaptivityWithJSMediaQueries();
  const platform3 = usePlatform();
  return (0, import_jsx_runtime73.jsx)(FocusTrap, _object_spread_props(_object_spread({}, restProps), {
    onClick: stopPropagation2,
    className: clsx("vkuiActionSheet", platform3 === "ios" && "vkuiActionSheet--ios", closing ? "vkuiActionSheet--closing" : "vkuiActionSheet--opening", sizeY === "compact" && "vkuiActionSheet--sizeY-compact", className),
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheet.js
var ActionSheet = (_param) => {
  var { children, className, header, text, style, iosCloseItem, popupOffsetDistance, placement, mode: modeProp, onClose } = _param, restProps = _object_without_properties(_param, [
    "children",
    "className",
    "header",
    "text",
    "style",
    "iosCloseItem",
    "popupOffsetDistance",
    "placement",
    "mode",
    "onClose"
  ]);
  const platform3 = usePlatform();
  const [closingBy, setClosingBy] = React89.useState(void 0);
  const onCloseWithOther = () => setClosingBy("other");
  const actionCallbackRef = React89.useRef(noop);
  const [animationState, animationHandlers] = useCSSKeyframesAnimationController(closingBy !== void 0 ? "exit" : "enter", {
    onExited() {
      onClose({
        closedBy: closingBy || "other"
      });
      actionCallbackRef.current();
      actionCallbackRef.current = noop;
    }
  });
  const { isDesktop } = useAdaptivityWithJSMediaQueries();
  const mode = modeProp !== null && modeProp !== void 0 ? modeProp : isDesktop ? "menu" : "sheet";
  useScrollLock(mode === "sheet");
  const onItemClick = React89.useCallback(({ action, immediateAction, autoClose, isCancelItem }) => (event) => {
    event.persist();
    immediateAction && immediateAction(event);
    if (autoClose) {
      if (action) {
        actionCallbackRef.current = () => action(event);
      }
      setClosingBy(isCancelItem ? "cancel-item" : "action-item");
    } else {
      action && action(event);
    }
  }, []);
  const contextValue = useObjectMemo({
    onItemClick,
    mode,
    onClose: onCloseWithOther
  });
  const DropdownComponent = mode === "menu" ? ActionSheetDropdownMenu : ActionSheetDropdownSheet;
  const dropdownProps = mode === "menu" ? Object.assign(restProps, {
    popupOffsetDistance,
    placement
  }) : restProps;
  const actionSheet = (0, import_jsx_runtime74.jsx)(ActionSheetContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime74.jsxs)(DropdownComponent, _object_spread_props(_object_spread({
      closing: Boolean(closingBy),
      role: "dialog",
      "aria-modal": "true",
      autoFocus: animationState === "entered"
    }, dropdownProps, animationHandlers), {
      onClose: onCloseWithOther,
      className: mode === "menu" ? className : void 0,
      style: mode === "menu" ? style : void 0,
      children: [
        (0, import_jsx_runtime74.jsxs)("div", {
          className: "vkuiActionSheet__content-wrapper",
          children: [
            (header || text) && (0, import_jsx_runtime74.jsxs)("div", {
              className: "vkuiActionSheet__header",
              children: [
                header && (0, import_jsx_runtime74.jsx)(Footnote, {
                  weight: "2",
                  className: "vkuiActionSheet__title",
                  children: header
                }),
                text && (0, import_jsx_runtime74.jsx)(Footnote, {
                  className: "vkuiActionSheet__text",
                  children: text
                })
              ]
            }),
            children
          ]
        }),
        platform3 === "ios" && mode === "sheet" && (0, import_jsx_runtime74.jsx)("div", {
          className: "vkuiActionSheet__close-item-wrapper--ios",
          children: iosCloseItem !== null && iosCloseItem !== void 0 ? iosCloseItem : (0, import_jsx_runtime74.jsx)(ActionSheetDefaultIosCloseItem, {})
        })
      ]
    }))
  });
  if (mode === "menu") {
    return actionSheet;
  }
  return (0, import_jsx_runtime74.jsx)(PopoutWrapper, {
    closing: Boolean(closingBy),
    alignY: "bottom",
    className,
    style,
    onClick: onCloseWithOther,
    fixed: true,
    children: actionSheet
  });
};

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/ScreenSpinner.js
var import_jsx_runtime80 = __toESM(require_jsx_runtime());
var React96 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/ScreenSpinnerContainer.js
var import_jsx_runtime75 = __toESM(require_jsx_runtime());
var React91 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/context.js
var React90 = __toESM(require_react());
var ScreenSpinnerContext = React90.createContext({
  state: "loading",
  caption: void 0
});

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/ScreenSpinnerContainer.js
var stateClassNames = {
  cancelable: "vkuiScreenSpinner--state-cancelable",
  done: "vkuiScreenSpinner--state-done",
  error: "vkuiScreenSpinner--state-error"
};
var modeClassNames2 = {
  shadow: "vkuiScreenSpinner--mode-shadow",
  overlay: "vkuiScreenSpinner--mode-overlay"
};
var ScreenSpinnerContainer = (_param) => {
  var { state = "loading", mode = "shadow", caption, children } = _param, restProps = _object_without_properties(_param, [
    "state",
    "mode",
    "caption",
    "children"
  ]);
  return (0, import_jsx_runtime75.jsx)(ScreenSpinnerContext.Provider, {
    value: {
      state,
      caption
    },
    children: (0, import_jsx_runtime75.jsxs)(RootComponent, _object_spread_props(_object_spread({
      baseClassName: clsx("vkuiScreenSpinner", modeClassNames2[mode], state !== "loading" && stateClassNames[state], hasReactNode(caption) && "vkuiScreenSpinner--has-caption")
    }, restProps), {
      children: [
        (0, import_jsx_runtime75.jsx)("div", {
          className: "vkuiScreenSpinner__icon-slot",
          children
        }),
        hasReactNode(caption) && (0, import_jsx_runtime75.jsx)(Footnote, {
          className: "vkuiScreenSpinner__caption",
          "aria-hidden": true,
          children: caption
        })
      ]
    }))
  });
};
ScreenSpinnerContainer.displayName = "ScreenSpinnerContainer";

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/ScreenSpinnerLoader.js
var import_jsx_runtime76 = __toESM(require_jsx_runtime());
var React92 = __toESM(require_react());
var ScreenSpinnerLoader = (_param) => {
  var { size: size4 = "large", children } = _param, restProps = _object_without_properties(_param, [
    "size",
    "children"
  ]);
  const { caption } = React92.useContext(ScreenSpinnerContext);
  const a11yText = children ? children : caption !== null && caption !== void 0 ? caption : "Пожалуйста, подождите...";
  return (0, import_jsx_runtime76.jsx)(Spinner, _object_spread_props(_object_spread({
    className: clsx("vkuiScreenSpinner__spinner", !caption && "vkuiScreenSpinner__spinner--transition"),
    size: size4,
    noColor: true
  }, restProps), {
    children: a11yText
  }));
};
ScreenSpinnerLoader.displayName = "ScreenSpinnerLoader";

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/ScreenSpinnerSwapIcon.js
var import_jsx_runtime79 = __toESM(require_jsx_runtime());
var React95 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/Icon48CancelCircle.js
var import_jsx_runtime77 = __toESM(require_jsx_runtime());
var React93 = __toESM(require_react());
var Icon48CancelCircle = (props) => (0, import_jsx_runtime77.jsx)("svg", _object_spread_props(_object_spread({
  className: "vkuiIcon",
  width: "48",
  height: "48",
  viewBox: "0 0 48 48",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, props), {
  children: (0, import_jsx_runtime77.jsx)("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M40 24c0 8.837-7.163 16-16 16S8 32.837 8 24 15.163 8 24 8s16 7.163 16 16Zm-10.08-4.33a1.125 1.125 0 0 0-1.59-1.59L24 22.409l-4.33-4.33a1.125 1.125 0 0 0-1.59 0l-.101.116a1.125 1.125 0 0 0 .1 1.476L22.41 24l-4.33 4.33a1.125 1.125 0 0 0 1.591 1.59L24 25.591l4.33 4.33c.439.439 1.151.439 1.59 0l.101-.116a1.125 1.125 0 0 0-.1-1.476L25.59 24l4.33-4.33Z",
    fill: "currentColor"
  })
}));

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/Icon48DoneOutline.js
var import_jsx_runtime78 = __toESM(require_jsx_runtime());
var React94 = __toESM(require_react());
var Icon48DoneOutline = (props) => (0, import_jsx_runtime78.jsx)("svg", _object_spread_props(_object_spread({
  className: "vkuiIcon",
  width: "48",
  height: "48",
  viewBox: "0 0 48 48",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, props), {
  children: (0, import_jsx_runtime78.jsx)("path", {
    d: "M9 24L19 34L39 14",
    stroke: "currentColor",
    strokeWidth: "3.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })
}));

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/ScreenSpinnerSwapIcon.js
var ScreenSpinnerCancelIcon = (_param) => {
  var { onKeyDown, "aria-label": ariaLabel = "Отменить" } = _param, restProps = _object_without_properties(_param, [
    "onKeyDown",
    "aria-label"
  ]);
  const handlers = mergeCalls({
    onKeyDown: clickByKeyboardHandler
  }, {
    onKeyDown
  });
  let clickableProps = _object_spread_props(_object_spread({}, handlers), {
    "tabIndex": 0,
    "role": "button",
    "aria-label": ariaLabel
  });
  return (0, import_jsx_runtime79.jsx)(RootComponent, _object_spread_props(_object_spread({
    baseClassName: "vkuiScreenSpinner__icon"
  }, clickableProps, restProps), {
    children: (0, import_jsx_runtime79.jsx)(Icon24Cancel, {})
  }));
};
ScreenSpinnerCancelIcon.displayName = "ScreenSpinnerCancelIcon";
var ScreenSpinnerSwapIcon = (_param) => {
  var { cancelLabel } = _param, restProps = _object_without_properties(_param, [
    "cancelLabel"
  ]);
  const { state } = React95.useContext(ScreenSpinnerContext);
  if (state === "cancelable") {
    return (0, import_jsx_runtime79.jsx)(ScreenSpinnerCancelIcon, _object_spread({
      "aria-label": cancelLabel
    }, restProps));
  }
  const Icon = {
    loading: () => null,
    done: Icon48DoneOutline,
    error: Icon48CancelCircle
  }[state];
  return (0, import_jsx_runtime79.jsx)(RootComponent, _object_spread_props(_object_spread({
    baseClassName: "vkuiScreenSpinner__icon"
  }, restProps), {
    children: (0, import_jsx_runtime79.jsx)(Icon, {})
  }));
};
ScreenSpinnerSwapIcon.displayName = "ScreenSpinnerSwapIcon";

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/ScreenSpinner.js
var ScreenSpinner = (_param) => {
  var { style, className, state = "loading", onClick, cancelLabel, mode, caption } = _param, restProps = _object_without_properties(_param, [
    "style",
    "className",
    "state",
    "onClick",
    "cancelLabel",
    "mode",
    "caption"
  ]);
  useScrollLock();
  return (0, import_jsx_runtime80.jsx)(PopoutWrapper, {
    className,
    style,
    noBackground: true,
    children: (0, import_jsx_runtime80.jsxs)(ScreenSpinnerContainer, {
      state,
      mode,
      caption,
      children: [
        (0, import_jsx_runtime80.jsx)(ScreenSpinnerLoader, _object_spread({}, restProps)),
        (0, import_jsx_runtime80.jsx)(ScreenSpinnerSwapIcon, {
          onClick,
          cancelLabel
        })
      ]
    })
  });
};
ScreenSpinner.displayName = "ScreenSpinner";
ScreenSpinner.Container = ScreenSpinnerContainer;
ScreenSpinner.Container.displayName = "ScreenSpinner.Container";
ScreenSpinner.Loader = ScreenSpinnerLoader;
ScreenSpinner.Loader.displayName = "ScreenSpinner.Loader";
ScreenSpinner.SwapIcon = ScreenSpinnerSwapIcon;
ScreenSpinner.SwapIcon.displayName = "ScreenSpinner.SwapIcon";

// node_modules/@vkontakte/vkui/dist/components/Snackbar/Snackbar.js
var import_jsx_runtime82 = __toESM(require_jsx_runtime());
var React98 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useGlobalEscKeyDown.js
var EVENT_OPTIONS2 = {
  passive: true,
  capture: true
};
var useGlobalEscKeyDown = (init, callback) => {
  const { document: document2 } = useDOM();
  useIsomorphicLayoutEffect(() => {
    if (!document2 || !init || !callback) {
      return;
    }
    const handleKeyDown = (event) => {
      if (pressedKey(event) === Keys.ESCAPE) {
        callback(event);
      }
    };
    document2.addEventListener("keydown", handleKeyDown, EVENT_OPTIONS2);
    return () => {
      document2.removeEventListener("keydown", handleKeyDown, EVENT_OPTIONS2);
    };
  }, [
    init,
    document2,
    callback
  ]);
};

// node_modules/@vkontakte/vkui/dist/components/Snackbar/subcomponents/Basic/Basic.js
var import_jsx_runtime81 = __toESM(require_jsx_runtime());
var React97 = __toESM(require_react());
var stylesLayout = {
  none: "vkuiSnackbar--layout-none",
  vertical: "vkuiSnackbar--layout-vertical",
  horizontal: "vkuiSnackbar--layout-horizontal"
};
var sizeYClassNames14 = {
  none: "vkuiSnackbar--sizeY-none",
  regular: "vkuiSnackbar--sizeY-regular"
};
function Basic(_param) {
  var { layout: layoutProps, action, after, before, mode, subtitle, children } = _param, restProps = _object_without_properties(_param, [
    "layout",
    "action",
    "after",
    "before",
    "mode",
    "subtitle",
    "children"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const layout = after || subtitle ? "vertical" : "none";
  return (0, import_jsx_runtime81.jsxs)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiSnackbar__body", stylesLayout[layoutProps || layout], sizeY !== "compact" && sizeYClassNames14[sizeY], mode === "dark" && "vkuiSnackbar--mode-dark"),
    children: [
      before && (0, import_jsx_runtime81.jsx)("div", {
        className: "vkuiSnackbar__before",
        children: before
      }),
      (0, import_jsx_runtime81.jsxs)("div", {
        className: "vkuiSnackbar__content",
        children: [
          (0, import_jsx_runtime81.jsx)(Paragraph, {
            className: "vkuiSnackbar__content-text",
            children
          }),
          subtitle && !action && (0, import_jsx_runtime81.jsx)(Subhead, {
            className: "vkuiSnackbar__content-subtitle",
            children: subtitle
          }),
          action && !subtitle && (0, import_jsx_runtime81.jsx)("div", {
            className: "vkuiSnackbar__action",
            children: action
          })
        ]
      }),
      after && (0, import_jsx_runtime81.jsx)("div", {
        className: "vkuiSnackbar__after",
        children: after
      })
    ]
  }));
}

// node_modules/@vkontakte/vkui/dist/components/Snackbar/utils.js
function resolveOffsetYCssStyle(placement, style, offsetY) {
  if (offsetY === void 0) {
    return style;
  }
  switch (placement) {
    case "top-start":
    case "top":
    case "top-end":
      return _object_spread_props(_object_spread({}, style), {
        top: offsetY
      });
    case "bottom-start":
    case "bottom":
    case "bottom-end":
      return _object_spread_props(_object_spread({}, style), {
        bottom: offsetY
      });
  }
}
function getInitialShiftData(width, height, mediaQueries) {
  return {
    shifted: false,
    direction: null,
    isDesktop: mediaQueries.smallTabletPlus.matches,
    x: 0,
    y: 0,
    width,
    height
  };
}
function getMovedShiftData(placement, shiftData, nextShift) {
  if (shiftData.isDesktop) {
    if (placement.endsWith("start")) {
      shiftData.x = rubberbandIfOutOfBounds(nextShift.x, -shiftData.width, 0);
    } else if (placement.endsWith("end")) {
      shiftData.x = rubberbandIfOutOfBounds(nextShift.x, 0, shiftData.width);
    }
    if (placement.startsWith("bottom")) {
      shiftData.y = rubberbandIfOutOfBounds(nextShift.y, 0, shiftData.height);
    }
  } else if (placement.startsWith("bottom")) {
    shiftData.x = nextShift.x;
    const movingToLeft = nextShift.x < 0 ? -1 : null;
    const movingToRight = nextShift.x > 0 ? 1 : null;
    shiftData.direction = movingToLeft || movingToRight;
  }
  if (placement.startsWith("top")) {
    shiftData.y = rubberbandIfOutOfBounds(nextShift.y, -shiftData.height, 0);
  }
  shiftData.shifted = true;
  return shiftData;
}
var MINIMUM_PAN_GESTURE_FOR_TRIGGER_CLOSE = 200;
function shouldBeClosedByShiftData(placement, shiftData, relativeClientRect, velocity) {
  if (!shiftData.shifted) {
    return false;
  }
  const shouldBeClosedThreshold = {
    x: false,
    y: false
  };
  const shouldBeClosedByVelocity = {
    x: false,
    y: false
  };
  if (shiftData.isDesktop) {
    if (placement.endsWith("start")) {
      shouldBeClosedThreshold.x = relativeClientRect.x < -relativeClientRect.width / 2;
      shouldBeClosedByVelocity.x = relativeClientRect.x < 0 ? velocity.x < -MINIMUM_PAN_GESTURE_FOR_TRIGGER_CLOSE : false;
    } else if (placement.endsWith("end")) {
      shouldBeClosedThreshold.x = relativeClientRect.x > relativeClientRect.width / 2;
      shouldBeClosedByVelocity.x = relativeClientRect.x > 0 ? velocity.x > MINIMUM_PAN_GESTURE_FOR_TRIGGER_CLOSE : false;
    }
    if (placement.startsWith("bottom")) {
      shouldBeClosedThreshold.y = relativeClientRect.y > relativeClientRect.height / 2;
      shouldBeClosedByVelocity.y = relativeClientRect.y > 0 ? velocity.y > MINIMUM_PAN_GESTURE_FOR_TRIGGER_CLOSE : false;
    }
  } else if (placement.startsWith("bottom")) {
    shouldBeClosedThreshold.x = relativeClientRect.x < -relativeClientRect.width / 2 || relativeClientRect.x > relativeClientRect.width / 2;
    shouldBeClosedByVelocity.x = relativeClientRect.x < 0 && velocity.x < -MINIMUM_PAN_GESTURE_FOR_TRIGGER_CLOSE || relativeClientRect.x > 0 && velocity.x > MINIMUM_PAN_GESTURE_FOR_TRIGGER_CLOSE;
  }
  if (placement.startsWith("top")) {
    shouldBeClosedThreshold.y = relativeClientRect.y < -relativeClientRect.height / 2;
    shouldBeClosedByVelocity.y = relativeClientRect.y < 0 ? velocity.y < -MINIMUM_PAN_GESTURE_FOR_TRIGGER_CLOSE : false;
  }
  return shouldBeClosedThreshold.x || shouldBeClosedByVelocity.x || shouldBeClosedThreshold.y || /* istanbul ignore next: подсвечивает жёлтым и пишет "branch not covered" */
  shouldBeClosedByVelocity.y;
}

// node_modules/@vkontakte/vkui/dist/components/Snackbar/Snackbar.js
var placementClassNames2 = {
  "top-start": "vkuiSnackbar--placement-top-start",
  "top": "vkuiSnackbar--placement-top",
  "top-end": "vkuiSnackbar--placement-top-end",
  "bottom-start": "vkuiSnackbar--placement-bottom-start",
  "bottom": "vkuiSnackbar--placement-bottom",
  "bottom-end": "vkuiSnackbar--placement-bottom-end"
};
var animationStateClassNames = {
  enter: "vkuiSnackbar--state-enter",
  entering: "vkuiSnackbar--state-entering",
  entered: "vkuiSnackbar--state-entered",
  exit: "vkuiSnackbar--state-exit",
  exiting: "vkuiSnackbar--state-exiting",
  exited: void 0
};
var Snackbar = (_param) => {
  var { placement = "bottom-start", children, layout, action, before, after, duration = 4e3, onActionClick, onClose, mode = "default", subtitle, offsetY, style, getRootRef } = _param, restProps = _object_without_properties(_param, [
    "placement",
    "children",
    "layout",
    "action",
    "before",
    "after",
    "duration",
    "onActionClick",
    "onClose",
    "mode",
    "subtitle",
    "offsetY",
    "style",
    "getRootRef"
  ]);
  const platform3 = usePlatform();
  const [open, setOpen] = React98.useState(true);
  const [touched, setTouched] = React98.useState(false);
  const rootRef = useExternRef(getRootRef);
  const focused = useFocusWithin(rootRef);
  const inRef = React98.useRef(null);
  const panGestureRecognizer = React98.useRef(null);
  const shiftDataRef = React98.useRef(null);
  const rafRef = React98.useRef(null);
  const closeTimeoutIdRef = React98.useRef();
  const mediaQueries = useMediaQueries();
  const [animationState, animationHandlers] = useCSSKeyframesAnimationController(open ? "enter" : "exit", {
    onExited: onClose
  });
  const clearRAF = React98.useCallback(() => {
    if (rafRef.current !== null) {
      cancelAnimationFrame(rafRef.current);
      rafRef.current = null;
    }
  }, []);
  const updateShiftAxisCSSProperties = React98.useCallback((x, y, direction) => {
    rafRef.current = requestAnimationFrame(() => {
      if (rootRef.current) {
        x === null ? rootRef.current.style.removeProperty("--vkui_internal--snackbar_shift_x") : rootRef.current.style.setProperty("--vkui_internal--snackbar_shift_x", `${x}px`);
        y === null ? rootRef.current.style.removeProperty("--vkui_internal--snackbar_shift_y") : rootRef.current.style.setProperty("--vkui_internal--snackbar_shift_y", `${y}px`);
        direction === null ? rootRef.current.style.removeProperty("--vkui_internal--snackbar_direction") : (
          /* istanbul ignore next: TODO чтобы протестировать кейс, нужно мокать useMediaQueries(), чтобы перебивать mediaQueries.smallTabletPlus.matches */
          rootRef.current.style.setProperty("--vkui_internal--snackbar_direction", `${direction}`)
        );
      }
    });
  }, [
    rootRef
  ]);
  const close = React98.useCallback(() => {
    setOpen(false);
  }, []);
  const handleActionClick = (event) => {
    close();
    if (action) {
      onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick(event);
    }
  };
  const handleTouchStart = (event) => {
    panGestureRecognizer.current = new UIPanGestureRecognizer();
    panGestureRecognizer.current.setStartCoords(event.nativeEvent);
    shiftDataRef.current = getInitialShiftData(rootRef.current.offsetWidth, rootRef.current.offsetHeight, mediaQueries);
    setTouched(true);
  };
  const handleTouchMove = (event) => {
    if (shiftDataRef.current && panGestureRecognizer.current) {
      panGestureRecognizer.current.setInitialTimeOnce();
      panGestureRecognizer.current.setEndCoords(event.nativeEvent);
      shiftDataRef.current = getMovedShiftData(placement, shiftDataRef.current, panGestureRecognizer.current.delta());
      if (shiftDataRef.current.shifted) {
        updateShiftAxisCSSProperties(shiftDataRef.current.x, shiftDataRef.current.y, shiftDataRef.current.direction);
      }
    }
  };
  const handleTouchEnd = () => {
    if (touched && shiftDataRef.current && panGestureRecognizer.current && shouldBeClosedByShiftData(placement, shiftDataRef.current, getRelativeBoundingClientRect(rootRef.current, inRef.current), panGestureRecognizer.current.velocity())) {
      close();
    }
    setTouched(false);
  };
  useIsomorphicLayoutEffect(function closeAfterDelay() {
    if (!open || focused || touched || animationState !== "entered") {
      return;
    }
    closeTimeoutIdRef.current = setTimeout(close, duration);
    return function preventCloseAfterDelayOnUnmount() {
      clearTimeout(closeTimeoutIdRef.current);
    };
  }, [
    open,
    focused,
    touched,
    animationState,
    close,
    duration
  ]);
  useIsomorphicLayoutEffect(function clearUserInteractionDataAfterTouchEnd() {
    if (!touched) {
      clearRAF();
      shiftDataRef.current = null;
      panGestureRecognizer.current = null;
      if (open) {
        updateShiftAxisCSSProperties(null, null, null);
      }
    }
  }, [
    touched,
    open,
    updateShiftAxisCSSProperties,
    clearRAF
  ]);
  React98.useEffect(() => clearRAF, [
    clearRAF
  ]);
  useGlobalEscKeyDown(open, close);
  if (animationState === "exited") {
    return null;
  }
  return (0, import_jsx_runtime82.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    role: "presentation",
    baseClassName: clsx("vkuiSnackbar", platform3 === "ios" && "vkuiSnackbar--ios", touched && "vkuiSnackbar--touched", placementClassNames2[placement], animationStateClassNames[animationState]),
    style: resolveOffsetYCssStyle(placement, style, offsetY),
    getRootRef: rootRef,
    children: (0, import_jsx_runtime82.jsx)("div", _object_spread_props(_object_spread({
      role: "alert",
      className: "vkuiSnackbar__in",
      ref: inRef,
      // mobile
      onTouchStart: handleTouchStart,
      onTouchMove: handleTouchMove,
      onTouchEnd: handleTouchEnd,
      // desktop
      onMouseDown: handleTouchStart,
      onMouseMove: handleTouchMove,
      onMouseUp: handleTouchEnd,
      onMouseLeave: handleTouchEnd
    }, animationHandlers), {
      children: (0, import_jsx_runtime82.jsx)(Basic, {
        mode,
        layout,
        before,
        after,
        subtitle,
        action: action && (0, import_jsx_runtime82.jsx)(Button, {
          align: "left",
          mode: "link",
          appearance: mode === "dark" ? (
            /* istanbul ignore next: проверяется в e2e */
            "overlay"
          ) : "accent",
          size: "s",
          onClick: handleActionClick,
          children: action
        }),
        children
      })
    }))
  }));
};
Snackbar.Basic = Basic;

// node_modules/@vkontakte/vkui/dist/components/Tooltip/Tooltip.js
var import_jsx_runtime84 = __toESM(require_jsx_runtime());
var React101 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/usePatchChildren.js
var React99 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/helpers/getMergedSameEventsByProps.js
var isFunctionExistInProps = (props, key) => typeof props[key] === "function";
var getMergedSameEventsByProps = (mainProps, secondProps) => {
  const result = {};
  for (const eventName in mainProps) {
    if (mainProps.hasOwnProperty(eventName) && secondProps.hasOwnProperty(eventName) && isFunctionExistInProps(mainProps, eventName) && isFunctionExistInProps(secondProps, eventName)) {
      result[eventName] = function mergeSameEventsByProps(...args) {
        secondProps[eventName].apply(this, args);
        mainProps[eventName].apply(this, args);
      };
    }
  }
  return result;
};

// node_modules/@vkontakte/vkui/dist/hooks/usePatchChildren.js
var warn9 = warnOnce("usePatchChildrenRef");
var usePatchChildren = (children, injectProps, externRef) => {
  const isValidElementResult = isValidNotReactFragmentElement(children);
  const isDOMTypeElementResult = isValidElementResult && isDOMTypeElement(children);
  const isForwardedRefElementResult = isValidElementResult && isForwardRefElement(children);
  const shouldUseRef = isDOMTypeElementResult || isForwardedRefElementResult;
  const childRef = useExternRef(shouldUseRef ? children.ref : isValidElementResult ? children.props.getRootRef : void 0, externRef);
  const mergedEventsByInjectProps = getMergedSameEventsByProps(injectProps ? injectProps : {}, isValidElementResult ? children.props : {});
  const props = shouldUseRef ? _object_spread({
    ref: childRef
  }, injectProps, mergedEventsByInjectProps) : isValidElementResult ? _object_spread({
    getRootRef: childRef
  }, injectProps, mergedEventsByInjectProps) : void 0;
  useEffectDev(() => {
    if (!childRef.current) {
      warn9("Кажется, в children передан компонент, который не поддерживает свойство getRootRef. Мы не можем получить ссылку на корневой dom-элемент этого компонента", "error");
    }
  }, [
    isValidElementResult ? children.type : null,
    childRef
  ]);
  return [
    childRef,
    isValidElementResult ? React99.cloneElement(children, props) : children
  ];
};

// node_modules/@vkontakte/vkui/dist/components/TooltipBase/TooltipBase.js
var import_jsx_runtime83 = __toESM(require_jsx_runtime());
var React100 = __toESM(require_react());
var TOOLTIP_MAX_WIDTH = 220;
var stylesAppearance3 = {
  accent: "vkuiTooltipBase--appearance-accent",
  white: "vkuiTooltipBase--appearance-white",
  black: "vkuiTooltipBase--appearance-black",
  inversion: "vkuiTooltipBase--appearance-inversion"
};
var TooltipBase = (_param) => {
  var { appearance = "accent", arrowProps, ArrowIcon: ArrowIcon2 = DefaultIcon, text, header, maxWidth = TOOLTIP_MAX_WIDTH, closeIconLabel = "Закрыть", onCloseIconClick, className } = _param, restProps = _object_without_properties(_param, [
    "appearance",
    "arrowProps",
    "ArrowIcon",
    "text",
    "header",
    "maxWidth",
    "closeIconLabel",
    "onCloseIconClick",
    "className"
  ]);
  return (0, import_jsx_runtime83.jsxs)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiTooltipBase", appearance !== "neutral" && stylesAppearance3[appearance], className),
    role: "tooltip",
    children: [
      arrowProps && (0, import_jsx_runtime83.jsx)(FloatingArrow, _object_spread_props(_object_spread({}, arrowProps), {
        iconClassName: clsx("vkuiTooltipBase__arrow", arrowProps.iconClassName),
        Icon: ArrowIcon2
      })),
      (0, import_jsx_runtime83.jsxs)("div", {
        className: "vkuiTooltipBase__content",
        style: maxWidth !== null ? {
          maxWidth
        } : void 0,
        children: [
          (0, import_jsx_runtime83.jsxs)("div", {
            children: [
              hasReactNode(header) && (0, import_jsx_runtime83.jsx)(Subhead, {
                weight: "2",
                children: header
              }),
              hasReactNode(text) && (0, import_jsx_runtime83.jsx)(Subhead, {
                children: text
              })
            ]
          }),
          typeof onCloseIconClick === "function" && (0, import_jsx_runtime83.jsxs)(Tappable, {
            Component: "button",
            className: "vkuiTooltipBase__closeButton",
            hoverMode: "opacity",
            activeMode: "opacity",
            onClick: onCloseIconClick,
            children: [
              (0, import_jsx_runtime83.jsx)(VisuallyHidden, {
                children: closeIconLabel
              }),
              (0, import_jsx_runtime83.jsx)(Icon16Cancel, {
                display: "block"
              })
            ]
          })
        ]
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Tooltip/Tooltip.js
var Tooltip = (_param) => {
  var {
    // UseFloatingMiddlewaresBootstrapOptions
    placement: placementProp = "bottom",
    arrowPadding = 10,
    arrowHeight = 8,
    offsetByMainAxis = 8,
    offsetByCrossAxis = 0,
    hideWhenReferenceHidden,
    disableFlipMiddleware = false,
    disableTriggerOnFocus = false,
    // useFloatingWithInteractions
    defaultShown,
    shown: shownProp,
    onShownChange,
    hoverDelay = 150,
    // инверсированные св-ва для useFloatingWithInteractions
    enableInteractive = false,
    disableArrow = false,
    disableCloseAfterClick = false,
    // Reference
    children,
    // AppRootProps
    usePortal,
    // TooltipBaseProps
    id: idProp,
    getRootRef,
    appearance = "neutral",
    style: styleProp,
    className,
    zIndex = "var(--vkui--z_index_popout)",
    closable,
    onPlacementChange
  } = _param, popperProps = _object_without_properties(_param, [
    "placement",
    "arrowPadding",
    "arrowHeight",
    "offsetByMainAxis",
    "offsetByCrossAxis",
    "hideWhenReferenceHidden",
    "disableFlipMiddleware",
    "disableTriggerOnFocus",
    "defaultShown",
    "shown",
    "onShownChange",
    "hoverDelay",
    "enableInteractive",
    "disableArrow",
    "disableCloseAfterClick",
    "children",
    "usePortal",
    "id",
    "getRootRef",
    "appearance",
    "style",
    "className",
    "zIndex",
    "closable",
    "onPlacementChange"
  ]);
  const generatedId = React101.useId();
  const tooltipId = idProp || generatedId;
  const [arrowRef, setArrowRef] = React101.useState(null);
  const { middlewares, strictPlacement } = useFloatingMiddlewaresBootstrap({
    placement: placementProp,
    offsetByMainAxis,
    offsetByCrossAxis,
    hideWhenReferenceHidden,
    arrow: !disableArrow,
    arrowRef,
    arrowPadding,
    arrowHeight,
    disableFlipMiddleware
  });
  const { shown, willBeHide, placement, refs, referenceProps, floatingProps, middlewareData, onClose, onEscapeKeyDown } = useFloatingWithInteractions({
    defaultShown,
    shown: shownProp,
    onShownChange,
    placement: strictPlacement,
    trigger: disableTriggerOnFocus ? "hover" : [
      "hover",
      "focus"
    ],
    hoverDelay,
    closeAfterClick: !disableCloseAfterClick,
    disableInteractive: !enableInteractive,
    middlewares
  });
  const tooltipRef = useExternRef(getRootRef, refs.setFloating);
  usePlacementChangeCallback(placementProp, placement, onPlacementChange);
  let tooltip = null;
  if (shown) {
    tooltip = (0, import_jsx_runtime84.jsx)(AppRootPortal, {
      usePortal,
      children: (0, import_jsx_runtime84.jsx)(TooltipBase, _object_spread_props(_object_spread({}, popperProps, floatingProps), {
        style: _object_spread(_object_spread_props(_object_spread({}, floatingProps.style), {
          zIndex
        }), styleProp),
        id: tooltipId,
        getRootRef: tooltipRef,
        appearance,
        arrowProps: disableArrow ? void 0 : {
          placement,
          coords: getArrowCoordsByMiddlewareData(middlewareData),
          getRootRef: setArrowRef
        },
        className: clsx(willBeHide ? animationFadeClassNames.out : animationFadeClassNames.in, className),
        onCloseIconClick: closable ? onClose : void 0
      }))
    });
  }
  const [, child] = usePatchChildren(children, _object_spread({}, referenceProps, shown && {
    "aria-describedby": tooltipId
  }), refs.setReference);
  useGlobalEscKeyDown(shown, onEscapeKeyDown);
  return (0, import_jsx_runtime84.jsxs)(React101.Fragment, {
    children: [
      child,
      tooltip
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/ModalRootAdaptive.js
var import_jsx_runtime90 = __toESM(require_jsx_runtime());
var React109 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/ModalRoot.js
var import_jsx_runtime88 = __toESM(require_jsx_runtime());
var React106 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hoc/withContext.js
var import_jsx_runtime85 = __toESM(require_jsx_runtime());
var React102 = __toESM(require_react());
function withContext(Component3, Ctx, prop) {
  function WithContext(props) {
    const context = React102.useContext(Ctx);
    return (0, import_jsx_runtime85.jsx)(Component3, _object_spread_props(_object_spread({}, props), {
      [prop]: context
    }));
  }
  return WithContext;
}

// node_modules/@vkontakte/vkui/dist/hoc/withPlatform.js
var import_jsx_runtime86 = __toESM(require_jsx_runtime());
var React103 = __toESM(require_react());
function withPlatform(Component3) {
  function WithPlatform(props) {
    const { platform: platform3 } = useConfigProvider();
    return (0, import_jsx_runtime86.jsx)(Component3, _object_spread_props(_object_spread({}, props), {
      platform: platform3
    }));
  }
  return WithPlatform;
}

// node_modules/@vkontakte/vkui/dist/components/Touch/TouchContext.js
var React104 = __toESM(require_react());
var TouchRootContext = React104.createContext(false);
var TouchContext_default = TouchRootContext;

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/constants.js
var MODAL_PAGE_DEFAULT_PERCENT_HEIGHT = 75;

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/useModalManager.js
var import_jsx_runtime87 = __toESM(require_jsx_runtime());
var React105 = __toESM(require_react());
function getModals(children) {
  return React105.Children.toArray(children);
}
var warn10 = warnOnce("ModalRoot");
function modalTransitionReducer(state, action) {
  if (action.type === "setActive" && action.id !== state.activeModal) {
    const nextModal = action.id;
    const prevModal = state.exitingModal || state.activeModal;
    let history = state.history ? [
      ...state.history
    ] : [];
    const isBack = Boolean(nextModal && history.includes(nextModal));
    if (nextModal === null) {
      history = [];
    } else if (isBack) {
      history = history.splice(0, history.indexOf(nextModal) + 1);
    } else {
      history.push(nextModal);
    }
    return {
      activeModal: nextModal,
      // not entering yet
      enteringModal: null,
      exitingModal: prevModal,
      history,
      isBack
    };
  }
  if (action.type === "entered" && action.id === state.enteringModal) {
    return _object_spread_props(_object_spread({}, state), {
      enteringModal: null
    });
  }
  if (action.type === "exited" && action.id === state.exitingModal) {
    return _object_spread_props(_object_spread({}, state), {
      exitingModal: null
    });
  }
  if (action.type === "inited" && action.id === state.activeModal) {
    return _object_spread_props(_object_spread({}, state), {
      enteringModal: action.id
    });
  }
  return state;
}
function useModalManager(activeModal, children, onOpen = noop, onOpened = noop, onClose = noop, onClosed = noop, initModal2 = noop) {
  const modalsState = React105.useRef({}).current;
  getModals(children).forEach((Modal) => {
    const modalProps = Modal.props;
    const id = getNavId(modalProps, warn10);
    const state = id !== void 0 && modalsState[id] || {
      id: id !== null && id !== void 0 ? id : null
    };
    state.onOpen = Modal.props.onOpen;
    state.onOpened = Modal.props.onOpened;
    state.onClose = Modal.props.onClose;
    state.onClosed = Modal.props.onClosed;
    state.preventClose = Modal.props.preventClose;
    if (typeof modalProps.settlingHeight === "number") {
      state.settlingHeight = modalProps.settlingHeight;
    }
    if (state.id !== null) {
      modalsState[state.id] = state;
    }
  });
  const isMissing = activeModal && !modalsState[activeModal];
  const safeActiveModal = isMissing ? null : activeModal;
  const [transitionState, dispatchTransition] = React105.useReducer(modalTransitionReducer, {
    activeModal: safeActiveModal,
    enteringModal: null,
    exitingModal: null,
    history: safeActiveModal ? [
      safeActiveModal
    ] : [],
    isBack: false
  });
  useIsomorphicLayoutEffect(() => {
    if (isMissing) {
      warn10(`Переход невозможен - модальное окно (страница) ${activeModal} не существует`, "error");
    }
    dispatchTransition({
      type: "setActive",
      id: safeActiveModal !== null && safeActiveModal !== void 0 ? safeActiveModal : null
    });
  }, [
    activeModal
  ]);
  useIsomorphicLayoutEffect(() => {
    if (transitionState.activeModal) {
      initModal2(modalsState[transitionState.activeModal]);
      dispatchTransition({
        type: "inited",
        id: transitionState.activeModal
      });
    }
  }, [
    transitionState.activeModal
  ]);
  const isCard = (id) => {
    var _modalsState_id;
    return id != null && ((_modalsState_id = modalsState[id]) === null || _modalsState_id === void 0 ? void 0 : _modalsState_id.type) === "card";
  };
  const onEntered = React105.useCallback((id) => {
    if (id) {
      const modalState = modalsState[id];
      if (isFunction(modalState.onOpened)) {
        modalState.onOpened();
      } else if (isFunction(onOpened)) {
        onOpened(id);
      }
    }
    dispatchTransition({
      type: "entered",
      id
    });
  }, [
    modalsState,
    onOpened
  ]);
  const onExited = React105.useCallback((id) => {
    if (id) {
      const modalState = modalsState[id];
      if (isFunction(modalState.onClosed)) {
        modalState.onClosed();
      } else if (isFunction(onClosed)) {
        onClosed(id);
      }
    }
    dispatchTransition({
      type: "exited",
      id
    });
  }, [
    modalsState,
    onClosed
  ]);
  const delayEnter = Boolean(transitionState.exitingModal && (isCard(activeModal) || isCard(transitionState.exitingModal)));
  const getModalState = React105.useCallback((id) => id ? modalsState[id] : void 0, [
    modalsState
  ]);
  function onEnter() {
    const modalState = transitionState.activeModal && modalsState[transitionState.activeModal];
    if (modalState) {
      if (isFunction(modalState.onOpen)) {
        modalState.onOpen();
      } else if (isFunction(onOpen) && modalState.id) {
        onOpen(modalState.id);
      }
    }
  }
  function onExit() {
    const modalState = transitionState.activeModal && modalsState[transitionState.activeModal];
    if (modalState && !modalState.preventClose) {
      if (isFunction(modalState.onClose)) {
        modalState.onClose();
      } else if (isFunction(onClose) && modalState.id) {
        onClose(modalState.id);
      }
    }
  }
  return _object_spread_props(_object_spread({
    onEnter,
    onEntered,
    onExit,
    onExited
  }, transitionState), {
    delayEnter,
    getModalState
  });
}
function withModalManager(initModal2 = noop) {
  return function(Wrapped) {
    return function WithModalManager(props) {
      const transitionManager = useModalManager(props.activeModal, props.children, props.onOpen, props.onOpened, props.onClose, props.onClosed, initModal2);
      return (0, import_jsx_runtime87.jsx)(Wrapped, _object_spread({}, props, transitionManager));
    };
  };
}

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/ModalRoot.js
var warn11 = warnOnce("ModalRoot");
function numberInRange(number, range2) {
  if (!range2) {
    return false;
  }
  return number >= range2[0] && number <= range2[1];
}
function rangeTranslate(number) {
  return clamp2(number, 0, 98);
}
var ModalRootTouchComponent = class extends React106.Component {
  get timeout() {
    return this.props.platform === "ios" ? 400 : 320;
  }
  get document() {
    return this.props.document;
  }
  get window() {
    return this.props.window;
  }
  getModals() {
    return React106.Children.toArray(this.props.children);
  }
  componentDidMount() {
    var _this_window;
    (_this_window = this.window) === null || _this_window === void 0 ? void 0 : _this_window.addEventListener("resize", this.updateModalHeight, false);
  }
  componentWillUnmount() {
    this.toggleDocumentScrolling(true);
    this.window.removeEventListener("resize", this.updateModalHeight, false);
  }
  componentDidUpdate(prevProps) {
    if (this.props.exitingModal && this.props.exitingModal !== prevProps.exitingModal) {
      this.closeModal(this.props.exitingModal);
    }
    if (this.props.enteringModal && this.props.enteringModal !== prevProps.enteringModal) {
      const enteringState = this.props.getModalState(this.props.enteringModal);
      this.props.onEnter();
      this.waitTransitionFinish(enteringState, () => {
        if (enteringState) {
          if (enteringState.innerElement) {
            enteringState.innerElement.style.transitionDelay = "";
          }
          this.onEntered(enteringState);
        }
      });
      if (enteringState === null || enteringState === void 0 ? void 0 : enteringState.innerElement) {
        enteringState.innerElement.style.transitionDelay = this.props.delayEnter ? `${this.timeout}ms` : "";
        this.animateTranslate(enteringState, enteringState.translateY);
        this.setMaskOpacity(enteringState, 1);
      }
    }
    if (this.props.activeModal && !prevProps.activeModal) {
      this.restoreFocusTo = this.document.activeElement;
    }
    if (!this.props.activeModal && !this.props.exitingModal && this.restoreFocusTo) {
      this.restoreFocusTo.focus();
      this.restoreFocusTo = null;
    }
    this.toggleDocumentScrolling(!this.props.activeModal && !this.props.exitingModal);
  }
  /* Отключает скролл документа */
  toggleDocumentScrolling(enabled) {
    if (enabled) {
      this.document.documentElement.classList.remove("vkui--disable-overscroll-behavior");
    } else {
      this.document.documentElement.classList.add("vkui--disable-overscroll-behavior");
    }
  }
  checkPageContentHeight() {
    const modalState = this.props.getModalState(this.props.activeModal);
    if ((modalState === null || modalState === void 0 ? void 0 : modalState.type) === "page" && (modalState === null || modalState === void 0 ? void 0 : modalState.modalElement)) {
      const prevModalState = _object_spread({}, modalState);
      initPageModal(modalState);
      const currentModalState = _object_spread({}, modalState);
      let needAnimate = false;
      if (prevModalState.expandable === currentModalState.expandable) {
        if (prevModalState.translateYFrom !== currentModalState.translateYFrom) {
          needAnimate = true;
        }
      } else {
        needAnimate = true;
      }
      if (needAnimate) {
        this.animateTranslate(modalState, modalState.translateY);
      }
    }
  }
  onEntered({ id, modalElement }) {
    if (!this.props.noFocusToDialog && modalElement && !modalElement.contains(this.document.activeElement)) {
      modalElement.focus();
    }
    this.props.onEntered(id);
  }
  closeModal(id) {
    this.setState({
      touchDown: false
    });
    const prevModalState = this.props.getModalState(id);
    if (!prevModalState) {
      id && warn11(`closeActiveModal: модальное окно (страница) ${id} не существует`, "error");
      return;
    }
    if (!this.state.modalOpenedLog.length) {
      this.setState((prevState) => ({
        modalOpenedLog: [
          ...prevState.modalOpenedLog,
          id
        ]
      }));
    }
    const nextModalState = this.props.getModalState(this.props.activeModal);
    const nextIsPage = !!nextModalState && nextModalState.type === "page";
    const prevIsPage = !!prevModalState && prevModalState.type === "page";
    this.waitTransitionFinish(prevModalState, () => this.props.onExited(id));
    var _prevModalState_translateY, _nextModalState_translateYFrom, _nextModalState_translateYFrom1;
    const exitTranslate = prevIsPage && nextIsPage && ((_prevModalState_translateY = prevModalState.translateY) !== null && _prevModalState_translateY !== void 0 ? _prevModalState_translateY : 0) <= ((_nextModalState_translateYFrom = nextModalState === null || nextModalState === void 0 ? void 0 : nextModalState.translateYFrom) !== null && _nextModalState_translateYFrom !== void 0 ? _nextModalState_translateYFrom : 0) && !this.props.isBack ? ((_nextModalState_translateYFrom1 = nextModalState === null || nextModalState === void 0 ? void 0 : nextModalState.translateYFrom) !== null && _nextModalState_translateYFrom1 !== void 0 ? _nextModalState_translateYFrom1 : 0) + 10 : 100;
    this.animateTranslate(prevModalState, exitTranslate);
    if (!nextModalState) {
      this.setMaskOpacity(prevModalState, 0);
      this.setState({
        modalOpenedLog: []
      });
      prevModalState.translateY = void 0;
      prevModalState.expandable = void 0;
    } else if (nextModalState.id && !this.state.modalOpenedLog.includes(nextModalState.id)) {
      nextModalState.translateY = void 0;
      this.setState((prevState) => ({
        modalOpenedLog: [
          ...prevState.modalOpenedLog,
          nextModalState.id
        ]
      }));
    }
  }
  onPageTouchMove(event, modalState) {
    var _modalState_innerElement, _modalState_headerElement;
    const { shiftY, originalEvent } = event;
    const target = originalEvent.target;
    if (!event.isY) {
      var _this_viewportRef_current;
      if ((_this_viewportRef_current = this.viewportRef.current) === null || _this_viewportRef_current === void 0 ? void 0 : _this_viewportRef_current.contains(target)) {
        originalEvent.preventDefault();
      }
      return;
    }
    if (!((_modalState_innerElement = modalState.innerElement) === null || _modalState_innerElement === void 0 ? void 0 : _modalState_innerElement.contains(target))) {
      return originalEvent.preventDefault();
    }
    originalEvent.stopPropagation();
    const { expandable, contentScrolled, collapsed, expanded } = modalState;
    if (!this.state.touchDown) {
      var _modalState_contentElement;
      var _modalState_contentElement_scrollTop;
      modalState.touchStartContentScrollTop = (_modalState_contentElement_scrollTop = (_modalState_contentElement = modalState.contentElement) === null || _modalState_contentElement === void 0 ? void 0 : _modalState_contentElement.scrollTop) !== null && _modalState_contentElement_scrollTop !== void 0 ? _modalState_contentElement_scrollTop : 0;
      this.setState({
        touchDown: true
      });
    }
    if (contentScrolled) {
      return;
    }
    if (modalState.touchMovePositive === null) {
      modalState.touchMovePositive = shiftY > 0;
    }
    if (!modalState.expandable || collapsed || expanded && modalState.touchMovePositive && modalState.touchStartContentScrollTop === 0 || ((_modalState_headerElement = modalState.headerElement) === null || _modalState_headerElement === void 0 ? void 0 : _modalState_headerElement.contains(target))) {
      originalEvent.preventDefault();
      if (!expandable && shiftY < 0 || !this.window) {
        return;
      }
      !this.state.dragging && this.setState({
        dragging: true
      });
      const shiftYPercent = shiftY / this.window.innerHeight * 100;
      const shiftYCurrent = rubber(shiftYPercent, 72, 0.8, this.props.platform !== "ios");
      modalState.touchShiftYPercent = shiftYPercent;
      var _modalState_translateY;
      modalState.translateYCurrent = rangeTranslate(((_modalState_translateY = modalState.translateY) !== null && _modalState_translateY !== void 0 ? _modalState_translateY : 0) + shiftYCurrent);
      this.animateTranslate(modalState, modalState.translateYCurrent);
      this.setMaskOpacity(modalState);
    }
  }
  onCardTouchMove(event, modalState) {
    var _modalState_innerElement;
    const { originalEvent, shiftY } = event;
    const target = originalEvent.target;
    if ((_modalState_innerElement = modalState.innerElement) === null || _modalState_innerElement === void 0 ? void 0 : _modalState_innerElement.contains(target)) {
      if (!this.state.touchDown) {
        this.setState({
          touchDown: true,
          dragging: true
        });
      }
      const shiftYPercent = shiftY / modalState.innerElement.offsetHeight * 100;
      const shiftYCurrent = rubber(shiftYPercent, 72, 1.2, this.props.platform !== "ios");
      modalState.touchShiftYPercent = shiftYPercent;
      var _modalState_translateY;
      modalState.translateYCurrent = Math.max(0, ((_modalState_translateY = modalState.translateY) !== null && _modalState_translateY !== void 0 ? _modalState_translateY : 0) + shiftYCurrent);
      this.animateTranslate(modalState, modalState.translateYCurrent);
      this.setMaskOpacity(modalState);
    }
  }
  onPageTouchEnd(event, modalState) {
    const { startY, shiftY } = event;
    modalState.contentScrolled = false;
    modalState.touchMovePositive = null;
    let setStateCallback;
    if (this.state.dragging && this.window) {
      const shiftYEndPercent = (startY + shiftY) / this.window.innerHeight * 100;
      var _modalState_translateYCurrent;
      let translateY = (_modalState_translateYCurrent = modalState.translateYCurrent) !== null && _modalState_translateYCurrent !== void 0 ? _modalState_translateYCurrent : 0;
      var _modalState_touchShiftYPercent;
      const expectTranslateY = translateY / event.duration * 240 * 0.6 * (((_modalState_touchShiftYPercent = modalState.touchShiftYPercent) !== null && _modalState_touchShiftYPercent !== void 0 ? _modalState_touchShiftYPercent : 0) < 0 ? -1 : 1);
      translateY = rangeTranslate(translateY + expectTranslateY);
      if (modalState.settlingHeight !== 100) {
        if (numberInRange(translateY, modalState.expandedRange)) {
          var _modalState_expandedRange;
          var _modalState_expandedRange_;
          translateY = (_modalState_expandedRange_ = (_modalState_expandedRange = modalState.expandedRange) === null || _modalState_expandedRange === void 0 ? void 0 : _modalState_expandedRange[0]) !== null && _modalState_expandedRange_ !== void 0 ? _modalState_expandedRange_ : 0;
        } else if (numberInRange(translateY, modalState.collapsedRange)) {
          var _modalState_translateYFrom;
          translateY = (_modalState_translateYFrom = modalState.translateYFrom) !== null && _modalState_translateYFrom !== void 0 ? _modalState_translateYFrom : 0;
        } else if (numberInRange(translateY, modalState.hiddenRange)) {
          var _modalState_translateYFrom1;
          translateY = modalState.preventClose ? (_modalState_translateYFrom1 = modalState.translateYFrom) !== null && _modalState_translateYFrom1 !== void 0 ? _modalState_translateYFrom1 : 0 : 100;
        } else {
          var _modalState_translateYFrom2;
          translateY = (_modalState_translateYFrom2 = modalState.translateYFrom) !== null && _modalState_translateYFrom2 !== void 0 ? _modalState_translateYFrom2 : 0;
        }
      } else {
        if (numberInRange(translateY, [
          0,
          25
        ])) {
          translateY = 0;
        } else {
          var _modalState_translateYFrom3;
          translateY = modalState.preventClose ? (_modalState_translateYFrom3 = modalState.translateYFrom) !== null && _modalState_translateYFrom3 !== void 0 ? _modalState_translateYFrom3 : 0 : 100;
        }
      }
      if (translateY !== 100 && shiftYEndPercent >= 75 && !modalState.preventClose) {
        translateY = 100;
      }
      modalState.translateY = translateY;
      modalState.translateYCurrent = translateY;
      modalState.collapsed = numberInRange(translateY, modalState.collapsedRange);
      modalState.expanded = translateY === 0;
      modalState.hidden = translateY === 100;
      if (modalState.hidden) {
        this.props.onExit();
      }
      setStateCallback = () => {
        if (!modalState.hidden) {
          this.animateTranslate(modalState, modalState.translateY);
        }
        this.setMaskOpacity(modalState);
      };
    }
    this.setState({
      touchDown: false,
      dragging: false
    }, setStateCallback);
  }
  onCardTouchEnd({ duration }, modalState) {
    let setStateCallback;
    if (this.state.dragging) {
      var _modalState_translateYCurrent;
      let translateY = (_modalState_translateYCurrent = modalState.translateYCurrent) !== null && _modalState_translateYCurrent !== void 0 ? _modalState_translateYCurrent : 0;
      var _modalState_touchShiftYPercent;
      const expectTranslateY = translateY / duration * 240 * 0.6 * (((_modalState_touchShiftYPercent = modalState.touchShiftYPercent) !== null && _modalState_touchShiftYPercent !== void 0 ? _modalState_touchShiftYPercent : 0) < 0 ? -1 : 1);
      translateY = Math.max(0, translateY + expectTranslateY);
      if (translateY >= 30) {
        translateY = 100;
      } else {
        translateY = 0;
      }
      modalState.translateY = translateY;
      modalState.hidden = translateY === 100;
      if (modalState.hidden) {
        this.props.onExit();
      }
      setStateCallback = () => {
        if (!modalState.hidden) {
          this.animateTranslate(modalState, modalState.translateY);
        }
        this.setMaskOpacity(modalState);
      };
    }
    this.setState({
      touchDown: false,
      dragging: false
    }, setStateCallback);
  }
  waitTransitionFinish(modalState, eventHandler) {
    const el = modalState ? modalState.innerElement : null;
    if (el) {
      el.addEventListener("transitionend", eventHandler, {
        once: true
      });
    } else {
      setTimeout(eventHandler, this.timeout);
    }
  }
  /**
  * Анимирует сдвиг модалки
  *
  * @param {ModalsStateEntry} modalState
  * @param {number} percent Процент сдвига: 0 – полностью открыта, 100 – полностью закрыта
  */
  animateTranslate(modalState, percent) {
    const frameId = `animateTranslateFrame${modalState.id}`;
    cancelAnimationFrame(this.frameIds[frameId]);
    this.frameIds[frameId] = requestAnimationFrame(() => {
      if (!modalState.innerElement) {
        return;
      }
      modalState.innerElement.style.transform = `translate3d(0, ${percent}%, 0)`;
    });
  }
  /* Устанавливает прозрачность для полупрозрачной подложки */
  setMaskOpacity(modalState, forceOpacity = null) {
    var _this_props_history;
    if (forceOpacity === null && ((_this_props_history = this.props.history) === null || _this_props_history === void 0 ? void 0 : _this_props_history[0]) !== modalState.id) {
      return;
    }
    if (this.maskAnimationFrame) {
      cancelAnimationFrame(this.maskAnimationFrame);
    }
    this.maskAnimationFrame = requestAnimationFrame(() => {
      if (this.maskElementRef.current) {
        const { translateY = 0, translateYCurrent = 0 } = modalState;
        const opacity = forceOpacity === null ? 1 - (translateYCurrent - translateY) / (100 - translateY) || 0 : forceOpacity;
        this.maskElementRef.current.style.opacity = clamp2(opacity, 0, 100).toString();
        this.maskElementRef.current.style.transitionDelay = opacity && this.props.delayEnter ? `${this.timeout}ms` : "";
      }
    });
  }
  render() {
    var _this_props_configProvider;
    const { activeModal, exitingModal, enteringModal, modalOverlayTestId } = this.props;
    const { touchDown, dragging } = this.state;
    if (!activeModal && !exitingModal) {
      return null;
    }
    return (0, import_jsx_runtime88.jsx)(TouchContext_default.Provider, {
      value: true,
      children: (0, import_jsx_runtime88.jsx)(ModalRootContext.Provider, {
        value: this.modalRootContext,
        children: (0, import_jsx_runtime88.jsxs)(Touch, {
          className: clsx("vkuiModalRoot", ((_this_props_configProvider = this.props.configProvider) === null || _this_props_configProvider === void 0 ? void 0 : _this_props_configProvider.hasCustomPanelHeaderAfter) && "vkuiModalRoot--hasCustomPanelHeaderAfterSlot", touchDown && clsx("vkuiModalRoot--touched", "vkuiInternalModalRoot--touched"), !!(enteringModal || exitingModal) && clsx("vkuiModalRoot--switching", "vkuiInternalModalRoot--switching")),
          onMove: this.onTouchMove,
          onEnd: this.onTouchEnd,
          onScroll: this.onScroll,
          children: [
            (0, import_jsx_runtime88.jsx)("div", {
              "data-testid": modalOverlayTestId,
              className: "vkuiModalRoot__mask",
              onClick: this.props.onExit,
              ref: this.maskElementRef
            }),
            (0, import_jsx_runtime88.jsx)("div", {
              className: "vkuiModalRoot__viewport",
              ref: this.viewportRef,
              children: this.getModals().map((Modal) => {
                const modalId = getNavId(Modal.props, warn11);
                const _modalState = this.props.getModalState(modalId);
                if (modalId !== activeModal && modalId !== exitingModal || !_modalState) {
                  return null;
                }
                const modalState = _object_spread({}, _modalState);
                const isPage = modalState.type === "page";
                const key = `modal-${modalId}`;
                return (0, import_jsx_runtime88.jsx)(FocusTrap, {
                  onClose: this.props.onExit,
                  timeout: this.timeout,
                  className: clsx("vkuiModalRoot__modal", dragging && "vkuiInternalModalRoot__modal--dragging", isPage && modalState.expandable && "vkuiInternalModalRoot__modal--expandable", isPage && modalState.collapsed && "vkuiInternalModalRoot__modal--collapsed"),
                  autoFocus: false,
                  restoreFocus: false,
                  children: Modal
                }, key);
              })
            })
          ]
        })
      })
    });
  }
  constructor(props) {
    super(props), _define_property(this, "maskElementRef", void 0), _define_property(this, "viewportRef", React106.createRef()), _define_property(this, "maskAnimationFrame", void 0), _define_property(this, "modalRootContext", void 0), _define_property(this, "frameIds", void 0), _define_property(this, "restoreFocusTo", void 0), _define_property(this, "updateModalHeight", () => {
      const modalState = this.props.getModalState(this.props.activeModal);
      if (modalState && modalState.type === "page") {
        if (this.props.enteringModal) {
          this.waitTransitionFinish(modalState, () => {
            requestAnimationFrame(() => this.checkPageContentHeight());
          });
        } else {
          requestAnimationFrame(() => this.checkPageContentHeight());
        }
      }
    }), _define_property(this, "onTouchMove", (e) => {
      if (this.props.exitingModal) {
        return;
      }
      const modalState = this.props.getModalState(this.props.activeModal);
      if (!modalState) {
        return;
      }
      if (modalState.type === "page") {
        return this.onPageTouchMove(e, modalState);
      }
      if (modalState.type === "card") {
        return this.onCardTouchMove(e, modalState);
      }
    }), _define_property(this, "onTouchEnd", (e) => {
      const modalState = this.props.getModalState(this.props.activeModal);
      if ((modalState === null || modalState === void 0 ? void 0 : modalState.type) === "page") {
        return this.onPageTouchEnd(e, modalState);
      }
      if ((modalState === null || modalState === void 0 ? void 0 : modalState.type) === "card") {
        return this.onCardTouchEnd(e, modalState);
      }
    }), _define_property(this, "onScroll", (e) => {
      var _modalState_contentElement;
      const activeModal = this.props.activeModal;
      const target = e.target;
      if (!activeModal) {
        return;
      }
      const modalState = this.props.getModalState(activeModal);
      if ((modalState === null || modalState === void 0 ? void 0 : modalState.type) === "page" && (modalState === null || modalState === void 0 ? void 0 : (_modalState_contentElement = modalState.contentElement) === null || _modalState_contentElement === void 0 ? void 0 : _modalState_contentElement.contains(target))) {
        modalState.contentScrolled = true;
        if (modalState.contentScrollStopTimeout) {
          clearTimeout(modalState.contentScrollStopTimeout);
        }
        modalState.contentScrollStopTimeout = setTimeout(() => {
          if (modalState.contentScrolled) {
            modalState.contentScrolled = false;
          }
        }, 250);
      }
    });
    this.state = {
      touchDown: false,
      dragging: false,
      modalOpenedLog: []
    };
    this.maskElementRef = React106.createRef();
    this.modalRootContext = {
      updateModalHeight: this.updateModalHeight,
      registerModal: (_param) => {
        var { id } = _param, data = _object_without_properties(_param, [
          "id"
        ]);
        var _this_props_getModalState;
        return Object.assign((_this_props_getModalState = this.props.getModalState(id)) !== null && _this_props_getModalState !== void 0 ? _this_props_getModalState : {}, data);
      },
      onClose: () => this.props.onExit(),
      isInsideModal: true
    };
    this.frameIds = {};
  }
};
var ModalRootTouch = withContext(withPlatform(withDOM(withModalManager(initModal)(ModalRootTouchComponent))), ConfigProviderContext, "configProvider");
function initModal(modalState) {
  switch (modalState.type) {
    case "page":
      modalState.settlingHeight = modalState.settlingHeight || MODAL_PAGE_DEFAULT_PERCENT_HEIGHT;
      return initPageModal(modalState);
    case "card":
      return initCardModal(modalState);
    default:
      warn11(`initActiveModal: modalState.type="${modalState.type}" не поддерживается`, "error");
  }
}
function initPageModal(modalState) {
  const { contentElement, bottomInset } = modalState;
  const contentElementHeight = calculateModalContentHeight(contentElement === null || contentElement === void 0 ? void 0 : contentElement.firstElementChild, modalState.expandable);
  const bottomInsetHeight = (bottomInset === null || bottomInset === void 0 ? void 0 : bottomInset.offsetHeight) || 0;
  const contentHeight = contentElementHeight + bottomInsetHeight;
  let prevTranslateY = modalState.translateY;
  let prevExpandable = modalState.expandable;
  var _contentElement_clientHeight;
  modalState.expandable = contentHeight > ((_contentElement_clientHeight = contentElement === null || contentElement === void 0 ? void 0 : contentElement.clientHeight) !== null && _contentElement_clientHeight !== void 0 ? _contentElement_clientHeight : 0) || modalState.settlingHeight === 100;
  let collapsed = false;
  let expanded = false;
  let translateYFrom;
  let translateY;
  let expandedRange;
  let collapsedRange;
  let hiddenRange;
  const hasCollapsedState = Boolean(modalState.expandable && modalState.settlingHeight !== 100);
  if (modalState.expandable) {
    var _modalState_settlingHeight;
    translateYFrom = 100 - ((_modalState_settlingHeight = modalState.settlingHeight) !== null && _modalState_settlingHeight !== void 0 ? _modalState_settlingHeight : 0);
    const shiftHalf = translateYFrom / 2;
    const visiblePart = 100 - translateYFrom;
    expandedRange = [
      0,
      shiftHalf
    ];
    collapsedRange = hasCollapsedState ? [
      shiftHalf,
      translateYFrom + visiblePart / 4
    ] : void 0;
    hiddenRange = [
      translateYFrom + visiblePart / 4,
      100
    ];
    collapsed = hasCollapsedState && translateYFrom > 0;
    expanded = translateYFrom <= 0;
    translateY = translateYFrom;
  } else {
    var _modalState_headerElement, _modalState_innerElement_parentElement, _modalState_innerElement;
    var _modalState_headerElement_offsetHeight;
    const headerHeight = (_modalState_headerElement_offsetHeight = (_modalState_headerElement = modalState.headerElement) === null || _modalState_headerElement === void 0 ? void 0 : _modalState_headerElement.offsetHeight) !== null && _modalState_headerElement_offsetHeight !== void 0 ? _modalState_headerElement_offsetHeight : 0;
    const height = contentHeight + headerHeight;
    var _modalState_innerElement_parentElement_offsetHeight;
    translateYFrom = 100 - height / ((_modalState_innerElement_parentElement_offsetHeight = (_modalState_innerElement = modalState.innerElement) === null || _modalState_innerElement === void 0 ? void 0 : (_modalState_innerElement_parentElement = _modalState_innerElement.parentElement) === null || _modalState_innerElement_parentElement === void 0 ? void 0 : _modalState_innerElement_parentElement.offsetHeight) !== null && _modalState_innerElement_parentElement_offsetHeight !== void 0 ? _modalState_innerElement_parentElement_offsetHeight : 0) * 100;
    translateY = translateYFrom;
    expandedRange = [
      translateY,
      translateY + 25
    ];
    collapsedRange = void 0;
    hiddenRange = [
      translateY + 25,
      translateY + 100
    ];
  }
  const shouldExpand = prevExpandable && modalState.expandable;
  if (shouldExpand && translateY > (prevTranslateY !== null && prevTranslateY !== void 0 ? prevTranslateY : 100) || modalState.settlingHeight === 100) {
    translateY = 0;
  }
  if (translateY === 0) {
    expanded = true;
    collapsed = false;
  }
  modalState.expandedRange = expandedRange;
  modalState.collapsedRange = collapsedRange;
  modalState.hiddenRange = hiddenRange;
  modalState.translateY = translateY;
  modalState.translateYFrom = translateYFrom;
  modalState.collapsed = collapsed;
  modalState.expanded = expanded;
}
function initCardModal(modalState) {
  modalState.translateY = 0;
}
function calculateModalContentHeight(element, isExpandable) {
  if (!isExpandable) {
    return element.scrollHeight;
  }
  const currentHeightStyle = element.style.height;
  element.style.height = "auto";
  const elementHeight = element.scrollHeight;
  element.style.height = currentHeightStyle;
  return elementHeight;
}

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/ModalRootDesktop.js
var import_jsx_runtime89 = __toESM(require_jsx_runtime());
var React108 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useWaitTransitionFinish.js
var React107 = __toESM(require_react());
var useWaitTransitionFinish = () => {
  const timeoutRef = React107.useRef(null);
  const { document: document2 } = useDOM();
  const detach = React107.useRef(noop);
  const remove = React107.useCallback(() => {
    detach.current();
    detach.current = noop;
  }, []);
  const waitTransitionFinish = React107.useCallback((element, eventHandler, durationFallback) => {
    if (element) {
      if (!(document2 === null || document2 === void 0 ? void 0 : document2.hidden)) {
        remove();
        element.addEventListener("transitionend", eventHandler);
        detach.current = () => {
          element.removeEventListener("transitionend", eventHandler);
        };
      } else {
        if (timeoutRef === null || timeoutRef === void 0 ? void 0 : timeoutRef.current) {
          clearTimeout(timeoutRef.current);
        }
        timeoutRef.current = setTimeout(eventHandler, durationFallback);
      }
    }
  }, [
    document2,
    remove,
    timeoutRef
  ]);
  return waitTransitionFinish;
};

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/ModalRootDesktop.js
var warn12 = warnOnce("ModalRoot");
var ModalRootDesktop = ({ activeModal: activeModalProp, children, noFocusToDialog = false, onOpen, onOpened, onClose, onClosed, modalOverlayTestId }) => {
  const maskElementRef = React108.useRef(null);
  const maskAnimationFrame = React108.useRef(void 0);
  const restoreFocusTo = React108.useRef(void 0);
  const { document: document2 } = useDOM();
  const { hasCustomPanelHeaderAfter, platform: platform3 } = useConfigProvider();
  const { activeModal, exitingModal, onExit, getModalState, enteringModal, onEnter, onEntered: onEnteredProp, onExited, history, delayEnter } = useModalManager(activeModalProp, children, onOpen, onOpened, onClose, onClosed, noop);
  const waitTransitionFinish = useWaitTransitionFinish();
  const prevProps = usePrevious({
    exitingModal,
    enteringModal,
    activeModal
  });
  const modalRootContext = useObjectMemo({
    updateModalHeight: () => void 0,
    registerModal: (_param) => {
      var { id } = _param, data = _object_without_properties(_param, [
        "id"
      ]);
      var _getModalState;
      return Object.assign((_getModalState = getModalState(id)) !== null && _getModalState !== void 0 ? _getModalState : {}, data);
    },
    onClose: onExit,
    isInsideModal: true
  });
  const timeout = platform3 === "ios" ? 400 : 320;
  const modals = React108.Children.toArray(children);
  const animateModalOpacity = (modalState, display) => {
    if (modalState === null || modalState === void 0 ? void 0 : modalState.innerElement) {
      modalState.innerElement.style.transition = "";
      modalState.innerElement.style.transitionDelay = display && delayEnter ? `${timeout}ms` : "";
      modalState.innerElement.style.opacity = display ? "1" : "0";
    }
  };
  const setMaskOpacity = (modalState, forceOpacity = null) => {
    if (forceOpacity === null && (history === null || history === void 0 ? void 0 : history[0]) !== modalState.id) {
      return;
    }
    if (maskAnimationFrame.current) {
      cancelAnimationFrame(maskAnimationFrame.current);
    }
    maskAnimationFrame.current = requestAnimationFrame(() => {
      if (maskElementRef.current) {
        const { translateY = 0, translateYCurrent = 0 } = modalState;
        const opacity = forceOpacity === null ? 1 - (translateYCurrent - translateY) / (100 - translateY) || 0 : forceOpacity;
        maskElementRef.current.style.opacity = clamp2(opacity, 0, 100).toString();
      }
    });
  };
  const onEntered = ({ id, modalElement }) => {
    if (!noFocusToDialog && modalElement && !modalElement.contains(document2.activeElement)) {
      modalElement.focus();
    }
    onEnteredProp(id);
  };
  const openModal = () => {
    if (!enteringModal || !prevProps) {
      return;
    }
    const enteringState = getModalState(enteringModal);
    onEnter();
    if (!prevProps.exitingModal) {
      requestAnimationFrame(() => {
        if (enteringModal === enteringModal && enteringState) {
          waitTransitionFinish(enteringState.innerElement, () => onEntered(enteringState), timeout);
          animateModalOpacity(enteringState, true);
          setMaskOpacity(enteringState, 1);
        }
      });
      return;
    }
    requestAnimationFrame(() => {
      if (enteringState === null || enteringState === void 0 ? void 0 : enteringState.innerElement) {
        enteringState.innerElement.style.transition = "none";
        enteringState.innerElement.style.opacity = "1";
        setMaskOpacity(enteringState, 1);
      }
    });
    if (enteringState) {
      onEntered(enteringState);
    }
  };
  const closeModal = (id) => {
    const prevModalState = getModalState(id);
    if (!prevModalState) {
      return;
    }
    if (!activeModal) {
      requestAnimationFrame(() => {
        waitTransitionFinish(prevModalState === null || prevModalState === void 0 ? void 0 : prevModalState.innerElement, (event) => {
          if (event && event.target === (prevModalState === null || prevModalState === void 0 ? void 0 : prevModalState.innerElement)) {
            onExited(id);
          } else if (!event) {
            onExited(id);
          }
        }, timeout);
        animateModalOpacity(prevModalState, false);
        setMaskOpacity(prevModalState, 0);
      });
      return;
    }
    onExited(id);
  };
  React108.useEffect(() => {
    if (!prevProps) {
      return;
    }
    if (exitingModal && exitingModal !== prevProps.exitingModal) {
      closeModal(exitingModal);
    }
    if (enteringModal && enteringModal !== prevProps.enteringModal) {
      openModal();
    }
    if (activeModal && !prevProps.activeModal) {
      var _document_activeElement;
      restoreFocusTo.current = (_document_activeElement = document2 === null || document2 === void 0 ? void 0 : document2.activeElement) !== null && _document_activeElement !== void 0 ? _document_activeElement : void 0;
    }
    if (!activeModal && !exitingModal && restoreFocusTo.current) {
      restoreFocusTo.current.focus();
      restoreFocusTo.current = void 0;
    }
  });
  if (!activeModal && !exitingModal) {
    return null;
  }
  return (0, import_jsx_runtime89.jsx)(ModalRootContext.Provider, {
    value: modalRootContext,
    children: (0, import_jsx_runtime89.jsxs)("div", {
      className: clsx("vkuiModalRoot", hasCustomPanelHeaderAfter && "vkuiModalRoot--hasCustomPanelHeaderAfterSlot", "vkuiModalRoot--desktop"),
      children: [
        (0, import_jsx_runtime89.jsx)("div", {
          "data-testid": modalOverlayTestId,
          className: "vkuiModalRoot__mask",
          ref: maskElementRef,
          onClick: onExit
        }),
        (0, import_jsx_runtime89.jsx)("div", {
          className: "vkuiModalRoot__viewport",
          children: modals.map((Modal) => {
            const modalId = getNavId(Modal.props, warn12);
            if (modalId !== activeModal && modalId !== exitingModal) {
              return null;
            }
            const key = `modal-${modalId}`;
            return (0, import_jsx_runtime89.jsx)(FocusTrap, {
              autoFocus: false,
              restoreFocus: false,
              onClose: onExit,
              timeout,
              className: "vkuiModalRoot__modal",
              children: Modal
            }, key);
          })
        })
      ]
    })
  });
};

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/ModalRootAdaptive.js
var ModalRoot = (props) => {
  const { isDesktop } = useAdaptivityWithJSMediaQueries();
  useScrollLock(!!props.activeModal);
  const RootComponent2 = isDesktop ? ModalRootDesktop : ModalRootTouch;
  return (0, import_jsx_runtime90.jsx)(RootComponent2, _object_spread({}, props));
};

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/withModalRootContext.js
var import_jsx_runtime91 = __toESM(require_jsx_runtime());
var React111 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/useModalRootContext.js
var React110 = __toESM(require_react());
var useModalRootContext = () => React110.useContext(ModalRootContext);

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/withModalRootContext.js
function withModalRootContext(Component3) {
  function WithModalRootContext(props) {
    const { updateModalHeight } = useModalRootContext();
    return (0, import_jsx_runtime91.jsx)(Component3, _object_spread_props(_object_spread({}, props), {
      updateModalHeight
    }));
  }
  return WithModalRootContext;
}

// node_modules/@vkontakte/vkui/dist/components/ModalPage/ModalPage.js
var import_jsx_runtime92 = __toESM(require_jsx_runtime());
var React114 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useOrientationChange.js
var React112 = __toESM(require_react());
function getOrientation(window2) {
  var _window_screen_orientation, _window_screen;
  if (!window2) {
    return "portrait";
  }
  var _window_screen_orientation_angle;
  const angle = Math.abs((_window_screen_orientation_angle = (_window_screen = window2.screen) === null || _window_screen === void 0 ? void 0 : (_window_screen_orientation = _window_screen.orientation) === null || _window_screen_orientation === void 0 ? void 0 : _window_screen_orientation.angle) !== null && _window_screen_orientation_angle !== void 0 ? _window_screen_orientation_angle : Number(window2.orientation));
  return angle === 90 ? "landscape" : "portrait";
}
function useOrientationChange() {
  const { window: window2 } = useDOM();
  const [orientation, setOrientation] = React112.useState(() => getOrientation(window2));
  useGlobalEventListener(window2, "orientationchange", () => setOrientation(getOrientation(window2)));
  return orientation;
}

// node_modules/@vkontakte/vkui/dist/components/ModalPage/ModalPageContext.js
var React113 = __toESM(require_react());
var ModalPageContext = React113.createContext({});

// node_modules/@vkontakte/vkui/dist/components/ModalPage/ModalPage.js
var sizeClassName = {
  s: "vkuiModalPage--size-s",
  m: "vkuiModalPage--size-m",
  l: "vkuiModalPage--size-l"
};
var warn13 = warnOnce("ModalPage");
var ModalPage = (_param) => {
  var { children, header, size: sizeProp = "s", onOpen, onOpened, onClose, onClosed, settlingHeight, dynamicContentHeight, getModalContentRef, nav, id: idProp, hideCloseButton = false, height, modalContentTestId, modalDismissButtonTestId, getRootRef, preventClose } = _param, restProps = _object_without_properties(_param, [
    "children",
    "header",
    "size",
    "onOpen",
    "onOpened",
    "onClose",
    "onClosed",
    "settlingHeight",
    "dynamicContentHeight",
    "getModalContentRef",
    "nav",
    "id",
    "hideCloseButton",
    "height",
    "modalContentTestId",
    "modalDismissButtonTestId",
    "getRootRef",
    "preventClose"
  ]);
  const generatingId = React114.useId();
  const id = idProp || generatingId;
  const { updateModalHeight } = React114.useContext(ModalRootContext);
  const platform3 = usePlatform();
  const orientation = useOrientationChange();
  const { sizeX, isDesktop } = useAdaptivityWithJSMediaQueries();
  React114.useEffect(() => {
    if (dynamicContentHeight) {
      updateModalHeight();
    }
  }, [
    children,
    dynamicContentHeight,
    orientation,
    updateModalHeight
  ]);
  const isCloseButtonShown = !hideCloseButton && isDesktop;
  const size4 = isDesktop ? sizeProp : "s";
  const modalContext = React114.useContext(ModalRootContext);
  const { refs } = useModalRegistry(getNavId({
    nav,
    id
  }, warn13), "page");
  const rootRef = useExternRef(getRootRef, refs.modalElement);
  const contextValue = React114.useMemo(() => ({
    labelId: `${id}-label`
  }), [
    id
  ]);
  return (0, import_jsx_runtime92.jsx)(ModalPageContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime92.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
      getRootRef: rootRef,
      tabIndex: -1,
      role: "dialog",
      "aria-modal": "true",
      "aria-labelledby": contextValue.labelId,
      id,
      baseClassName: clsx("vkuiModalPage", platform3 === "ios" && "vkuiModalPage--ios", isDesktop && "vkuiModalPage--desktop", sizeX === "regular" && "vkuiInternalModalPage--sizeX-regular", typeof size4 === "string" && sizeClassName[size4]),
      children: (0, import_jsx_runtime92.jsx)("div", {
        className: "vkuiModalPage__in-wrap",
        style: {
          maxWidth: typeof size4 === "number" ? size4 : void 0,
          height
        },
        ref: refs.innerElement,
        children: (0, import_jsx_runtime92.jsxs)("div", {
          className: "vkuiModalPage__in",
          children: [
            (0, import_jsx_runtime92.jsx)("div", {
              className: "vkuiModalPage__header",
              ref: refs.headerElement,
              children: header
            }),
            (0, import_jsx_runtime92.jsxs)("div", {
              className: "vkuiModalPage__content-wrap",
              children: [
                (0, import_jsx_runtime92.jsx)("div", _object_spread_props(_object_spread({
                  className: "vkuiModalPage__content",
                  ref: multiRef(refs.contentElement, getModalContentRef)
                }, modalContentTestId && {
                  "data-testid": modalContentTestId
                }), {
                  children: (0, import_jsx_runtime92.jsx)("div", {
                    className: "vkuiModalPage__content-in",
                    children
                  })
                })),
                (0, import_jsx_runtime92.jsx)("div", {
                  ref: refs.bottomInset,
                  className: "vkuiModalPage__bottom-inset"
                })
              ]
            }),
            isCloseButtonShown && (0, import_jsx_runtime92.jsx)(ModalDismissButton, {
              "data-testid": modalDismissButtonTestId,
              onClick: onClose || modalContext.onClose
            })
          ]
        })
      })
    }))
  });
};

// node_modules/@vkontakte/vkui/dist/components/ModalPageHeader/ModalPageHeader.js
var import_jsx_runtime93 = __toESM(require_jsx_runtime());
var React115 = __toESM(require_react());
var ModalPageHeader = (_param) => {
  var { children, noSeparator = false, getRootRef, className, typographyProps } = _param, restProps = _object_without_properties(_param, [
    "children",
    "noSeparator",
    "getRootRef",
    "className",
    "typographyProps"
  ]);
  const platform3 = usePlatform();
  const { isDesktop, sizeX } = useAdaptivityWithJSMediaQueries();
  const { labelId } = React115.useContext(ModalPageContext);
  return (0, import_jsx_runtime93.jsxs)(import_jsx_runtime93.Fragment, {
    children: [
      (0, import_jsx_runtime93.jsx)("div", {
        className: clsx("vkuiModalPageHeader", platform3 !== "vkcom" && "vkuiModalPageHeader--withGaps", isDesktop && "vkuiModalPageHeader--desktop"),
        ref: getRootRef,
        children: (0, import_jsx_runtime93.jsx)(PanelHeader, _object_spread_props(_object_spread({
          className: clsx("vkuiInternalModalPageHeader__in", className),
          typographyProps: _object_spread({
            Component: "h2",
            id: labelId
          }, typographyProps)
        }, restProps), {
          fixed: false,
          delimiter: "none",
          transparent: true,
          children
        }))
      }),
      !noSeparator && (0, import_jsx_runtime93.jsx)(Separator, {
        wide: sizeX === "regular"
      })
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/ModalCard/ModalCard.js
var import_jsx_runtime96 = __toESM(require_jsx_runtime());
var React119 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ModalCardBase/ModalCardBase.js
var import_jsx_runtime95 = __toESM(require_jsx_runtime());
var React118 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useKeyboard.js
var React116 = __toESM(require_react());
var eventOptions = {
  passive: true,
  capture: false
};
function useKeyboard() {
  var _document_activeElement;
  const { document: document2 } = useDOM();
  const [isOpened, setIsOpened] = React116.useState(false);
  const onFocus = React116.useCallback((event) => {
    var _document_activeElement2, _document_activeElement1;
    const isOpened2 = (event === true || event.type === "focusin") && ((document2 === null || document2 === void 0 ? void 0 : (_document_activeElement2 = document2.activeElement) === null || _document_activeElement2 === void 0 ? void 0 : _document_activeElement2.tagName) === "INPUT" || (document2 === null || document2 === void 0 ? void 0 : (_document_activeElement1 = document2.activeElement) === null || _document_activeElement1 === void 0 ? void 0 : _document_activeElement1.tagName) === "TEXTAREA");
    setIsOpened(isOpened2);
  }, [
    document2 === null || document2 === void 0 ? void 0 : (_document_activeElement = document2.activeElement) === null || _document_activeElement === void 0 ? void 0 : _document_activeElement.tagName
  ]);
  React116.useEffect(() => {
    onFocus(true);
  }, [
    onFocus
  ]);
  useGlobalEventListener(document2, "focusout", onFocus, eventOptions);
  useGlobalEventListener(document2, "focusin", onFocus, eventOptions);
  return {
    isOpened
  };
}

// node_modules/@vkontakte/vkui/dist/components/ModalCardBase/ModalCardBaseCloseButton.js
var import_jsx_runtime94 = __toESM(require_jsx_runtime());
var React117 = __toESM(require_react());
function ModalCardBaseCloseButton({ children = "Закрыть", testId, mode, onClose }) {
  const platform3 = usePlatform();
  const { isDesktop } = useAdaptivityWithJSMediaQueries();
  if (isDesktop && mode === "outside") {
    return (0, import_jsx_runtime94.jsx)(ModalDismissButton, {
      "data-testid": testId,
      onClick: onClose,
      children
    });
  }
  if (mode === "inside" || platform3 === "ios" && !isDesktop) {
    return (0, import_jsx_runtime94.jsxs)(Tappable, {
      className: "vkuiModalCardBase__dismiss",
      onClick: onClose,
      hoverMode: "opacity",
      activeMode: "opacity",
      "data-testid": testId,
      children: [
        (0, import_jsx_runtime94.jsx)(VisuallyHidden, {
          children
        }),
        platform3 === "ios" ? (0, import_jsx_runtime94.jsx)(Icon24Dismiss, {}) : (0, import_jsx_runtime94.jsx)(Icon20Cancel, {})
      ]
    });
  }
  return null;
}

// node_modules/@vkontakte/vkui/dist/components/ModalCardBase/ModalCardBase.js
var ModalCardBase = (_param) => {
  var { icon, header, headerComponent = "span", subheader, subheaderComponent = "span", children, actions, onClose, dismissLabel = "Скрыть", style, size: sizeProp, modalDismissButtonTestId, dismissButtonMode = "outside", preventClose } = _param, restProps = _object_without_properties(_param, [
    "icon",
    "header",
    "headerComponent",
    "subheader",
    "subheaderComponent",
    "children",
    "actions",
    "onClose",
    "dismissLabel",
    "style",
    "size",
    "modalDismissButtonTestId",
    "dismissButtonMode",
    "preventClose"
  ]);
  const platform3 = usePlatform();
  const { isDesktop } = useAdaptivityWithJSMediaQueries();
  const isSoftwareKeyboardOpened = useKeyboard().isOpened;
  const size4 = isDesktop ? sizeProp : void 0;
  const withSafeZone = !icon && (dismissButtonMode === "inside" || platform3 === "ios" && !isDesktop && dismissButtonMode !== "none");
  const hasHeader = hasReactNode(header);
  const hasSubheader = hasReactNode(subheader);
  return (0, import_jsx_runtime95.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiInternalModalCardBase", platform3 === "ios" && "vkuiModalCardBase--ios", isDesktop && "vkuiModalCardBase--desktop", withSafeZone && "vkuiModalCardBase--withSafeZone"),
    style: _object_spread_props(_object_spread({}, style), {
      maxWidth: size4
    }),
    children: (0, import_jsx_runtime95.jsxs)("div", {
      className: clsx("vkuiModalCardBase__container", isSoftwareKeyboardOpened && "vkuiModalCardBase__container--softwareKeyboardOpened"),
      children: [
        hasReactNode(icon) && (0, import_jsx_runtime95.jsx)("div", {
          className: "vkuiModalCardBase__icon",
          children: icon
        }),
        hasReactNode(header) && (0, import_jsx_runtime95.jsx)(Title, {
          level: "2",
          weight: "2",
          className: "vkuiModalCardBase__header",
          Component: headerComponent,
          children: header
        }),
        hasHeader && hasSubheader && (0, import_jsx_runtime95.jsx)(Spacing, {
          size: 8
        }),
        hasSubheader && (0, import_jsx_runtime95.jsx)(AdaptivityContext.Provider, {
          value: {
            sizeY: "regular"
          },
          children: (0, import_jsx_runtime95.jsx)(Subhead, {
            className: "vkuiModalCardBase__subheader",
            Component: subheaderComponent,
            children: subheader
          })
        }),
        children,
        hasReactNode(actions) && (0, import_jsx_runtime95.jsx)("div", {
          className: "vkuiModalCardBase__actions",
          children: actions
        }),
        dismissButtonMode !== "none" && (0, import_jsx_runtime95.jsx)(ModalCardBaseCloseButton, {
          testId: modalDismissButtonTestId,
          onClose,
          mode: dismissButtonMode,
          children: dismissLabel
        })
      ]
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ModalCard/ModalCard.js
var platformClassNames4 = {
  ios: "vkuiModalCard--ios",
  android: "vkuiModalCard--android",
  vkcom: "vkuiModalCard--vkcom"
};
var warn14 = warnOnce("ModalCard");
var ModalCard = (_param) => {
  var { icon, header, headerComponent, subheader, subheaderComponent, children, actions, onClose, nav, id, size: size4, modalDismissButtonTestId, getRootRef, dismissButtonMode, dismissLabel } = _param, restProps = _object_without_properties(_param, [
    "icon",
    "header",
    "headerComponent",
    "subheader",
    "subheaderComponent",
    "children",
    "actions",
    "onClose",
    "nav",
    "id",
    "size",
    "modalDismissButtonTestId",
    "getRootRef",
    "dismissButtonMode",
    "dismissLabel"
  ]);
  const { isDesktop } = useAdaptivityWithJSMediaQueries();
  const platform3 = usePlatform();
  const modalContext = React119.useContext(ModalRootContext);
  const { refs } = useModalRegistry(getNavId({
    nav,
    id
  }, warn14), "card");
  const rootRef = useExternRef(getRootRef, refs.modalElement);
  const contextValue = React119.useMemo(() => ({
    labelId: `${id}-label`
  }), [
    id
  ]);
  return (0, import_jsx_runtime96.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    getRootRef: rootRef,
    tabIndex: -1,
    role: "dialog",
    "aria-modal": "true",
    "aria-labelledby": contextValue.labelId,
    id,
    baseClassName: clsx("vkuiModalCard", platformClassNames4.hasOwnProperty(platform3) ? platformClassNames4[platform3] : platformClassNames4.android, isDesktop && "vkuiModalCard--desktop"),
    children: (0, import_jsx_runtime96.jsx)(ModalCardBase, {
      className: "vkuiModalCard__in",
      getRootRef: refs.innerElement,
      icon,
      header,
      headerComponent,
      subheader,
      subheaderComponent,
      actions,
      onClose: onClose || modalContext.onClose,
      size: size4,
      modalDismissButtonTestId,
      dismissButtonMode,
      dismissLabel,
      children
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Badge/Badge.js
var import_jsx_runtime97 = __toESM(require_jsx_runtime());
var stylesMode4 = {
  new: "vkuiBadge--mode-new",
  prominent: "vkuiBadge--mode-prominent"
};
var Badge = (_param) => {
  var { mode = "new", children } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "children"
  ]);
  return (0, import_jsx_runtime97.jsx)(RootComponent, _object_spread_props(_object_spread({
    Component: "span",
    baseClassName: clsx("vkuiBadge", "vkuiInternalBadge", stylesMode4[mode])
  }, restProps), {
    children: children && (0, import_jsx_runtime97.jsx)(VisuallyHidden, {
      children
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ContentBadge/ContentBadge.js
var import_jsx_runtime99 = __toESM(require_jsx_runtime());
var React122 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ContentBadge/ContentBadgeContext.js
var React120 = __toESM(require_react());
var ContentBadgeContext = React120.createContext({
  isSingleChild: false,
  size: "m"
});

// node_modules/@vkontakte/vkui/dist/components/ContentBadge/ContentBadgeSlotIcon.js
var import_jsx_runtime98 = __toESM(require_jsx_runtime());
var React121 = __toESM(require_react());
var iconsClassNames = {
  m: null,
  l: "vkuiContentBadge__icon-slot--size-l"
};
var singleIconClassNames = {
  m: "vkuiContentBadge__singleIcon-slot--size-m",
  l: "vkuiContentBadge__singleIcon-slot--size-l"
};
var ContentBadgeSlotIcon = (_param) => {
  var { className, getRootRef, children } = _param, restProps = _object_without_properties(_param, [
    "className",
    "getRootRef",
    "children"
  ]);
  const { size: size4, isSingleChild } = React121.useContext(ContentBadgeContext);
  if (size4 === "s") {
    return null;
  }
  return (0, import_jsx_runtime98.jsx)("div", _object_spread_props(_object_spread({
    ref: getRootRef,
    className: clsx(className, isSingleChild ? singleIconClassNames[size4] : iconsClassNames[size4])
  }, restProps), {
    children
  }));
};
ContentBadgeSlotIcon.displayName = "ContentBadgeSlotIcon";

// node_modules/@vkontakte/vkui/dist/components/ContentBadge/ContentBadge.js
var appearanceClassNames = {
  "accent": {
    primary: "vkuiContentBadge--primary-accent",
    secondary: "vkuiContentBadge--secondary-accent",
    outline: "vkuiContentBadge--outline-accent"
  },
  "neutral": {
    primary: "vkuiContentBadge--primary-neutral",
    secondary: "vkuiContentBadge--secondary-neutral",
    outline: "vkuiContentBadge--outline-neutral"
  },
  "accent-green": {
    primary: "vkuiContentBadge--primary-accent-green",
    secondary: "vkuiContentBadge--secondary-accent-green",
    outline: "vkuiContentBadge--outline-accent-green"
  },
  "accent-red": {
    primary: "vkuiContentBadge--primary-accent-red",
    secondary: "vkuiContentBadge--secondary-accent-red",
    outline: "vkuiContentBadge--outline-accent-red"
  },
  "overlay": {
    primary: "vkuiContentBadge--primary-overlay",
    secondary: "vkuiContentBadge--secondary-overlay",
    outline: "vkuiContentBadge--outline-overlay"
  }
};
var sizeClassNames = {
  s: "vkuiContentBadge--size-s",
  m: "vkuiContentBadge--size-m",
  l: "vkuiContentBadge--size-l"
};
var ContentBadge = (_param) => {
  var { appearance = "accent", mode = "primary", capsule, size: size4 = "m", weight = "2", className, children } = _param, restProps = _object_without_properties(_param, [
    "appearance",
    "mode",
    "capsule",
    "size",
    "weight",
    "className",
    "children"
  ]);
  const TypographyComponent = size4 === "l" ? Footnote : Caption;
  return (0, import_jsx_runtime99.jsx)(TypographyComponent, _object_spread_props(_object_spread({}, restProps), {
    weight,
    normalize: true,
    className: clsx(className, "vkuiContentBadge", size4 !== "s" && capsule && "vkuiContentBadge--capsule", mode === "outline" && "vkuiContentBadge--mode-outline", appearanceClassNames[appearance][mode], sizeClassNames[size4]),
    children: (0, import_jsx_runtime99.jsx)(ContentBadgeContext.Provider, {
      value: {
        isSingleChild: React122.Children.count(children) === 1,
        size: size4
      },
      children
    })
  }));
};
ContentBadge.displayName = "ContentBadge";
ContentBadge.SlotIcon = ContentBadgeSlotIcon;
ContentBadge.SlotIcon.displayName = "ContentBadge.SlotIcon";

// node_modules/@vkontakte/vkui/dist/components/ButtonGroup/ButtonGroup.js
var import_jsx_runtime100 = __toESM(require_jsx_runtime());
var stylesMode5 = {
  vertical: "vkuiButtonGroup--mode-vertical",
  horizontal: "vkuiButtonGroup--mode-horizontal"
};
var stylesGap = {
  space: "vkuiButtonGroup--gap-space",
  s: "vkuiButtonGroup--gap-s",
  m: "vkuiButtonGroup--gap-m"
};
var stylesAlign2 = {
  left: "vkuiButtonGroup--align-left",
  center: "vkuiButtonGroup--align-center",
  right: "vkuiButtonGroup--align-right"
};
var ButtonGroup = (_param) => {
  var {
    mode = "horizontal",
    gap = "m",
    stretched = false,
    align = "left"
    /* NOTE: Чтобы блоки по-умолчанию не растягивались на всю ширину контейнера */
  } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "gap",
    "stretched",
    "align"
  ]);
  return (0, import_jsx_runtime100.jsx)(RootComponent, _object_spread({
    baseClassName: clsx("vkuiButtonGroup", stylesMode5[mode], gap !== "none" && stylesGap[gap], stretched && "vkuiButtonGroup--stretched", stylesAlign2[align]),
    role: "group"
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Card/Card.js
var import_jsx_runtime101 = __toESM(require_jsx_runtime());
var Card = (_param) => {
  var {
    mode = "tint",
    // TODO [>=7]: поменять тег на li https://github.com/VKCOM/VKUI/issues/7336
    Component: Component3 = "div"
  } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "Component"
  ]);
  const withBorder = mode === "outline" || mode === "outline-tint";
  return (0, import_jsx_runtime101.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    Component: Component3,
    baseClassName: clsx("vkuiCard", mode === "outline" && "vkuiCard--mode-outline", mode === "shadow" && "vkuiCard--mode-shadow", withBorder && "vkuiCard--withBorder")
  }));
};

// node_modules/@vkontakte/vkui/dist/components/CardGrid/CardGrid.js
var import_jsx_runtime102 = __toESM(require_jsx_runtime());
var sizeXClassNames5 = {
  none: "vkuiCardGrid--sizeX-none",
  compact: "vkuiCardGrid--sizeX-compact"
};
var stylesSize3 = {
  s: "vkuiInternalCardGrid--size-s",
  m: "vkuiInternalCardGrid--size-m",
  l: "vkuiInternalCardGrid--size-l"
};
var CardGrid = (_param) => {
  var {
    size: size4 = "s",
    spaced = false,
    // TODO [>=7]: поменять тег на ul https://github.com/VKCOM/VKUI/issues/7336
    Component: Component3 = "div"
  } = _param, restProps = _object_without_properties(_param, [
    "size",
    "spaced",
    "Component"
  ]);
  const { sizeX = "none" } = useAdaptivity();
  return (0, import_jsx_runtime102.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    Component: Component3,
    baseClassName: clsx("vkuiCardGrid", "vkuiInternalCardGrid", spaced && "vkuiCardGrid--spaced", stylesSize3[size4], sizeX !== "regular" && sizeXClassNames5[sizeX])
  }));
};

// node_modules/@vkontakte/vkui/dist/components/CardScroll/CardScroll.js
var import_jsx_runtime103 = __toESM(require_jsx_runtime());
var React123 = __toESM(require_react());
var stylesSize4 = {
  s: "vkuiInternalCardScroll--size-s",
  m: "vkuiInternalCardScroll--size-m",
  l: "vkuiInternalCardScroll--size-l"
};
var CardScroll = (_param) => {
  var {
    children,
    size: size4 = "s",
    showArrows = true,
    noSpaces = false,
    // TODO [>=7]: поменять тег на ul https://github.com/VKCOM/VKUI/issues/7336
    Component: Component3 = "div"
  } = _param, restProps = _object_without_properties(_param, [
    "children",
    "size",
    "showArrows",
    "noSpaces",
    "Component"
  ]);
  const refContainer = React123.useRef(null);
  const gapRef = React123.useRef(null);
  const { window: window2 } = useDOM();
  function getScrollToLeft(offset4) {
    if (!refContainer.current || !gapRef.current) {
      return offset4;
    }
    const containerWidth = refContainer.current.offsetWidth;
    const slideIndex = [
      ...refContainer.current.children
    ].findIndex((el) => el.offsetLeft + el.offsetWidth + parseInt(window2.getComputedStyle(el).marginRight) - offset4 >= 0);
    if (slideIndex === -1) {
      return offset4;
    }
    if (slideIndex === 0) {
      return 0;
    }
    const slide = refContainer.current.children[slideIndex];
    const scrollTo = slide.offsetLeft - (containerWidth - slide.offsetWidth) + gapRef.current.offsetWidth;
    if (scrollTo <= 2 * gapRef.current.offsetWidth) {
      return 0;
    }
    return scrollTo;
  }
  function getScrollToRight(offset4) {
    if (!refContainer.current || !gapRef.current) {
      return offset4;
    }
    const containerWidth = refContainer.current.offsetWidth;
    const slide = Array.prototype.find.call(refContainer.current.children, (el) => el.offsetLeft + el.offsetWidth - offset4 > containerWidth);
    if (!slide) {
      return offset4;
    }
    return slide.offsetLeft - gapRef.current.offsetWidth;
  }
  return (0, import_jsx_runtime103.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    Component: Component3,
    baseClassName: clsx("vkuiCardScroll", "vkuiInternalCardScroll", size4 !== false && stylesSize4[size4], !noSpaces && "vkuiCardScroll--withSpaces"),
    children: (0, import_jsx_runtime103.jsx)(HorizontalScroll, {
      getScrollToLeft,
      getScrollToRight,
      showArrows,
      children: (0, import_jsx_runtime103.jsxs)("div", {
        className: "vkuiCardScroll__in",
        ref: refContainer,
        children: [
          (0, import_jsx_runtime103.jsx)("span", {
            className: "vkuiCardScroll__gap",
            ref: gapRef
          }),
          children,
          (0, import_jsx_runtime103.jsx)("span", {
            className: "vkuiCardScroll__gap"
          })
        ]
      })
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ContentCard/ContentCard.js
var import_jsx_runtime104 = __toESM(require_jsx_runtime());
var React124 = __toESM(require_react());
var ContentCard = (_param) => {
  var {
    subtitle,
    header,
    headerComponent = "span",
    text,
    caption,
    // card props
    className,
    mode = "shadow",
    style,
    getRootRef,
    // img props
    getRef,
    maxHeight,
    src,
    srcSet,
    alt = "",
    width,
    height,
    crossOrigin,
    decoding,
    loading,
    referrerPolicy,
    sizes,
    useMap,
    fetchPriority,
    hasHover: hasHover2 = false,
    hasActive = false,
    // TODO [>=7]: поменять тег на li https://github.com/VKCOM/VKUI/issues/7336
    Component: Component3 = "div"
  } = _param, restProps = _object_without_properties(_param, [
    "subtitle",
    "header",
    "headerComponent",
    "text",
    "caption",
    "className",
    "mode",
    "style",
    "getRootRef",
    "getRef",
    "maxHeight",
    "src",
    "srcSet",
    "alt",
    "width",
    "height",
    "crossOrigin",
    "decoding",
    "loading",
    "referrerPolicy",
    "sizes",
    "useMap",
    "fetchPriority",
    "hasHover",
    "hasActive",
    "Component"
  ]);
  return (0, import_jsx_runtime104.jsx)(Card, {
    mode,
    getRootRef,
    Component: Component3,
    style,
    className: clsx(restProps.disabled && "vkuiContentCard--disabled", className),
    children: (0, import_jsx_runtime104.jsxs)(Tappable, _object_spread_props(_object_spread({}, restProps), {
      hasHover: hasHover2,
      hasActive,
      className: "vkuiContentCard__tappable",
      children: [
        (src || srcSet) && (0, import_jsx_runtime104.jsx)("img", _object_spread_props(_object_spread({
          ref: getRef,
          className: "vkuiContentCard__img",
          src,
          srcSet,
          alt,
          crossOrigin,
          decoding,
          loading,
          referrerPolicy,
          sizes,
          useMap
        }, getFetchPriorityProp(fetchPriority)), {
          height,
          style: {
            maxHeight
          },
          width: "100%"
        })),
        (0, import_jsx_runtime104.jsxs)("div", {
          className: "vkuiContentCard__body",
          children: [
            hasReactNode(subtitle) && (0, import_jsx_runtime104.jsx)(Caption, {
              className: clsx("vkuiContentCard__text", "vkuiContentCard__subtitle"),
              weight: "1",
              level: "3",
              caps: true,
              children: subtitle
            }),
            hasReactNode(header) && (0, import_jsx_runtime104.jsx)(Headline, {
              className: "vkuiContentCard__text",
              weight: "2",
              level: "1",
              Component: headerComponent,
              children: header
            }),
            hasReactNode(text) && (0, import_jsx_runtime104.jsx)(Text, {
              className: "vkuiContentCard__text",
              children: text
            }),
            hasReactNode(caption) && (0, import_jsx_runtime104.jsx)(Footnote, {
              className: clsx("vkuiContentCard__text", "vkuiContentCard__caption"),
              children: caption
            })
          ]
        })
      ]
    }))
  });
};

// node_modules/@vkontakte/vkui/dist/components/Header/Header.js
var import_jsx_runtime105 = __toESM(require_jsx_runtime());
var React125 = __toESM(require_react());
var HeaderContent = (_param) => {
  var { mode, size: size4 } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "size"
  ]);
  const isLarge = size4 === "large";
  const platform3 = usePlatform();
  if (platform3 === "ios") {
    switch (mode) {
      case "primary":
        return isLarge ? (0, import_jsx_runtime105.jsx)(Title, _object_spread({
          level: "2",
          weight: "2"
        }, restProps)) : (0, import_jsx_runtime105.jsx)(Title, _object_spread({
          weight: "1",
          level: "3"
        }, restProps));
      case "secondary":
        return (0, import_jsx_runtime105.jsx)(Footnote, _object_spread({
          weight: "1",
          caps: true
        }, restProps));
      case "tertiary":
        return (0, import_jsx_runtime105.jsx)(Title, _object_spread({
          weight: "1",
          level: "3"
        }, restProps));
    }
  }
  switch (mode) {
    case "primary":
      return isLarge ? (0, import_jsx_runtime105.jsx)(Title, _object_spread({
        level: "2",
        weight: "2"
      }, restProps)) : (0, import_jsx_runtime105.jsx)(Headline, _object_spread({
        weight: "2"
      }, restProps));
    case "secondary":
      return (0, import_jsx_runtime105.jsx)(Footnote, _object_spread({
        weight: "1",
        caps: true
      }, restProps));
    case "tertiary":
      return (0, import_jsx_runtime105.jsx)(Headline, _object_spread({
        weight: "2"
      }, restProps));
  }
  return null;
};
var stylesMode6 = {
  primary: "vkuiHeader--mode-primary",
  secondary: "vkuiHeader--mode-secondary",
  tertiary: "vkuiHeader--mode-tertiary"
};
var Header = (_param) => {
  var { mode = "primary", size: size4 = "regular", Component: Component3 = "h2", children, subtitle, subtitleComponent = "span", indicator, aside, multiline, before, beforeTitle, afterTitle, beforeSubtitle, afterSubtitle } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "size",
    "Component",
    "children",
    "subtitle",
    "subtitleComponent",
    "indicator",
    "aside",
    "multiline",
    "before",
    "beforeTitle",
    "afterTitle",
    "beforeSubtitle",
    "afterSubtitle"
  ]);
  return (0, import_jsx_runtime105.jsxs)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiHeader", stylesMode6[mode], size4 === "large" && "vkuiHeader--large", isPrimitiveReactNode(indicator) && "vkuiHeader--pi", hasReactNode(subtitle) && "vkuiHeader--with-subtitle"),
    children: [
      before && (0, import_jsx_runtime105.jsx)("div", {
        className: clsx("vkuiHeader__before", subtitle && "vkuiHeader__before--withSubtitle"),
        children: before
      }),
      (0, import_jsx_runtime105.jsxs)("div", {
        className: "vkuiHeader__main",
        children: [
          (0, import_jsx_runtime105.jsxs)(HeaderContent, {
            className: "vkuiHeader__content",
            Component: Component3,
            mode,
            size: size4,
            children: [
              beforeTitle && (0, import_jsx_runtime105.jsx)("div", {
                className: "vkuiHeader__content__before",
                children: beforeTitle
              }),
              (0, import_jsx_runtime105.jsx)("span", {
                className: clsx("vkuiHeader__content-in", multiline && "vkuiHeader__content--multiline"),
                children
              }),
              afterTitle && (0, import_jsx_runtime105.jsx)("div", {
                className: "vkuiHeader__content__after",
                children: afterTitle
              }),
              hasReactNode(indicator) && (0, import_jsx_runtime105.jsx)(Footnote, {
                className: "vkuiHeader__indicator",
                weight: "2",
                children: indicator
              })
            ]
          }),
          hasReactNode(subtitle) && (0, import_jsx_runtime105.jsxs)("div", {
            className: "vkuiHeader__subtitleWrapper",
            children: [
              beforeSubtitle && (0, import_jsx_runtime105.jsx)("div", {
                className: "vkuiHeader__subtitleBefore",
                children: beforeSubtitle
              }),
              (0, import_jsx_runtime105.jsx)(Subhead, {
                className: clsx("vkuiHeader__subtitle", multiline && "vkuiHeader__content--multiline"),
                Component: subtitleComponent,
                children: subtitle
              }),
              afterSubtitle && (0, import_jsx_runtime105.jsx)("div", {
                className: "vkuiHeader__subtitleAfter",
                children: afterSubtitle
              })
            ]
          })
        ]
      }),
      hasReactNode(aside) && (0, import_jsx_runtime105.jsx)(Paragraph, {
        className: "vkuiHeader__aside",
        Component: "span",
        children: aside
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Group/Group.js
var import_jsx_runtime110 = __toESM(require_jsx_runtime());
var React130 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Group/GroupContainer.js
var import_jsx_runtime106 = __toESM(require_jsx_runtime());
var React126 = __toESM(require_react());
var sizeXClassNames6 = {
  none: clsx("vkuiGroup--sizeX-none", "vkuiInternalGroup--sizeX-none"),
  regular: "vkuiGroup--sizeX-regular",
  compact: "vkuiGroup--sizeX-compact"
};
var stylesMode7 = {
  none: clsx("vkuiGroup--mode-none", "vkuiInternalGroup--mode-none"),
  plain: clsx("vkuiGroup--mode-plain", "vkuiInternalGroup--mode-plain"),
  card: clsx("vkuiGroup--mode-card", "vkuiInternalGroup--mode-card")
};
var stylesPadding = {
  s: "vkuiGroup--padding-s",
  m: "vkuiGroup--padding-m"
};
function useGroupMode(forcedMode, sizeX, isInsideModal) {
  const { layout } = React126.useContext(AppRootContext);
  if (forcedMode) {
    return forcedMode;
  }
  if (isInsideModal) {
    return "plain";
  }
  if (layout) {
    return layout;
  }
  if (sizeX !== "none") {
    return sizeX === "regular" ? "card" : "plain";
  }
  return "none";
}
var warn15 = warnOnce("Group");
var GroupContainer = (_param) => {
  var { children, separator = "auto", mode: modeProps, padding = "m", tabIndex: tabIndexProp } = _param, restProps = _object_without_properties(_param, [
    "children",
    "separator",
    "mode",
    "padding",
    "tabIndex"
  ]);
  const { isInsideModal } = React126.useContext(ModalRootContext);
  const { sizeX = "none" } = useAdaptivity();
  const mode = useGroupMode(modeProps, sizeX, isInsideModal);
  const isTabPanel = restProps.role === "tabpanel";
  if (isTabPanel && (!restProps["aria-controls"] || !restProps["id"])) {
    warn15('При использовании роли "tabpanel" необходимо задать значение свойств "aria-controls" и "id"');
  }
  const tabIndex = isTabPanel && tabIndexProp === void 0 ? 0 : tabIndexProp;
  let siblingSeparatorElement = null;
  switch (separator) {
    case "auto":
      siblingSeparatorElement = (0, import_jsx_runtime106.jsx)("div", {
        className: "vkuiGroup__separator-sibling"
      });
      break;
    case "show":
      siblingSeparatorElement = (0, import_jsx_runtime106.jsx)("div", {
        className: clsx("vkuiGroup__separator-sibling", mode === "plain" || mode === "none" ? "vkuiGroup__separator-sibling--forced" : void 0)
      });
      break;
    case "hide":
      break;
  }
  return (0, import_jsx_runtime106.jsxs)(import_jsx_runtime106.Fragment, {
    children: [
      (0, import_jsx_runtime106.jsx)(RootComponent, _object_spread_props(_object_spread({
        Component: "section"
      }, restProps), {
        tabIndex,
        baseClassName: clsx("vkuiInternalGroup", "vkuiGroup", sizeXClassNames6[sizeX], mode === "plain" && isInsideModal && "vkuiGroup--mode-plain-inside-modal", stylesMode7[mode], stylesPadding[padding]),
        children
      })),
      siblingSeparatorElement
    ]
  });
};
GroupContainer.displayName = "GroupContainer";

// node_modules/@vkontakte/vkui/dist/components/Group/GroupDescription.js
var import_jsx_runtime107 = __toESM(require_jsx_runtime());
var React127 = __toESM(require_react());
var GroupDescription = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  return (0, import_jsx_runtime107.jsx)(Footnote, _object_spread({
    className: clsx(className, "vkuiGroup__description")
  }, restProps));
};
GroupDescription.displayName = "GroupDescription";

// node_modules/@vkontakte/vkui/dist/components/Group/GroupExpandedContent.js
var import_jsx_runtime108 = __toESM(require_jsx_runtime());
var React128 = __toESM(require_react());
var stylesDirection3 = {
  inline: "vkuiGroup__expanded-content--inline",
  block: "vkuiGroup__expanded-content--block"
};
var GroupExpandedContent = (_param) => {
  var { direction = "inline" } = _param, restProps = _object_without_properties(_param, [
    "direction"
  ]);
  return (0, import_jsx_runtime108.jsx)(RootComponent, _object_spread_props(_object_spread({
    Component: "div"
  }, restProps), {
    baseClassName: clsx("vkuiGroup__expanded-content", stylesDirection3[direction])
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Group/GroupHeader.js
var import_jsx_runtime109 = __toESM(require_jsx_runtime());
var React129 = __toESM(require_react());
var GroupHeader = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  return (0, import_jsx_runtime109.jsx)("div", _object_spread({
    className: clsx(className, "vkuiGroup__header")
  }, restProps));
};
GroupHeader.displayName = "GroupHeader";

// node_modules/@vkontakte/vkui/dist/components/Group/Group.js
var Group = (_param) => {
  var { header, description, children } = _param, restProps = _object_without_properties(_param, [
    "header",
    "description",
    "children"
  ]);
  return (0, import_jsx_runtime110.jsxs)(GroupContainer, _object_spread_props(_object_spread({}, restProps), {
    children: [
      hasReactNode(header) && (0, import_jsx_runtime110.jsx)(GroupHeader, {
        children: header
      }),
      children,
      hasReactNode(description) && (0, import_jsx_runtime110.jsx)(GroupDescription, {
        children: description
      })
    ]
  }));
};
Group.displayName = "Group";
Group.Container = GroupContainer;
Group.Container.displayName = "Group.Container";
Group.Header = GroupHeader;
Group.Header.displayName = "Group.Header";
Group.Description = GroupDescription;
Group.Description.displayName = "Group.Description";
Group.ExpandedContent = GroupExpandedContent;
Group.ExpandedContent.displayName = "Group.ExpandedContent";

// node_modules/@vkontakte/vkui/dist/components/Gradient/Gradient.js
var import_jsx_runtime111 = __toESM(require_jsx_runtime());
var modeStyles = {
  overlay: "vkuiGradient--mode-overlay",
  tint: "vkuiGradient--mode-tint"
};
var Gradient = (_param) => {
  var { mode = "default", to = "top" } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "to"
  ]);
  return (0, import_jsx_runtime111.jsx)(RootComponent, _object_spread_props(_object_spread({
    role: "presentation"
  }, restProps), {
    baseClassName: clsx("vkuiGradient", mode !== "default" && modeStyles[mode], to === "bottom" && "vkuiGradient--to-bottom")
  }));
};

// node_modules/@vkontakte/vkui/dist/components/List/List.js
var import_jsx_runtime112 = __toESM(require_jsx_runtime());
var React132 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useDraggableWithDomApi/constants.js
var AUTO_SCROLL_START_DELAY = 300;
var ITEM_INITIAL_INDEX = -1;
var DATA_DRAGGABLE_PLACEHOLDER_KEY = "data-draggable-placeholder";
var DATA_DRAGGABLE_PLACEHOLDER_REACT_PROP = {
  [DATA_DRAGGABLE_PLACEHOLDER_KEY]: "true"
};

// node_modules/@vkontakte/vkui/dist/hooks/useDraggableWithDomApi/useDraggableWithDomApi.js
var React131 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/rafSchd.js
var rafSchd = (fn) => {
  let lastArgs = [];
  let frameId = null;
  const wrapperFn = (...args) => {
    lastArgs = args;
    if (frameId) {
      return;
    }
    frameId = requestAnimationFrame(() => {
      frameId = null;
      fn(...lastArgs);
    });
  };
  wrapperFn.cancel = () => {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
  };
  return wrapperFn;
};

// node_modules/@vkontakte/vkui/dist/hooks/useDraggableWithDomApi/autoScroll.js
var SCROLL_SPEED = 10;
var EDGE_SIZE = 50;
var getAutoScrollingData = (clientY, scrollEl) => {
  const scrollTop = Math.floor(getNodeScroll(scrollEl).scrollTop);
  const { relative, edges } = getScrollRect(scrollEl);
  const viewportHeight = relative.height;
  const documentHeight = getScrollHeight(scrollEl);
  const maxScrollY = documentHeight - viewportHeight;
  const canScrollUp = scrollTop > 0;
  const canScrollDown = scrollTop < maxScrollY;
  const [edgeTop, edgeBottom] = edges.y;
  const topDistance = clientY - edgeTop;
  const bottomDistance = edgeBottom - clientY;
  const isInTopEdge = topDistance <= EDGE_SIZE;
  const isInBottomEdge = bottomDistance <= EDGE_SIZE;
  const result = {
    shouldScrolling: canScrollUp && isInTopEdge || canScrollDown && isInBottomEdge,
    y: 0
  };
  if (isInTopEdge) {
    result.y = -1 * ((EDGE_SIZE - topDistance) / EDGE_SIZE) * SCROLL_SPEED;
  } else if (isInBottomEdge) {
    result.y = (EDGE_SIZE - bottomDistance) / EDGE_SIZE * SCROLL_SPEED;
  }
  return result;
};
var createAutoScrollController = (scrollEl) => {
  let isRunning = false;
  const scheduledScroll = rafSchd(scroll);
  function scroll(fn) {
    const { shouldScrolling, y } = fn();
    if (shouldScrolling) {
      isRunning = true;
      scrollEl.scrollBy(0, y);
      scheduledScroll(fn);
    } else {
      isRunning = false;
      scheduledScroll.cancel();
    }
  }
  const tryAutoScroll = (fn) => {
    scheduledScroll(fn);
  };
  const stop = () => {
    isRunning = false;
    scheduledScroll.cancel();
  };
  return {
    tryAutoScroll,
    stop,
    get isRunning() {
      return isRunning;
    }
  };
};

// node_modules/@vkontakte/vkui/dist/hooks/useDraggableWithDomApi/utils.js
var getTargetIsOverOrUnderElData = (clientY, elRect) => {
  const elRectHalfHeight = elRect.height / 2;
  return {
    isUnderEl: clientY <= elRect.bottom - elRectHalfHeight,
    isOverEl: clientY >= elRect.top + elRectHalfHeight
  };
};
var setDraggingItemShiftStyles = (draggingEl, nextShiftY) => {
  requestAnimationFrame(() => {
    draggingEl.style.transform = `translateY(${nextShiftY}px)`;
  });
};
var setSiblingItemsShiftStyles = ([{ el, draggingElRect: { height } }, direction], additionalGap = 0) => {
  requestAnimationFrame(() => {
    if (direction === "up") {
      el.style.setProperty("transition", "transform 0.3s ease-in 0s");
      el.style.removeProperty("transform");
    } else {
      el.style.setProperty("transition", "transform 0.3s ease-out 0s");
      el.style.setProperty("transform", `translateY(${height + additionalGap}px)`);
    }
  });
};
var setInitialDraggingItemStyles = ({ el, draggingElRect }) => {
  const { top, left, width, height } = draggingElRect;
  requestAnimationFrame(() => {
    el.style.setProperty("pointer-events", "none");
    el.style.setProperty("position", "fixed");
    el.style.setProperty("top", `${top}px`);
    el.style.setProperty("left", `${left}px`);
    el.style.setProperty("width", `${width}px`);
    el.style.setProperty("height", `${height}px`);
    el.style.setProperty("z-index", "var(--vkui_internal--z_index_cell_dragging)");
    el.style.setProperty("box-sizing", "border-box");
    el.style.setProperty("transform", "translateY(0)");
  });
};
var unsetInitialDraggingItemStyles = ({ el }) => {
  requestAnimationFrame(() => {
    el.style.removeProperty("pointer-events");
    el.style.removeProperty("position");
    el.style.removeProperty("top");
    el.style.removeProperty("left");
    el.style.removeProperty("width");
    el.style.removeProperty("height");
    el.style.removeProperty("z-index");
    el.style.removeProperty("box-sizing");
    el.style.removeProperty("transform");
  });
};
var setInitialPlaceholderItemStyles = ({ el, draggingElRect }) => {
  if (el.firstElementChild) {
    return;
  }
  const { width, height } = draggingElRect;
  const node = el.cloneNode();
  node.style.setProperty("display", "block");
  node.style.setProperty("width", `${width}px`);
  node.style.setProperty("height", `${height}px`);
  node.style.setProperty("pointer-events", "none");
  el.appendChild(node);
  el.style.setProperty("display", "block");
};
var unsetInitialPlaceholderItemStyles = ({ el }) => {
  el.style.display = "";
  el.removeAttribute("style");
  if (el.firstElementChild) {
    el.firstElementChild.remove();
  }
};
var setInitialSiblingItemStyles = ({ el, shifted, draggingElRect }, additionalGap = 0) => {
  const { height } = draggingElRect;
  requestAnimationFrame(() => {
    el.style.setProperty("pointer-events", "none");
    el.style.setProperty("transition", "none 0s ease 0s");
    if (shifted) {
      el.style.setProperty("transform", `translateY(${height + additionalGap}px)`);
    }
  });
};
var unsetInitialSiblingItemStyles = ({ el }) => {
  requestAnimationFrame(() => {
    el.style.removeProperty("pointer-events");
    el.style.removeProperty("transition");
    el.style.removeProperty("transform");
  });
};

// node_modules/@vkontakte/vkui/dist/hooks/useDraggableWithDomApi/useDraggableWithDomApi.js
var useDraggableWithDomApi = ({ elRef: draggingElRef, onDragFinish }) => {
  const [dragging, setDragging] = React131.useState(false);
  const lastClientYRef = React131.useRef(0);
  const lastDragShiftYRef = React131.useRef(0);
  const scrollElRef = React131.useRef(null);
  const lastScrollTopRef = React131.useRef(0);
  const scrollControllerRef = React131.useRef(null);
  const initializeScrollRefs = (draggableEl) => {
    const node = getNearestOverflowAncestor2(draggableEl);
    if (node) {
      scrollElRef.current = node;
      lastScrollTopRef.current = getNodeScroll(node).scrollTop;
      scrollControllerRef.current = createAutoScrollController(scrollElRef.current);
    }
  };
  const cleanupScrollRefs = () => {
    var _scrollControllerRef_current;
    lastScrollTopRef.current = 0;
    (_scrollControllerRef_current = scrollControllerRef.current) === null || _scrollControllerRef_current === void 0 ? void 0 : _scrollControllerRef_current.stop();
    scrollElRef.current = scrollControllerRef.current = null;
  };
  const lastDragDirectionRef = React131.useRef(void 0);
  const toggleDragDirection = (prevShiftY, nextShiftY) => {
    const shiftYDiff = prevShiftY - nextShiftY;
    if (shiftYDiff < 0) {
      return "down";
    }
    if (shiftYDiff > 0) {
      return "up";
    }
    return lastDragDirectionRef.current;
  };
  const itemStartIndexRef = React131.useRef(ITEM_INITIAL_INDEX);
  const itemEndIndexRef = React131.useRef(ITEM_INITIAL_INDEX);
  const draggingItemRef = React131.useRef(null);
  const placeholderItemRef = React131.useRef(null);
  const siblingItemsRef = React131.useRef([]);
  const itemsGapRef = React131.useRef(0);
  const initializeItems = (draggingEl) => {
    const draggingElRect = getBoundingClientRect(draggingEl, true);
    const parentElement = draggingEl.parentElement;
    itemsGapRef.current = parentElement ? parseInt(parentElement.style.gridGap) : 0;
    const { children } = parentElement || {
      children: []
    };
    Array.prototype.forEach.call(children, (el, index2) => {
      if (el === draggingEl) {
        itemStartIndexRef.current = itemEndIndexRef.current = index2;
        draggingItemRef.current = {
          index: index2,
          el,
          draggingElRect
        };
      } else if (el.getAttribute(DATA_DRAGGABLE_PLACEHOLDER_KEY) !== null) {
        placeholderItemRef.current = {
          index: index2,
          el,
          draggingElRect
        };
      } else {
        siblingItemsRef.current.push({
          index: index2,
          el,
          shifted: itemStartIndexRef.current !== ITEM_INITIAL_INDEX && itemStartIndexRef.current < index2,
          draggingElRect
        });
      }
    });
    if (placeholderItemRef.current) {
      setInitialPlaceholderItemStyles(placeholderItemRef.current);
    }
    if (draggingItemRef.current) {
      setInitialDraggingItemStyles(draggingItemRef.current);
    }
    siblingItemsRef.current.forEach((sibling) => setInitialSiblingItemStyles(sibling, itemsGapRef.current));
  };
  const cleanupItems = () => {
    if (placeholderItemRef.current) {
      unsetInitialPlaceholderItemStyles(placeholderItemRef.current);
    }
    if (draggingItemRef.current) {
      unsetInitialDraggingItemStyles(draggingItemRef.current);
    }
    siblingItemsRef.current.forEach(unsetInitialSiblingItemStyles);
    siblingItemsRef.current = [];
    placeholderItemRef.current = draggingItemRef.current = null;
    const swappedItemIndexRange = {
      from: itemStartIndexRef.current,
      to: itemEndIndexRef.current
    };
    itemStartIndexRef.current = itemEndIndexRef.current = ITEM_INITIAL_INDEX;
    return swappedItemIndexRange;
  };
  const getShiftAndUnshiftItemsPreparedData = (clientY) => {
    const shiftItemEls = [];
    const unshiftItemEls = [];
    itemEndIndexRef.current = itemStartIndexRef.current;
    siblingItemsRef.current.forEach((siblingItem) => {
      const { isOverEl, isUnderEl } = getTargetIsOverOrUnderElData(clientY, getBoundingClientRect(siblingItem.el));
      if (itemStartIndexRef.current < siblingItem.index) {
        if (isOverEl) {
          itemEndIndexRef.current = itemEndIndexRef.current + 1;
          if (lastDragDirectionRef.current === "down" && siblingItem.shifted) {
            siblingItem.shifted = false;
            shiftItemEls.push([
              siblingItem,
              "up"
            ]);
          }
        }
        if (isUnderEl) {
          if (lastDragDirectionRef.current === "up" && !siblingItem.shifted) {
            siblingItem.shifted = true;
            unshiftItemEls.push([
              siblingItem,
              "down"
            ]);
          }
        }
      } else if (itemStartIndexRef.current > siblingItem.index) {
        if (isUnderEl) {
          itemEndIndexRef.current = itemEndIndexRef.current - 1;
          if (lastDragDirectionRef.current === "up" && !siblingItem.shifted) {
            siblingItem.shifted = true;
            shiftItemEls.push([
              siblingItem,
              "down"
            ]);
          }
        }
        if (isOverEl) {
          if (lastDragDirectionRef.current === "down" && siblingItem.shifted) {
            siblingItem.shifted = false;
            unshiftItemEls.push([
              siblingItem,
              "up"
            ]);
          }
        }
      }
    });
    return [
      shiftItemEls,
      unshiftItemEls
    ];
  };
  const setShiftAndUnshiftItemStyles = (shiftItemEls, unshiftItemEls) => {
    shiftItemEls.forEach((item) => setSiblingItemsShiftStyles(item, itemsGapRef.current));
    unshiftItemEls.forEach((item) => setSiblingItemsShiftStyles(item, itemsGapRef.current));
  };
  const schedulingAutoScrollTimeoutIdRef = React131.useRef(null);
  const clearSchedulingAutoScrollTimeout = () => {
    if (schedulingAutoScrollTimeoutIdRef.current) {
      clearTimeout(schedulingAutoScrollTimeoutIdRef.current);
      schedulingAutoScrollTimeoutIdRef.current = null;
    }
  };
  const tryAutoScroll = () => {
    if (scrollControllerRef.current) {
      scrollControllerRef.current.tryAutoScroll(() => {
        return scrollElRef.current ? getAutoScrollingData(lastClientYRef.current, scrollElRef.current) : {
          shouldScrolling: false,
          y: 0
        };
      });
    }
  };
  const schedulingAutoScroll = () => {
    clearSchedulingAutoScrollTimeout();
    schedulingAutoScrollTimeoutIdRef.current = setTimeout(() => {
      schedulingAutoScrollTimeoutIdRef.current = null;
      tryAutoScroll();
    }, AUTO_SCROLL_START_DELAY);
  };
  const onDragStart = (event) => {
    event.originalEvent.stopPropagation();
    event.originalEvent.preventDefault();
  };
  const onDragMove = (event) => {
    event.originalEvent.stopPropagation();
    event.originalEvent.preventDefault();
    const draggingEl = draggingElRef.current;
    if (!draggingEl) {
      return;
    }
    if (dragging) {
      lastDragDirectionRef.current = toggleDragDirection(lastDragShiftYRef.current, event.shiftY);
      lastDragShiftYRef.current = event.shiftY;
      lastClientYRef.current = event.clientY;
      if (scrollControllerRef.current && scrollControllerRef.current.isRunning) {
        setDraggingItemShiftStyles(draggingEl, lastDragShiftYRef.current);
      } else {
        const [shiftItemEls, unshiftItemEls] = getShiftAndUnshiftItemsPreparedData(lastClientYRef.current);
        setDraggingItemShiftStyles(draggingEl, lastDragShiftYRef.current);
        setShiftAndUnshiftItemStyles(shiftItemEls, unshiftItemEls);
        schedulingAutoScroll();
      }
    } else {
      setDragging((prevDragging) => {
        if (prevDragging) {
          return prevDragging;
        }
        initializeScrollRefs(draggingEl);
        initializeItems(draggingEl);
        return true;
      });
    }
  };
  const onDragEnd = (event) => {
    event.originalEvent.stopPropagation();
    event.originalEvent.preventDefault();
    clearSchedulingAutoScrollTimeout();
    cleanupScrollRefs();
    lastClientYRef.current = lastDragShiftYRef.current = 0;
    lastDragDirectionRef.current = void 0;
    if (dragging) {
      const swappedItemRange = cleanupItems();
      if (onDragFinish) {
        onDragFinish(swappedItemRange);
      }
      setDragging(false);
    }
  };
  const handleScroll = React131.useCallback(() => {
    if (!draggingElRef.current || !scrollElRef.current) {
      return;
    }
    const nextScrollTop = getNodeScroll(scrollElRef.current).scrollTop;
    lastDragDirectionRef.current = toggleDragDirection(lastScrollTopRef.current, nextScrollTop);
    const scrollDiff = lastScrollTopRef.current - nextScrollTop;
    const clientYWithScrollOffset = lastClientYRef.current + scrollDiff;
    lastScrollTopRef.current = nextScrollTop;
    const [shiftItemEls, unshiftItemEls] = getShiftAndUnshiftItemsPreparedData(clientYWithScrollOffset);
    setShiftAndUnshiftItemStyles(shiftItemEls, unshiftItemEls);
  }, [
    draggingElRef
  ]);
  useIsomorphicLayoutEffect(function recalculateOnScroll() {
    const scrollEl = scrollElRef.current;
    if (!dragging || !scrollEl) {
      return;
    }
    scrollEl.addEventListener("scroll", handleScroll);
    return () => {
      if (scrollEl) {
        scrollEl.removeEventListener("scroll", handleScroll);
      }
    };
  }, [
    dragging,
    handleScroll
  ]);
  useIsomorphicLayoutEffect(() => function componentWillUnmount() {
    if (placeholderItemRef.current) {
      unsetInitialPlaceholderItemStyles(placeholderItemRef.current);
    }
  }, []);
  return {
    dragging,
    onDragStart,
    onDragMove,
    onDragEnd
  };
};

// node_modules/@vkontakte/vkui/dist/components/List/List.js
var List = (_param) => {
  var { children, gap = 0, className, style } = _param, restProps = _object_without_properties(_param, [
    "children",
    "gap",
    "className",
    "style"
  ]);
  return (0, import_jsx_runtime112.jsxs)(RootComponent, _object_spread_props(_object_spread({
    role: "list",
    className: clsx("vkuiList", className),
    style: _object_spread_props(_object_spread({}, style), {
      gridGap: gap
    })
  }, restProps), {
    children: [
      children,
      (0, import_jsx_runtime112.jsx)("div", _object_spread_props(_object_spread({
        "aria-hidden": true
      }, DATA_DRAGGABLE_PLACEHOLDER_REACT_PROP), {
        className: "vkuiList__placeholder"
      }))
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Cell/Cell.js
var import_jsx_runtime118 = __toESM(require_jsx_runtime());
var React137 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Removable/Removable.js
var import_jsx_runtime113 = __toESM(require_jsx_runtime());
var React133 = __toESM(require_react());
var RemovableIos = ({ onRemove, removePlaceholder, removePlaceholderString, children: childrenProp, toggleButtonTestId, removeButtonTestId, disabled }) => {
  const { window: window2 } = useDOM();
  const removeButtonRef = React133.useRef(null);
  const disabledRef = React133.useRef(true);
  const [removeOffset, updateRemoveOffset] = React133.useState(0);
  useGlobalEventListener(window2, "click", () => {
    if (removeOffset > 0) {
      updateRemoveOffset(0);
    }
  }, {
    capture: true
  });
  const onRemoveTransitionEnd = () => {
    if (removeOffset > 0) {
      var _removeButtonRef_current;
      removeButtonRef === null || removeButtonRef === void 0 ? void 0 : (_removeButtonRef_current = removeButtonRef.current) === null || _removeButtonRef_current === void 0 ? void 0 : _removeButtonRef_current.focus();
    } else {
      disabledRef.current = true;
    }
  };
  const onRemoveActivateClick = (e) => {
    e.stopPropagation();
    if (!removeButtonRef.current) {
      return;
    }
    const { offsetWidth } = removeButtonRef.current;
    disabledRef.current = false;
    updateRemoveOffset(offsetWidth);
  };
  return (0, import_jsx_runtime113.jsxs)("div", {
    className: clsx("vkuiRemovable__content", "vkuiInternalRemovable__content"),
    style: {
      transform: `translateX(-${removeOffset !== null && removeOffset !== void 0 ? removeOffset : 0}px)`
    },
    onTransitionEnd: onRemoveTransitionEnd,
    children: [
      (0, import_jsx_runtime113.jsxs)(IconButton, {
        hasActive: false,
        hasHover: false,
        className: clsx("vkuiRemovable__action", "vkuiRemovable__toggle", "vkuiInternalRemovable__action"),
        onClick: onRemoveActivateClick,
        disabled: removeOffset > 0 || disabled,
        "data-testid": toggleButtonTestId,
        children: [
          (0, import_jsx_runtime113.jsx)(VisuallyHidden, {
            children: removePlaceholderString
          }),
          (0, import_jsx_runtime113.jsx)("i", {
            className: "vkuiRemovable__toggle-in",
            role: "presentation"
          })
        ]
      }),
      typeof childrenProp === "function" ? childrenProp({
        isRemoving: removeOffset > 0
      }) : childrenProp,
      (0, import_jsx_runtime113.jsx)("span", {
        className: "vkuiRemovable__offset",
        "aria-hidden": true
      }),
      (0, import_jsx_runtime113.jsx)(Tappable, {
        Component: "button",
        hasActive: false,
        hasHover: false,
        disabled: disabledRef.current,
        getRootRef: removeButtonRef,
        className: "vkuiRemovable__remove",
        onClick: onRemove,
        "data-testid": removeButtonTestId,
        children: (0, import_jsx_runtime113.jsx)("span", {
          className: "vkuiRemovable__remove-in",
          children: removePlaceholder
        })
      })
    ]
  });
};
var Removable = (_param) => {
  var { children, onRemove, removePlaceholder = "Удалить", align = "center", indent = false, toggleButtonTestId, removeButtonTestId, disabled } = _param, restProps = _object_without_properties(_param, [
    "children",
    "onRemove",
    "removePlaceholder",
    "align",
    "indent",
    "toggleButtonTestId",
    "removeButtonTestId",
    "disabled"
  ]);
  const platform3 = usePlatform();
  const onRemoveClick = (e) => {
    e.preventDefault();
    onRemove === null || onRemove === void 0 ? void 0 : onRemove(e);
  };
  const removePlaceholderString = getTextFromChildren(removePlaceholder);
  return (0, import_jsx_runtime113.jsxs)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx(platform3 === "ios" && "vkuiRemovable--ios", align === "start" && "vkuiRemovable--align-start", indent && "vkuiRemovable--indent"),
    children: [
      platform3 !== "ios" && (0, import_jsx_runtime113.jsxs)("div", {
        className: clsx("vkuiRemovable__content", "vkuiInternalRemovable__content"),
        children: [
          typeof children === "function" ? children({
            isRemoving: false
          }) : children,
          (0, import_jsx_runtime113.jsx)(IconButton, {
            activeMode: "opacity",
            hoverMode: "opacity",
            className: clsx("vkuiRemovable__action", "vkuiInternalRemovable__action"),
            onClick: onRemoveClick,
            label: removePlaceholderString,
            "data-testid": removeButtonTestId,
            disabled,
            children: (0, import_jsx_runtime113.jsx)(Icon24Cancel, {
              role: "presentation"
            })
          }),
          (0, import_jsx_runtime113.jsx)("span", {
            className: "vkuiRemovable__offset",
            "aria-hidden": true
          })
        ]
      }),
      platform3 === "ios" && (0, import_jsx_runtime113.jsx)(RemovableIos, {
        onRemove: onRemoveClick,
        removePlaceholder,
        removePlaceholderString,
        toggleButtonTestId,
        removeButtonTestId,
        disabled,
        children
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/SimpleCell/SimpleCell.js
var import_jsx_runtime115 = __toESM(require_jsx_runtime());
var React135 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/SimpleCell/Chevron/Chevron.js
var import_jsx_runtime114 = __toESM(require_jsx_runtime());
var React134 = __toESM(require_react());
var iconSize = {
  s: Icon16Chevron,
  m: Icon24ChevronCompactRight
};
var Chevron = (_param) => {
  var { size: size4 = "m" } = _param, restProps = _object_without_properties(_param, [
    "size"
  ]);
  const Icon = iconSize[size4];
  return (0, import_jsx_runtime114.jsx)(Icon, _object_spread({}, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/SimpleCell/SimpleCell.js
var sizeYClassNames15 = {
  none: "vkuiSimpleCell--sizeY-none",
  compact: "vkuiSimpleCell--sizeY-compact"
};
var SimpleCell = (_param) => {
  var { badgeBeforeTitle, badgeAfterTitle, badgeBeforeSubtitle, badgeAfterSubtitle, before, indicator, children, after, expandable, multiline, subhead, subtitle, extraSubtitle, className, chevronSize = "m" } = _param, restProps = _object_without_properties(_param, [
    "badgeBeforeTitle",
    "badgeAfterTitle",
    "badgeBeforeSubtitle",
    "badgeAfterSubtitle",
    "before",
    "indicator",
    "children",
    "after",
    "expandable",
    "multiline",
    "subhead",
    "subtitle",
    "extraSubtitle",
    "className",
    "chevronSize"
  ]);
  const platform3 = usePlatform();
  const hasChevron = expandable === "always" || expandable === "auto" && platform3 === "ios";
  const hasAfter = hasReactNode(after) || hasChevron;
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime115.jsxs)(Tappable, _object_spread_props(_object_spread({}, restProps), {
    className: clsx("vkuiSimpleCell", restProps.disabled && "vkuiSimpleCell--disabled", sizeY !== "regular" && sizeYClassNames15[sizeY], multiline && "vkuiSimpleCell--mult", className),
    children: [
      (0, import_jsx_runtime115.jsx)("div", {
        className: clsx("vkuiSimpleCell__before", platform3 === "ios" && "vkuiSimpleCell__before--ios"),
        children: before
      }),
      (0, import_jsx_runtime115.jsxs)("div", {
        className: "vkuiSimpleCell__middle",
        children: [
          subhead && (0, import_jsx_runtime115.jsx)(Subhead, {
            Component: "span",
            className: clsx("vkuiSimpleCell__text", "vkuiSimpleCell__subhead"),
            children: subhead
          }),
          (0, import_jsx_runtime115.jsxs)("div", {
            className: "vkuiSimpleCell__content",
            children: [
              badgeBeforeTitle && (0, import_jsx_runtime115.jsx)("span", {
                className: "vkuiSimpleCell__badge",
                children: badgeBeforeTitle
              }),
              (0, import_jsx_runtime115.jsx)(Headline, {
                Component: "span",
                className: "vkuiSimpleCell__children",
                weight: "3",
                children
              }),
              hasReactNode(badgeAfterTitle) && (0, import_jsx_runtime115.jsx)("span", {
                className: "vkuiSimpleCell__badge",
                children: badgeAfterTitle
              })
            ]
          }),
          subtitle && (0, import_jsx_runtime115.jsxs)("div", {
            className: "vkuiSimpleCell__content",
            children: [
              badgeBeforeSubtitle && (0, import_jsx_runtime115.jsx)("span", {
                className: "vkuiSimpleCell__badge",
                children: badgeBeforeSubtitle
              }),
              (0, import_jsx_runtime115.jsx)(Footnote, {
                normalize: false,
                className: clsx("vkuiSimpleCell__text", "vkuiSimpleCell__subtitle"),
                children: subtitle
              }),
              badgeAfterSubtitle && (0, import_jsx_runtime115.jsx)("span", {
                className: "vkuiSimpleCell__badge",
                children: badgeAfterSubtitle
              })
            ]
          }),
          extraSubtitle && (0, import_jsx_runtime115.jsx)(Footnote, {
            className: clsx("vkuiSimpleCell__text", "vkuiSimpleCell__extraSubtitle"),
            children: extraSubtitle
          })
        ]
      }),
      hasReactNode(indicator) && (0, import_jsx_runtime115.jsx)(Headline, {
        Component: "span",
        weight: "3",
        className: "vkuiSimpleCell__indicator",
        children: indicator
      }),
      hasAfter && (0, import_jsx_runtime115.jsxs)("div", {
        className: clsx("vkuiSimpleCell__after", "vkuiInternalSimpleCell__after"),
        children: [
          after,
          hasChevron && (0, import_jsx_runtime115.jsx)(Chevron, {
            size: chevronSize,
            className: "vkuiSimpleCell__chevronIcon"
          })
        ]
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Cell/CellCheckbox/CellCheckbox.js
var import_jsx_runtime116 = __toESM(require_jsx_runtime());
var React136 = __toESM(require_react());
var CheckBoxOn = () => (0, import_jsx_runtime116.jsx)(AdaptiveIconRenderer, {
  IconCompact: Icon20CheckBoxOn,
  IconRegular: Icon24CheckBoxOn
});
var CheckBoxOff = () => (0, import_jsx_runtime116.jsx)(AdaptiveIconRenderer, {
  IconCompact: Icon20CheckBoxOff,
  IconRegular: Icon24CheckBoxOff
});
var CheckCircleOn = () => (0, import_jsx_runtime116.jsx)(AdaptiveIconRenderer, {
  IconCompact: Icon20CheckCircleOn,
  IconRegular: Icon24CheckCircleOn
});
var CheckCircleOff = () => (0, import_jsx_runtime116.jsx)(AdaptiveIconRenderer, {
  IconCompact: Icon20CheckCircleOff,
  IconRegular: Icon24CheckCircleOff
});
function useTypeIcon(type) {
  const platform3 = usePlatform();
  if (type !== "auto") {
    return type;
  }
  if (platform3 === "ios" || platform3 === "vkcom") {
    return "circle";
  }
  return "square";
}
var CellCheckbox = (_param) => {
  var { getRootRef, getRef, className, style, type = "auto" } = _param, restProps = _object_without_properties(_param, [
    "getRootRef",
    "getRef",
    "className",
    "style",
    "type"
  ]);
  const typeIcon = useTypeIcon(type);
  const IconOff = typeIcon === "circle" ? CheckCircleOff : CheckBoxOff;
  const IconOn = typeIcon === "circle" ? CheckCircleOn : CheckBoxOn;
  return (0, import_jsx_runtime116.jsxs)("span", {
    className: clsx("vkuiCellCheckbox", className),
    style,
    ref: getRootRef,
    children: [
      (0, import_jsx_runtime116.jsx)(VisuallyHidden, _object_spread_props(_object_spread({}, restProps), {
        Component: "input",
        type: "checkbox",
        className: "vkuiCellCheckbox__input",
        getRootRef: getRef
      })),
      (0, import_jsx_runtime116.jsx)("span", {
        className: clsx("vkuiCellCheckbox__icon", "vkuiCellCheckbox__icon--off"),
        "aria-hidden": true,
        children: (0, import_jsx_runtime116.jsx)(IconOff, {})
      }),
      (0, import_jsx_runtime116.jsx)("span", {
        className: clsx("vkuiCellCheckbox__icon", "vkuiCellCheckbox__icon--on"),
        "aria-hidden": true,
        children: (0, import_jsx_runtime116.jsx)(IconOn, {})
      })
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/Cell/CellDragger/CellDragger.js
var import_jsx_runtime117 = __toESM(require_jsx_runtime());
var CellDragger = (_param) => {
  var { elRef, disabled, className, onDragStateChange, onDragFinish, children } = _param, restProps = _object_without_properties(_param, [
    "elRef",
    "disabled",
    "className",
    "onDragStateChange",
    "onDragFinish",
    "children"
  ]);
  const platform3 = usePlatform();
  const Icon = platform3 === "ios" ? Icon24ReorderIos : Icon24Reorder;
  const { dragging, onDragStart, onDragMove, onDragEnd } = useDraggableWithDomApi({
    elRef,
    onDragFinish
  });
  useIsomorphicLayoutEffect(() => {
    if (onDragStateChange) {
      onDragStateChange(dragging);
    }
  }, [
    dragging,
    onDragStateChange
  ]);
  return (0, import_jsx_runtime117.jsxs)(Touch, _object_spread_props(_object_spread({
    className: clsx("vkuiCellDragger", className),
    onStart: disabled ? void 0 : onDragStart,
    onMoveY: disabled ? void 0 : onDragMove,
    onEnd: disabled ? void 0 : onDragEnd
  }, restProps), {
    children: [
      children && (0, import_jsx_runtime117.jsx)(VisuallyHidden, {
        children
      }),
      (0, import_jsx_runtime117.jsx)(Icon, {
        className: "vkuiCellDragger__icon"
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Cell/constants.js
var DEFAULT_DRAGGABLE_LABEL = "Перенести ячейку";

// node_modules/@vkontakte/vkui/dist/components/Cell/Cell.js
var Cell = (_param) => {
  var { mode, onRemove, removePlaceholder = "Удалить", onDragFinish, before, after, disabled, draggable, Component: ComponentProps, onChange, name, value, checked, defaultChecked, getRootRef, draggerLabel = DEFAULT_DRAGGABLE_LABEL, className, style, toggleButtonTestId, removeButtonTestId } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "onRemove",
    "removePlaceholder",
    "onDragFinish",
    "before",
    "after",
    "disabled",
    "draggable",
    "Component",
    "onChange",
    "name",
    "value",
    "checked",
    "defaultChecked",
    "getRootRef",
    "draggerLabel",
    "className",
    "style",
    "toggleButtonTestId",
    "removeButtonTestId"
  ]);
  const [dragging, setDragging] = React137.useState(false);
  const selectable = mode === "selectable";
  const removable = mode === "removable";
  const Component3 = selectable ? "label" : ComponentProps;
  const platform3 = usePlatform();
  const rootElRef = useExternRef(getRootRef);
  const dragger = draggable ? (0, import_jsx_runtime118.jsx)(CellDragger, {
    elRef: rootElRef,
    className: clsx("vkuiCell__dragger", !before && !selectable && "vkuiCell__control--noBefore"),
    onDragStateChange: setDragging,
    onDragFinish,
    children: draggerLabel
  }) : null;
  let checkbox;
  if (selectable) {
    const checkboxProps = {
      name,
      value,
      defaultChecked,
      checked,
      disabled,
      onChange
    };
    checkbox = (0, import_jsx_runtime118.jsx)(CellCheckbox, _object_spread({
      className: clsx("vkuiCell__checkbox", !before && "vkuiCell__control--noBefore")
    }, checkboxProps));
  }
  const hasActive = !disabled && !dragging;
  const cellClasses = clsx("vkuiCell", dragging && "vkuiCell--dragging", platform3 === "ios" && "vkuiCell--ios", removable && "vkuiCell--removable", Component3 === "label" && "vkuiCell--selectable");
  const simpleCellProps = _object_spread_props(_object_spread(_object_spread_props(_object_spread({
    hasActive,
    hasHover: hasActive && !removable,
    disabled
  }, restProps), {
    className: "vkuiCell__content"
  }), Component3 && {
    Component: Component3
  }), {
    before: (0, import_jsx_runtime118.jsxs)(React137.Fragment, {
      children: [
        draggable && platform3 !== "ios" && dragger,
        selectable && checkbox,
        before
      ]
    }),
    after: (0, import_jsx_runtime118.jsxs)(React137.Fragment, {
      children: [
        draggable && platform3 === "ios" && dragger,
        after
      ]
    })
  });
  if (removable) {
    return (0, import_jsx_runtime118.jsx)(Removable, {
      className: clsx(cellClasses, className),
      style,
      getRootRef: rootElRef,
      removePlaceholder,
      onRemove: (e) => onRemove === null || onRemove === void 0 ? void 0 : onRemove(e, rootElRef.current),
      toggleButtonTestId,
      removeButtonTestId,
      disabled,
      children: platform3 === "ios" ? ({ isRemoving }) => {
        return (0, import_jsx_runtime118.jsx)(SimpleCell, _object_spread({}, simpleCellProps, isRemoving ? {
          onClick: void 0
        } : {}));
      } : (0, import_jsx_runtime118.jsx)(SimpleCell, _object_spread({}, simpleCellProps))
    });
  }
  return (0, import_jsx_runtime118.jsx)("div", {
    className: clsx(cellClasses, className),
    style,
    ref: rootElRef,
    children: (0, import_jsx_runtime118.jsx)(SimpleCell, _object_spread({}, simpleCellProps))
  });
};
Cell.Checkbox = CellCheckbox;

// node_modules/@vkontakte/vkui/dist/components/RichCell/RichCell.js
var import_jsx_runtime120 = __toESM(require_jsx_runtime());
var React138 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/RichCell/RichCellIcon/RichCellIcon.js
var import_jsx_runtime119 = __toESM(require_jsx_runtime());
var RichCellIcon = (props) => {
  return (0, import_jsx_runtime119.jsx)(RootComponent, _object_spread({
    baseClassName: "vkuiRichCellIcon"
  }, props));
};

// node_modules/@vkontakte/vkui/dist/components/RichCell/RichCell.js
var sizeYClassNames16 = {
  none: "vkuiRichCell--sizeY-none",
  compact: "vkuiRichCell--sizeY-compact"
};
var alignAfterClassNames = {
  start: "vkuiRichCell__content-after--align-start",
  center: "vkuiRichCell__content-after--align-center",
  end: "vkuiRichCell__content-after--align-end"
};
var RichCell = (_param) => {
  var { subhead, children, text, caption, before, after, afterCaption, bottom, actions, multiline, className, afterAlign = "start" } = _param, restProps = _object_without_properties(_param, [
    "subhead",
    "children",
    "text",
    "caption",
    "before",
    "after",
    "afterCaption",
    "bottom",
    "actions",
    "multiline",
    "className",
    "afterAlign"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const afterRender = () => {
    if (!after && !afterCaption) {
      return;
    }
    return (0, import_jsx_runtime120.jsxs)("div", {
      className: clsx("vkuiRichCell__content-after", alignAfterClassNames[afterAlign]),
      children: [
        after && (0, import_jsx_runtime120.jsx)("div", {
          className: "vkuiRichCell__after-children",
          children: after
        }),
        afterCaption && (0, import_jsx_runtime120.jsx)("div", {
          className: "vkuiRichCell__after-caption",
          children: afterCaption
        })
      ]
    });
  };
  return (0, import_jsx_runtime120.jsxs)(Tappable, _object_spread_props(_object_spread({}, restProps), {
    className: clsx("vkuiRichCell", !multiline && "vkuiRichCell--text-ellipsis", sizeY !== "regular" && sizeYClassNames16[sizeY], className),
    children: [
      before && (0, import_jsx_runtime120.jsx)("div", {
        className: "vkuiRichCell__before",
        children: before
      }),
      (0, import_jsx_runtime120.jsxs)("div", {
        className: "vkuiRichCell__in",
        children: [
          (0, import_jsx_runtime120.jsxs)("div", {
            className: "vkuiRichCell__content",
            children: [
              (0, import_jsx_runtime120.jsxs)("div", {
                className: "vkuiRichCell__content-before",
                children: [
                  subhead && (0, import_jsx_runtime120.jsx)(Subhead, {
                    Component: "div",
                    className: "vkuiRichCell__subhead",
                    children: subhead
                  }),
                  (0, import_jsx_runtime120.jsx)("div", {
                    className: "vkuiRichCell__children",
                    children
                  }),
                  text && (0, import_jsx_runtime120.jsx)("div", {
                    className: "vkuiRichCell__text",
                    children: text
                  }),
                  caption && (0, import_jsx_runtime120.jsx)(Subhead, {
                    Component: "div",
                    className: "vkuiRichCell__caption",
                    children: caption
                  })
                ]
              }),
              afterAlign === "start" && afterRender()
            ]
          }),
          bottom && (0, import_jsx_runtime120.jsx)("div", {
            className: "vkuiRichCell__bottom",
            children: bottom
          }),
          actions && (0, import_jsx_runtime120.jsx)("div", {
            className: "vkuiRichCell__actions",
            children: actions
          })
        ]
      }),
      afterAlign !== "start" && afterRender()
    ]
  }));
};
RichCell.Icon = RichCellIcon;

// node_modules/@vkontakte/vkui/dist/components/CellButton/CellButton.js
var import_jsx_runtime121 = __toESM(require_jsx_runtime());
var CellButton = (_param) => {
  var { centered = false, mode = "primary", className } = _param, restProps = _object_without_properties(_param, [
    "centered",
    "mode",
    "className"
  ]);
  return (0, import_jsx_runtime121.jsx)(SimpleCell, _object_spread_props(_object_spread({}, restProps), {
    className: clsx("vkuiCellButton", mode === "danger" && "vkuiCellButton--mode-danger", centered && "vkuiCellButton--centered", className)
  }));
};

// node_modules/@vkontakte/vkui/dist/components/HorizontalCell/HorizontalCell.js
var import_jsx_runtime126 = __toESM(require_jsx_runtime());
var React142 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Avatar/Avatar.js
var import_jsx_runtime125 = __toESM(require_jsx_runtime());

// node_modules/@vkontakte/vkui/dist/components/Avatar/AvatarBadge/AvatarBadge.js
var import_jsx_runtime122 = __toESM(require_jsx_runtime());
var React139 = __toESM(require_react());
var AvatarBadge = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  const { size: size4 } = React139.useContext(ImageBaseContext);
  return (0, import_jsx_runtime122.jsx)(ImageBase.Badge, _object_spread_props(_object_spread({}, restProps), {
    className: clsx("vkuiAvatarBadge", size4 < 96 && "vkuiAvatarBadge--shifted", className)
  }));
};
AvatarBadge.displayName = "Avatar.Badge";

// node_modules/@vkontakte/vkui/dist/components/Avatar/AvatarBadge/AvatarBadgeWithPreset.js
var import_jsx_runtime124 = __toESM(require_jsx_runtime());
var React141 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Avatar/AvatarBadge/icons.js
var import_jsx_runtime123 = __toESM(require_jsx_runtime());
var React140 = __toESM(require_react());
var Icon12Circle2 = (_param) => {
  var { width, height } = _param, restProps = _object_without_properties(_param, [
    "width",
    "height"
  ]);
  return (0, import_jsx_runtime123.jsx)(Icon12Circle, _object_spread_props(_object_spread({}, restProps), {
    width: width >= 24 ? 15 : 12,
    height: height >= 24 ? 15 : 12
  }));
};
var Icon12OnlineMobile2 = (_param) => {
  var { width, height } = _param, restProps = _object_without_properties(_param, [
    "width",
    "height"
  ]);
  return (0, import_jsx_runtime123.jsx)(Icon12OnlineMobile, _object_spread_props(_object_spread({}, restProps), {
    width: width >= 24 ? 9 : 8,
    height: height >= 24 ? 15 : 12
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Avatar/AvatarBadge/AvatarBadgeWithPreset.js
var AvatarBadgeWithPreset = (_param) => {
  var { preset = "online", className } = _param, restProps = _object_without_properties(_param, [
    "preset",
    "className"
  ]);
  const { size: size4 } = React141.useContext(ImageBaseContext);
  const badgeSize = getBadgeIconSizeByImageBaseSize(size4);
  const isOnlinePreset = preset === "online";
  const presetClassName = isOnlinePreset ? "vkuiAvatarBadge--preset-online" : "vkuiAvatarBadge--preset-onlineMobile";
  const Icon = isOnlinePreset ? Icon12Circle2 : Icon12OnlineMobile2;
  return (0, import_jsx_runtime124.jsx)(ImageBase.Badge, _object_spread_props(_object_spread({
    background: "stroke",
    className: clsx("vkuiAvatarBadge", presetClassName, className)
  }, restProps), {
    children: (0, import_jsx_runtime124.jsx)(Icon, {
      width: badgeSize,
      height: badgeSize
    })
  }));
};
AvatarBadgeWithPreset.displayName = "Avatar.BadgeWithPreset";

// node_modules/@vkontakte/vkui/dist/components/Avatar/helpers.js
var MAX_FONT_SIZE = 30;
var MAX_IMAGE_BASE_SIZE = 96;
var RELATIVE_SIZE = MAX_FONT_SIZE / MAX_IMAGE_BASE_SIZE;
function getInitialsFontSize(avatarSize) {
  if (avatarSize <= 16) {
    return 5;
  } else if (avatarSize <= 24) {
    return 8;
  } else if (avatarSize <= 32) {
    return 10;
  } else if (avatarSize <= 36) {
    return 13;
  } else if (avatarSize <= 44) {
    return 14;
  } else if (avatarSize <= 48) {
    return 17;
  } else if (avatarSize < 56) {
    return 18;
  } else if (avatarSize <= 64) {
    return 21;
  } else if (avatarSize <= 88) {
    return 26;
  } else if (avatarSize <= MAX_IMAGE_BASE_SIZE) {
    return MAX_FONT_SIZE;
  }
  const calculatedFontSize = Math.ceil(avatarSize * RELATIVE_SIZE);
  const evenFix = calculatedFontSize % 2;
  return calculatedFontSize + evenFix;
}

// node_modules/@vkontakte/vkui/dist/components/Avatar/Avatar.js
var AVATAR_DEFAULT_SIZE = 48;
var COLORS_NUMBER_TO_TEXT_MAP = {
  1: "red",
  2: "orange",
  3: "yellow",
  4: "green",
  5: "l-blue",
  6: "violet"
};
var gradientStyles = {
  "red": "vkuiAvatar--gradient-red",
  "orange": "vkuiAvatar--gradient-orange",
  "yellow": "vkuiAvatar--gradient-yellow",
  "green": "vkuiAvatar--gradient-green",
  "blue": "vkuiAvatar--gradient-blue",
  "l-blue": "vkuiAvatar--gradient-l-blue",
  "violet": "vkuiAvatar--gradient-violet"
};
var Avatar = (_param) => {
  var { size: size4 = AVATAR_DEFAULT_SIZE, className, gradientColor, initials, fallbackIcon: fallbackIconProp, children } = _param, restProps = _object_without_properties(_param, [
    "size",
    "className",
    "gradientColor",
    "initials",
    "fallbackIcon",
    "children"
  ]);
  const gradientName = typeof gradientColor === "number" ? COLORS_NUMBER_TO_TEXT_MAP[gradientColor] : gradientColor;
  const isGradientNotCustom = gradientName && gradientName !== "custom";
  const fallbackIcon = initials ? (0, import_jsx_runtime125.jsx)("div", {
    className: "vkuiAvatar__initials",
    style: {
      fontSize: getInitialsFontSize(size4)
    },
    children: initials
  }) : fallbackIconProp;
  return (0, import_jsx_runtime125.jsx)(ImageBase, _object_spread_props(_object_spread({}, restProps), {
    size: size4,
    fallbackIcon,
    className: clsx("vkuiAvatar", gradientName && "vkuiAvatar--has-gradient", isGradientNotCustom && gradientStyles[gradientName], className),
    children
  }));
};
Avatar.displayName = "Avatar";
Avatar.Badge = AvatarBadge;
Avatar.Badge.displayName = "Avatar.Badge";
Avatar.BadgeWithPreset = AvatarBadgeWithPreset;
Avatar.BadgeWithPreset.displayName = "Avatar.BadgeWithPreset";
Avatar.Overlay = ImageBase.Overlay;
Avatar.Overlay.displayName = "Avatar.Overlay";
Avatar.getInitialsFontSize = getInitialsFontSize;

// node_modules/@vkontakte/vkui/dist/components/HorizontalCell/HorizontalCell.js
var stylesSize5 = {
  s: "vkuiHorizontalCell--size-s",
  m: "vkuiHorizontalCell--size-m",
  l: "vkuiHorizontalCell--size-l"
};
var CellTypography = (_param) => {
  var { size: size4, children } = _param, restProps = _object_without_properties(_param, [
    "size",
    "children"
  ]);
  return size4 === "s" ? (0, import_jsx_runtime126.jsx)(Caption, _object_spread_props(_object_spread({}, restProps), {
    children
  })) : (0, import_jsx_runtime126.jsx)(Subhead, _object_spread_props(_object_spread({}, restProps), {
    children
  }));
};
var HorizontalCell = (_param) => {
  var { className, header, style, subtitle, size: size4 = "s", children = (0, import_jsx_runtime126.jsx)(Avatar, {
    size: 56
  }), getRootRef, getRef, extraSubtitle } = _param, restProps = _object_without_properties(_param, [
    "className",
    "header",
    "style",
    "subtitle",
    "size",
    "children",
    "getRootRef",
    "getRef",
    "extraSubtitle"
  ]);
  return (0, import_jsx_runtime126.jsx)("div", {
    ref: getRootRef,
    style,
    className: clsx("vkuiHorizontalCell", stylesSize5[size4], className),
    children: (0, import_jsx_runtime126.jsxs)(Tappable, _object_spread_props(_object_spread({
      className: "vkuiHorizontalCell__body",
      getRootRef: getRef
    }, restProps), {
      children: [
        hasReactNode(children) && (0, import_jsx_runtime126.jsx)("div", {
          className: "vkuiHorizontalCell__image",
          children
        }),
        (header || subtitle || extraSubtitle) && (0, import_jsx_runtime126.jsxs)("div", {
          className: "vkuiHorizontalCell__content",
          children: [
            hasReactNode(header) && (0, import_jsx_runtime126.jsx)(CellTypography, {
              size: size4,
              children: header
            }),
            hasReactNode(subtitle) && (0, import_jsx_runtime126.jsx)(Footnote, {
              className: "vkuiHorizontalCell__subtitle",
              children: subtitle
            }),
            hasReactNode(extraSubtitle) && (0, import_jsx_runtime126.jsx)(Footnote, {
              className: "vkuiHorizontalCell__subtitle",
              children: extraSubtitle
            })
          ]
        })
      ]
    }))
  });
};

// node_modules/@vkontakte/vkui/dist/components/HorizontalScroll/HorizontalCellShowMore/HorizontalCellShowMore.js
var import_jsx_runtime127 = __toESM(require_jsx_runtime());
var sizeClassNames2 = {
  s: "vkuiHorizontalCellShowMore--size-s",
  m: "vkuiHorizontalCellShowMore--size-m",
  l: "vkuiHorizontalCellShowMore--size-l"
};
var HorizontalCellShowMore = (_param) => {
  var { className, style, getRef, getRootRef, compensateLastCellIndent, height, size: size4 = "s", children = size4 === "s" ? "Все" : "Показать все", centered = false } = _param, restProps = _object_without_properties(_param, [
    "className",
    "style",
    "getRef",
    "getRootRef",
    "compensateLastCellIndent",
    "height",
    "size",
    "children",
    "centered"
  ]);
  return (0, import_jsx_runtime127.jsx)("div", {
    style,
    className: clsx("vkuiHorizontalCellShowMore", compensateLastCellIndent && "vkuiHorizontalCellShowMore--compensate-last-cell-indent", centered && "vkuiHorizontalCellShowMore--centered", sizeClassNames2[size4], className),
    ref: getRootRef,
    children: (0, import_jsx_runtime127.jsxs)(Tappable, _object_spread_props(_object_spread({
      style: size4 === "s" ? void 0 : {
        height
      },
      className: "vkuiHorizontalCellShowMore__body",
      getRootRef: getRef,
      activeMode: "opacity",
      hoverMode: "opacity"
    }, restProps), {
      children: [
        (0, import_jsx_runtime127.jsx)(Icon28ChevronRightCircle, {
          className: "vkuiHorizontalCellShowMore__icon",
          fill: "currentColor"
        }),
        (0, import_jsx_runtime127.jsx)(Subhead, {
          className: "vkuiHorizontalCellShowMore__text",
          weight: "2",
          children
        })
      ]
    }))
  });
};

// node_modules/@vkontakte/vkui/dist/components/Footer/Footer.js
var import_jsx_runtime128 = __toESM(require_jsx_runtime());
var React143 = __toESM(require_react());
var Footer = (_param) => {
  var { children, className, Component: Component3 = "footer", role: roleProp } = _param, restProps = _object_without_properties(_param, [
    "children",
    "className",
    "Component",
    "role"
  ]);
  const role = roleProp !== null && roleProp !== void 0 ? roleProp : Component3 === "footer" ? "contentinfo" : void 0;
  return (0, import_jsx_runtime128.jsx)(Footnote, _object_spread_props(_object_spread({
    Component: Component3,
    role
  }, restProps), {
    className: clsx("vkuiFooter", className),
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/InfoRow/InfoRow.js
var import_jsx_runtime129 = __toESM(require_jsx_runtime());
var React144 = __toESM(require_react());
var InfoRow = (_param) => {
  var { header, children, className } = _param, restProps = _object_without_properties(_param, [
    "header",
    "children",
    "className"
  ]);
  return (0, import_jsx_runtime129.jsxs)(Headline, _object_spread_props(_object_spread({}, restProps), {
    Component: "span",
    className: clsx("vkuiInfoRow", className),
    weight: "3",
    children: [
      hasReactNode(header) && (0, import_jsx_runtime129.jsxs)(Subhead, {
        Component: "strong",
        className: "vkuiInfoRow__header",
        children: [
          header,
          (0, import_jsx_runtime129.jsx)(VisuallyHidden, {
            children: " "
          })
        ]
      }),
      children
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Gallery/Gallery.js
var import_jsx_runtime132 = __toESM(require_jsx_runtime());
var React149 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/BaseGallery/BaseGallery.js
var import_jsx_runtime130 = __toESM(require_jsx_runtime());
var React145 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/BaseGallery/helpers.js
var calcMin = ({ containerWidth = 0, layerWidth = 0, slides = [], viewportOffsetWidth = 0, align, isCenterWithCustomWidth }) => {
  switch (align) {
    case "left":
      return containerWidth - layerWidth;
    case "right":
      return viewportOffsetWidth - layerWidth;
    case "center":
      if (isCenterWithCustomWidth && slides.length) {
        const { coordX: coordX2, width } = slides[slides.length - 1];
        return viewportOffsetWidth / 2 - coordX2 - width / 2;
      } else {
        return viewportOffsetWidth - (containerWidth - viewportOffsetWidth) / 2 - layerWidth;
      }
  }
};
var calcMax = ({ slides = [], viewportOffsetWidth = 0, isCenterWithCustomWidth }) => {
  if (isCenterWithCustomWidth && slides.length) {
    const { width, coordX: coordX2 } = slides[0];
    return viewportOffsetWidth / 2 - coordX2 - width / 2;
  }
  return 0;
};

// node_modules/@vkontakte/vkui/dist/components/BaseGallery/BaseGallery.js
var ANIMATION_DURATION = 0.24;
var LAYOUT_DEFAULT_STATE = {
  containerWidth: 0,
  viewportOffsetWidth: 0,
  layerWidth: 0,
  min: 0,
  max: 0,
  slides: [],
  isFullyVisible: true
};
var SHIFT_DEFAULT_STATE = {
  animation: void 0,
  shiftX: 0,
  dragging: false,
  deltaX: 0,
  indent: 0
};
var stylesBullets = {
  dark: "vkuiBaseGallery__bullets--dark",
  light: "vkuiBaseGallery__bullets--light"
};
var BaseGallery = (_param) => {
  var { bullets = false, getRootRef, children, slideWidth = "100%", slideIndex = 0, dragDisabled = false, onDragStart, onDragEnd, onChange, onPrevClick, onNextClick, align = "left", showArrows, getRef, arrowSize = "l" } = _param, restProps = _object_without_properties(_param, [
    "bullets",
    "getRootRef",
    "children",
    "slideWidth",
    "slideIndex",
    "dragDisabled",
    "onDragStart",
    "onDragEnd",
    "onChange",
    "onPrevClick",
    "onNextClick",
    "align",
    "showArrows",
    "getRef",
    "arrowSize"
  ]);
  const slidesStore = React145.useRef({});
  const layoutState = React145.useRef(LAYOUT_DEFAULT_STATE);
  const [shiftState, setShiftState] = React145.useState(SHIFT_DEFAULT_STATE);
  const rootRef = useExternRef(getRootRef);
  const viewportRef = useExternRef(getRef);
  const { window: window2 } = useDOM();
  const hasPointer = useAdaptivityHasPointer();
  const isCenterWithCustomWidth = slideWidth === "custom" && align === "center";
  const validateIndent = (value) => {
    var _layoutState_current_max;
    const localMax = (_layoutState_current_max = layoutState.current.max) !== null && _layoutState_current_max !== void 0 ? _layoutState_current_max : 0;
    var _layoutState_current_min;
    const localMin = (_layoutState_current_min = layoutState.current.min) !== null && _layoutState_current_min !== void 0 ? _layoutState_current_min : 0;
    if (value < localMin) {
      return localMin;
    } else if (value > localMax) {
      return localMax;
    }
    return value;
  };
  const calculateIndent2 = (targetIndex) => {
    var _layoutState_current_slides;
    if (layoutState.current.isFullyVisible) {
      return 0;
    }
    const targetSlide = ((_layoutState_current_slides = layoutState.current.slides) === null || _layoutState_current_slides === void 0 ? void 0 : _layoutState_current_slides.length) ? layoutState.current.slides[targetIndex] : null;
    if (targetSlide) {
      const { coordX: coordX2, width } = targetSlide;
      if (isCenterWithCustomWidth) {
        var _layoutState_current_viewportOffsetWidth;
        const viewportWidth = (_layoutState_current_viewportOffsetWidth = layoutState.current.viewportOffsetWidth) !== null && _layoutState_current_viewportOffsetWidth !== void 0 ? _layoutState_current_viewportOffsetWidth : 0;
        return viewportWidth / 2 - coordX2 - width / 2;
      }
      return validateIndent(-1 * coordX2);
    }
    return 0;
  };
  const calculateDragIndent = () => {
    var _layoutState_current_max;
    const localMax = (_layoutState_current_max = layoutState.current.max) !== null && _layoutState_current_max !== void 0 ? _layoutState_current_max : 0;
    var _layoutState_current_min;
    const localMin = (_layoutState_current_min = layoutState.current.min) !== null && _layoutState_current_min !== void 0 ? _layoutState_current_min : 0;
    const indent2 = shiftState.shiftX + shiftState.deltaX;
    if (indent2 > localMax) {
      return localMax + Number((indent2 - localMax) / 3);
    } else if (indent2 < localMin) {
      return localMin + Number((indent2 - localMin) / 3);
    }
    return indent2;
  };
  const initializeSlides = (options = {}) => {
    var _rootRef_current, _viewportRef_current, _layoutState_current_slides_slideIndex, _localSlides_slideIndex, _localSlides_slideIndex1;
    var _React_Children_map;
    const localSlides = (_React_Children_map = React145.Children.map(children, (_item, i) => {
      const elem = slidesStore.current[`slide-${i}`];
      var _elem_offsetLeft, _elem_offsetWidth;
      return {
        coordX: (_elem_offsetLeft = elem === null || elem === void 0 ? void 0 : elem.offsetLeft) !== null && _elem_offsetLeft !== void 0 ? _elem_offsetLeft : 0,
        width: (_elem_offsetWidth = elem === null || elem === void 0 ? void 0 : elem.offsetWidth) !== null && _elem_offsetWidth !== void 0 ? _elem_offsetWidth : 0
      };
    })) !== null && _React_Children_map !== void 0 ? _React_Children_map : [];
    var _rootRef_current_offsetWidth;
    const localContainerWidth = (_rootRef_current_offsetWidth = (_rootRef_current = rootRef.current) === null || _rootRef_current === void 0 ? void 0 : _rootRef_current.offsetWidth) !== null && _rootRef_current_offsetWidth !== void 0 ? _rootRef_current_offsetWidth : 0;
    var _viewportRef_current_offsetWidth;
    const localViewportOffsetWidth = (_viewportRef_current_offsetWidth = (_viewportRef_current = viewportRef.current) === null || _viewportRef_current === void 0 ? void 0 : _viewportRef_current.offsetWidth) !== null && _viewportRef_current_offsetWidth !== void 0 ? _viewportRef_current_offsetWidth : 0;
    const localLayerWidth = localSlides.reduce((val, slide) => slide.width + val, 0);
    const adjustShiftX = localSlides.length <= layoutState.current.slides.length || ((_layoutState_current_slides_slideIndex = layoutState.current.slides[slideIndex]) === null || _layoutState_current_slides_slideIndex === void 0 ? void 0 : _layoutState_current_slides_slideIndex.coordX) !== ((_localSlides_slideIndex = localSlides[slideIndex]) === null || _localSlides_slideIndex === void 0 ? void 0 : _localSlides_slideIndex.coordX);
    var _localSlides_slideIndex_width;
    const currentSlideOffsetOnCenterAlignment = (localContainerWidth - ((_localSlides_slideIndex_width = (_localSlides_slideIndex1 = localSlides[slideIndex]) === null || _localSlides_slideIndex1 === void 0 ? void 0 : _localSlides_slideIndex1.width) !== null && _localSlides_slideIndex_width !== void 0 ? _localSlides_slideIndex_width : 0)) / 2;
    const isFullyVisible = align === "center" ? localLayerWidth + currentSlideOffsetOnCenterAlignment <= localContainerWidth : localLayerWidth <= localContainerWidth;
    layoutState.current = {
      containerWidth: localContainerWidth,
      viewportOffsetWidth: localViewportOffsetWidth,
      layerWidth: localLayerWidth,
      max: calcMax({
        slides: localSlides,
        viewportOffsetWidth: localViewportOffsetWidth,
        isCenterWithCustomWidth
      }),
      min: calcMin({
        containerWidth: localContainerWidth,
        layerWidth: localLayerWidth,
        slides: localSlides,
        viewportOffsetWidth: localViewportOffsetWidth,
        isCenterWithCustomWidth,
        align
      }),
      slides: localSlides,
      isFullyVisible
    };
    setShiftState((prevState) => {
      var _options_animation;
      return _object_spread_props(_object_spread({}, prevState), {
        shiftX: adjustShiftX ? calculateIndent2(slideIndex) : prevState.shiftX,
        animation: (_options_animation = options.animation) !== null && _options_animation !== void 0 ? _options_animation : prevState.shiftX === validateIndent(prevState.shiftX)
      });
    });
  };
  const onResize = () => {
    if (shiftState.animation !== void 0) {
      initializeSlides({
        animation: false
      });
    }
  };
  useGlobalEventListener(window2, "resize", onResize);
  useIsomorphicLayoutEffect(() => {
    initializeSlides({
      animation: false
    });
  }, [
    children,
    align,
    slideWidth
  ]);
  useIsomorphicLayoutEffect(() => {
    if (shiftState.animation !== void 0) {
      setShiftState((prevState) => _object_spread_props(_object_spread({}, prevState), {
        animation: true,
        deltaX: 0,
        shiftX: calculateIndent2(slideIndex !== null && slideIndex !== void 0 ? slideIndex : 0)
      }));
    }
  }, [
    slideIndex
  ]);
  const slideLeft = (event) => {
    onChange === null || onChange === void 0 ? void 0 : onChange(slideIndex - 1);
    onPrevClick === null || onPrevClick === void 0 ? void 0 : onPrevClick(event);
  };
  const slideRight = (event) => {
    onChange === null || onChange === void 0 ? void 0 : onChange(slideIndex + 1);
    onNextClick === null || onNextClick === void 0 ? void 0 : onNextClick(event);
  };
  const getTarget = (e) => {
    const expectDeltaX = shiftState.deltaX / e.duration * 240 * 0.6;
    var _layoutState_current_max;
    const shift4 = shiftState.shiftX + shiftState.deltaX + expectDeltaX - ((_layoutState_current_max = layoutState.current.max) !== null && _layoutState_current_max !== void 0 ? _layoutState_current_max : 0);
    const direction = shiftState.deltaX < 0 ? 1 : -1;
    let targetIndex = layoutState.current.slides.reduce((val, item, index2) => {
      const previousValue = Math.abs(layoutState.current.slides[val].coordX + shift4);
      const currentValue = Math.abs(item.coordX + shift4);
      return previousValue < currentValue ? val : index2;
    }, slideIndex);
    if (targetIndex === slideIndex) {
      let targetSlide = slideIndex + direction;
      if (targetSlide >= 0 && targetSlide < layoutState.current.slides.length) {
        if (Math.abs(shiftState.deltaX) > layoutState.current.slides[targetSlide].width * 0.05) {
          targetIndex = targetSlide;
        }
      }
    }
    return targetIndex;
  };
  const isDraggable = !dragDisabled && !layoutState.current.isFullyVisible;
  const onStart = (e) => {
    e.originalEvent.stopPropagation();
    if (isDraggable) {
      onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(e);
      setShiftState((prevState) => _object_spread_props(_object_spread({}, prevState), {
        animation: false
      }));
    }
  };
  const onMoveX = (e) => {
    if (isDraggable) {
      e.originalEvent.preventDefault();
      if (e.isSlideX) {
        if (shiftState.deltaX !== e.shiftX) {
          setShiftState((prevState) => _object_spread_props(_object_spread({}, prevState), {
            deltaX: e.shiftX,
            dragging: e.isSlideX
          }));
        }
      }
    }
  };
  const onEnd = (e) => {
    if (isDraggable) {
      const targetIndex = e.isSlide ? getTarget(e) : slideIndex !== null && slideIndex !== void 0 ? slideIndex : 0;
      onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(e, targetIndex);
      const nextShiftState = {
        animation: true,
        dragging: false,
        deltaX: 0
      };
      const shiftXStick = calculateDragIndent();
      if (targetIndex !== slideIndex) {
        nextShiftState.shiftX = shiftXStick;
      }
      setShiftState((prevState) => _object_spread({}, prevState, nextShiftState));
      if (targetIndex !== slideIndex) {
        onChange === null || onChange === void 0 ? void 0 : onChange(targetIndex);
      }
    }
  };
  const indent = shiftState.dragging ? calculateDragIndent() : shiftState.shiftX;
  const layerStyle = {
    transform: `translateX(${indent}px)`,
    transition: shiftState.animation ? `transform ${ANIMATION_DURATION}s cubic-bezier(.1, 0, .25, 1)` : "none"
  };
  const setSlideRef = (slideRef, slideIndex2) => {
    slidesStore.current[`slide-${slideIndex2}`] = slideRef;
  };
  const canSlideLeft = !layoutState.current.isFullyVisible && shiftState.shiftX < 0;
  var _layoutState_current_layerWidth;
  const canSlideRight = !layoutState.current.isFullyVisible && // we can't move right when gallery layer fully scrolled right, if gallery aligned by left side
  (align === "left" && layoutState.current.containerWidth - shiftState.shiftX < ((_layoutState_current_layerWidth = layoutState.current.layerWidth) !== null && _layoutState_current_layerWidth !== void 0 ? _layoutState_current_layerWidth : 0) || // otherwise we need to check current slide index (align = right or align = center)
  align !== "left" && slideIndex < layoutState.current.slides.length - 1);
  return (0, import_jsx_runtime130.jsxs)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiBaseGallery", align === "center" && "vkuiBaseGallery--align-center", slideWidth === "custom" && "vkuiBaseGallery--custom-width", isDraggable && "vkuiBaseGallery--draggable"),
    getRootRef: rootRef,
    children: [
      (0, import_jsx_runtime130.jsx)(Touch, {
        className: "vkuiBaseGallery__viewport",
        onStartX: onStart,
        onMoveX,
        onEnd,
        style: {
          width: slideWidth === "custom" ? "100%" : slideWidth
        },
        getRootRef: viewportRef,
        noSlideClick: true,
        children: (0, import_jsx_runtime130.jsx)("div", {
          className: "vkuiBaseGallery__layer",
          style: layerStyle,
          children: React145.Children.map(children, (item, i) => (0, import_jsx_runtime130.jsx)("div", {
            className: "vkuiBaseGallery__slide",
            ref: (el) => setSlideRef(el, i),
            children: item
          }, `slide-${i}`))
        })
      }),
      bullets && (0, import_jsx_runtime130.jsx)("div", {
        "aria-hidden": true,
        className: clsx("vkuiBaseGallery__bullets", stylesBullets[bullets]),
        children: React145.Children.map(children, (_item, index2) => (0, import_jsx_runtime130.jsx)("div", {
          className: clsx("vkuiBaseGallery__bullet", index2 === slideIndex && "vkuiBaseGallery__bullet--active")
        }, index2))
      }),
      showArrows && hasPointer && canSlideLeft && (0, import_jsx_runtime130.jsx)(ScrollArrow, {
        className: "vkuiBaseGallery__arrow",
        direction: "left",
        onClick: slideLeft,
        size: arrowSize
      }),
      showArrows && hasPointer && canSlideRight && (0, import_jsx_runtime130.jsx)(ScrollArrow, {
        className: "vkuiBaseGallery__arrow",
        direction: "right",
        onClick: slideRight,
        size: arrowSize
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/BaseGallery/CarouselBase/CarouselBase.js
var import_jsx_runtime131 = __toESM(require_jsx_runtime());
var React147 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/BaseGallery/CarouselBase/constants.js
var ANIMATION_DURATION2 = 240;
var SLIDE_THRESHOLD = 0.05;
var CONTROL_ELEMENTS_STATE = {
  canSlideLeft: true,
  canSlideRight: true,
  isDraggable: true
};
var SLIDES_MANAGER_STATE = {
  viewportOffsetWidth: 0,
  slides: [],
  isFullyVisible: true,
  loopPoints: [],
  contentSize: 0,
  snaps: []
};

// node_modules/@vkontakte/vkui/dist/components/BaseGallery/CarouselBase/helpers.js
function calculateIndent(targetIndex, slidesManager, isCenterWithCustomWidth) {
  if (slidesManager.isFullyVisible || !slidesManager.slides.length) {
    return 0;
  }
  const targetSlide = slidesManager.slides[targetIndex];
  if (targetSlide) {
    const { coordX: coordX2, width } = targetSlide;
    if (isCenterWithCustomWidth) {
      return slidesManager.viewportOffsetWidth / 2 - coordX2 - width / 2;
    }
    return -1 * coordX2;
  }
  return 0;
}
function getShiftedIndexes(direction, slides, availableWidth) {
  let gap = availableWidth;
  const shiftedSlideIndexes = [];
  const startIndex = direction === 1 ? 0 : slides.length - 1;
  const endIndex = direction === 1 ? slides.length - 1 : 0;
  for (let i = startIndex; (direction === 1 ? i <= endIndex : i >= endIndex) && gap > 0; i += direction) {
    const slideWidth = slides[i].width;
    if (gap > 0) {
      shiftedSlideIndexes.push(i);
    }
    gap -= slideWidth;
  }
  return shiftedSlideIndexes;
}
function calculateLoopPoints(indexes, edge, slidesManager, containerWidth) {
  const { contentSize, slides, snaps } = slidesManager;
  const isStartEdge = edge === "start";
  const offset4 = isStartEdge ? -contentSize : contentSize;
  return indexes.map((index2) => {
    const initial = isStartEdge ? 0 : -contentSize;
    const altered = isStartEdge ? contentSize : 0;
    const loopPoint = isStartEdge ? snaps[index2] + containerWidth + offset4 : snaps[index2] - slides[index2].width + offset4 - snaps[0];
    return {
      index: index2,
      target: (currentLocation) => {
        return currentLocation >= loopPoint ? initial : altered;
      }
    };
  });
}
function getLoopPoints(slidesManager, containerWidth) {
  const { slides, snaps } = slidesManager;
  const startShiftedIndexes = getShiftedIndexes(-1, slides, snaps[0]);
  const endShiftedIndexes = getShiftedIndexes(1, slides, containerWidth - snaps[0]);
  return [
    ...calculateLoopPoints(endShiftedIndexes, "start", slidesManager, containerWidth),
    ...calculateLoopPoints(startShiftedIndexes, "end", slidesManager, containerWidth)
  ];
}
function getTargetIndex(slides, slideIndex, currentShiftX, currentShiftXDelta) {
  const shift4 = currentShiftX + currentShiftXDelta;
  const direction = currentShiftXDelta < 0 ? 1 : -1;
  let targetIndex = slides.reduce((val, item, index2) => {
    const previousValue = Math.abs(slides[val].coordX + shift4);
    const currentValue = Math.abs(item.coordX + shift4);
    return previousValue < currentValue ? val : index2;
  }, slideIndex);
  if (targetIndex === slideIndex) {
    let targetSlide = slideIndex + direction;
    if (targetSlide >= 0 && targetSlide < slides.length) {
      if (Math.abs(currentShiftXDelta) > slides[targetSlide].width * SLIDE_THRESHOLD) {
        return targetSlide;
      }
      return targetIndex;
    }
    return direction < 0 ? (targetSlide + slides.length) % slides.length : targetSlide % slides.length;
  }
  return targetIndex;
}

// node_modules/@vkontakte/vkui/dist/components/BaseGallery/CarouselBase/hooks.js
var React146 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/animate.js
function animate2({ duration, timing, draw, animationQueue = [] }) {
  if (!canUseDOM) {
    return;
  }
  let start;
  requestAnimationFrame(function animate3(time) {
    if (!start) {
      start = time;
    }
    let timeFraction = Math.min((time - start) / duration, 1);
    const progress = timing(timeFraction);
    draw(progress);
    if (timeFraction < 1) {
      requestAnimationFrame(animate3);
      return;
    }
    animationQueue.shift();
    if (animationQueue.length > 0) {
      animationQueue[0]();
    }
  });
}

// node_modules/@vkontakte/vkui/dist/components/BaseGallery/CarouselBase/hooks.js
var TIMING_FUNCTION = cubicBezier(0.8, 1);
function useSlideAnimation() {
  const animationQueue = React146.useRef([]);
  function getAnimateFunction(drawFunction) {
    return () => {
      animate2({
        duration: ANIMATION_DURATION2,
        timing: TIMING_FUNCTION,
        animationQueue: animationQueue.current,
        draw: drawFunction
      });
    };
  }
  function addToAnimationQueue(func) {
    animationQueue.current.push(func);
  }
  function startAnimation() {
    if (animationQueue.current.length === 1) {
      animationQueue.current[0]();
    }
  }
  return {
    getAnimateFunction,
    addToAnimationQueue,
    startAnimation
  };
}

// node_modules/@vkontakte/vkui/dist/components/BaseGallery/CarouselBase/CarouselBase.js
var stylesBullets2 = {
  dark: "vkuiBaseGallery__bullets--dark",
  light: "vkuiBaseGallery__bullets--light"
};
var warn16 = warnOnce("Gallery");
var CarouselBase = (_param) => {
  var { bullets = false, getRootRef, children, slideWidth = "100%", slideIndex = 0, dragDisabled = false, onDragStart, onDragEnd, onChange, onPrevClick, onNextClick, align = "left", showArrows, getRef, arrowSize = "l" } = _param, restProps = _object_without_properties(_param, [
    "bullets",
    "getRootRef",
    "children",
    "slideWidth",
    "slideIndex",
    "dragDisabled",
    "onDragStart",
    "onDragEnd",
    "onChange",
    "onPrevClick",
    "onNextClick",
    "align",
    "showArrows",
    "getRef",
    "arrowSize"
  ]);
  const slidesStore = React147.useRef({});
  const slidesManager = React147.useRef(SLIDES_MANAGER_STATE);
  const rootRef = useExternRef(getRootRef);
  const viewportRef = useExternRef(getRef);
  const layerRef = React147.useRef(null);
  const animationFrameRef = React147.useRef(null);
  const shiftXCurrentRef = React147.useRef(0);
  const shiftXDeltaRef = React147.useRef(0);
  const initialized = React147.useRef(false);
  const { addToAnimationQueue, getAnimateFunction, startAnimation } = useSlideAnimation();
  const [controlElementsState, setControlElementsState] = React147.useState(CONTROL_ELEMENTS_STATE);
  const { window: window2 } = useDOM();
  const hasPointer = useAdaptivityHasPointer();
  const isCenterWithCustomWidth = slideWidth === "custom" && align === "center";
  const transformCssStyles = (shiftX, animation = false) => {
    slidesManager.current.loopPoints.forEach((loopPoint) => {
      const { target, index: index2 } = loopPoint;
      const slide = slidesStore.current[index2];
      if (slide) {
        slide.style.transform = `translate3d(${target(shiftX)}px, 0, 0)`;
      }
    });
    if (layerRef.current) {
      layerRef.current.style.transform = `translate3d(${shiftX}px, 0, 0)`;
      layerRef.current.style.transition = animation ? `transform ${ANIMATION_DURATION2}ms cubic-bezier(.1, 0, .25, 1)` : "";
    }
  };
  const requestTransform = (shiftX, animation = false) => {
    const { snaps, contentSize, slides } = slidesManager.current;
    if (animationFrameRef.current !== null) {
      cancelAnimationFrame(animationFrameRef.current);
    }
    animationFrameRef.current = requestAnimationFrame(() => {
      if (shiftX > snaps[0]) {
        shiftXCurrentRef.current = -contentSize + snaps[0];
        shiftX = shiftXCurrentRef.current + shiftXDeltaRef.current;
      }
      const lastPoint = slides[slides.length - 1].width + slides[slides.length - 1].coordX;
      if (shiftX <= -lastPoint) {
        shiftXCurrentRef.current = Math.abs(shiftXDeltaRef.current) + snaps[0];
      }
      transformCssStyles(shiftX, animation);
    });
  };
  const initializeSlides = () => {
    if (!rootRef.current || !viewportRef.current) {
      return;
    }
    let localSlides = React147.Children.map(children, (_item, i) => {
      const elem = slidesStore.current[i] || {
        offsetLeft: 0,
        offsetWidth: 0
      };
      return {
        coordX: elem.offsetLeft,
        width: elem.offsetWidth
      };
    }) || [];
    if (localSlides.length === 0) {
      initialized.current = false;
      return;
    }
    const containerWidth = rootRef.current.offsetWidth;
    const viewportOffsetWidth = viewportRef.current.offsetWidth;
    const layerWidth = localSlides.reduce((val, slide) => slide.width + val, 0);
    if (true) {
      let remainingWidth = containerWidth;
      let slideIndex2 = 0;
      while (remainingWidth > 0 && slideIndex2 < localSlides.length) {
        remainingWidth -= localSlides[slideIndex2].width;
        slideIndex2++;
      }
      if (remainingWidth <= 0 && slideIndex2 === localSlides.length) {
        warn16('Ширины слайдов недостаточно для корректной работы свойства "looped". Пожалуйста, сделайте её больше.');
      }
    }
    if (align === "center") {
      const firstSlideShift = (containerWidth - localSlides[0].width) / 2;
      localSlides = localSlides.map((item) => {
        return {
          width: item.width,
          coordX: item.coordX - firstSlideShift
        };
      });
    }
    slidesManager.current = _object_spread_props(_object_spread({}, slidesManager.current), {
      viewportOffsetWidth,
      slides: localSlides,
      isFullyVisible: layerWidth <= containerWidth
    });
    const snaps = localSlides.map((_, index2) => calculateIndent(index2, slidesManager.current, isCenterWithCustomWidth));
    let contentSize = -snaps[snaps.length - 1] + localSlides[localSlides.length - 1].width;
    if (align === "center") {
      contentSize += snaps[0];
    }
    slidesManager.current.snaps = snaps;
    slidesManager.current.contentSize = contentSize;
    slidesManager.current.loopPoints = getLoopPoints(slidesManager.current, containerWidth);
    setControlElementsState({
      canSlideLeft: !slidesManager.current.isFullyVisible,
      canSlideRight: !slidesManager.current.isFullyVisible,
      isDraggable: !(dragDisabled || slidesManager.current.isFullyVisible)
    });
    shiftXCurrentRef.current = snaps[slideIndex];
    initialized.current = true;
    requestTransform(shiftXCurrentRef.current);
  };
  const onResize = () => {
    if (initialized.current) {
      initializeSlides();
    }
  };
  useGlobalEventListener(window2, "resize", onResize);
  useIsomorphicLayoutEffect(function performSlideChange() {
    if (!initialized.current) {
      return;
    }
    const { snaps, slides } = slidesManager.current;
    const indent = snaps[slideIndex];
    let startPoint = shiftXCurrentRef.current;
    if (indent === snaps[0] && shiftXCurrentRef.current <= snaps[snaps.length - 1]) {
      const distance = Math.abs(snaps[snaps.length - 1]) + slides[slides.length - 1].width + startPoint;
      addToAnimationQueue(getAnimateFunction((progress) => {
        const shiftX = startPoint + progress * distance * -1;
        transformCssStyles(shiftX);
        if (shiftX <= snaps[snaps.length - 1] - slides[slides.length - 1].width) {
          requestAnimationFrame(() => {
            shiftXCurrentRef.current = indent;
            transformCssStyles(snaps[0]);
          });
        }
      }));
    } else if (indent === snaps[snaps.length - 1] && shiftXCurrentRef.current === snaps[0]) {
      startPoint = indent - slides[slides.length - 1].width;
      addToAnimationQueue(() => {
        requestAnimationFrame(() => {
          const shiftX = indent - slides[slides.length - 1].width;
          transformCssStyles(shiftX);
          getAnimateFunction((progress) => {
            transformCssStyles(startPoint + progress * slides[slides.length - 1].width);
          })();
        });
      });
    } else {
      addToAnimationQueue(() => {
        const distance = Math.abs(indent - startPoint);
        let direction = startPoint <= indent ? 1 : -1;
        getAnimateFunction((progress) => {
          const shiftX = startPoint + progress * distance * direction;
          transformCssStyles(shiftX);
        })();
      });
    }
    startAnimation();
    shiftXCurrentRef.current = indent;
  }, [
    slideIndex
  ]);
  useMutationObserver(layerRef, initializeSlides);
  useIsomorphicLayoutEffect(initializeSlides, [
    align,
    slideWidth
  ]);
  const calculateMinDeltaXToSlide = () => {
    return slidesManager.current.slides[slideIndex].width * SLIDE_THRESHOLD;
  };
  const slideLeft = (event) => {
    if (slideIndex > 0) {
      shiftXCurrentRef.current += calculateMinDeltaXToSlide();
    }
    onChange === null || onChange === void 0 ? void 0 : onChange((slideIndex - 1 + slidesManager.current.slides.length) % slidesManager.current.slides.length);
    onPrevClick === null || onPrevClick === void 0 ? void 0 : onPrevClick(event);
  };
  const slideRight = (event) => {
    if (slideIndex < slidesManager.current.slides.length - 1) {
      shiftXCurrentRef.current -= calculateMinDeltaXToSlide();
    }
    onChange === null || onChange === void 0 ? void 0 : onChange((slideIndex + 1) % slidesManager.current.slides.length);
    onNextClick === null || onNextClick === void 0 ? void 0 : onNextClick(event);
  };
  const onStart = (e) => {
    e.originalEvent.stopPropagation();
    if (controlElementsState.isDraggable) {
      onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(e);
      shiftXCurrentRef.current = slidesManager.current.snaps[slideIndex];
      shiftXDeltaRef.current = 0;
    }
  };
  const onMoveX = (e) => {
    if (controlElementsState.isDraggable) {
      e.originalEvent.preventDefault();
      if (e.isSlideX) {
        if (shiftXDeltaRef.current !== e.shiftX) {
          shiftXDeltaRef.current = e.shiftX;
          requestTransform(shiftXCurrentRef.current + shiftXDeltaRef.current);
        }
      }
    }
  };
  const onEnd = (e) => {
    if (controlElementsState.isDraggable) {
      let targetIndex = slideIndex;
      if (e.isSlide) {
        targetIndex = getTargetIndex(slidesManager.current.slides, slideIndex, shiftXCurrentRef.current, shiftXDeltaRef.current);
      }
      onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(e, targetIndex);
      if (targetIndex !== slideIndex) {
        shiftXCurrentRef.current = shiftXCurrentRef.current + shiftXDeltaRef.current;
        onChange === null || onChange === void 0 ? void 0 : onChange(targetIndex);
      } else {
        const initialShiftX = slidesManager.current.snaps[targetIndex];
        requestTransform(initialShiftX, true);
      }
    }
  };
  const setSlideRef = (slideRef, slideIndex2) => {
    slidesStore.current[slideIndex2] = slideRef;
  };
  const { canSlideLeft, canSlideRight, isDraggable } = controlElementsState;
  return (0, import_jsx_runtime131.jsxs)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiBaseGallery", slideWidth === "custom" && "vkuiBaseGallery--custom-width", isDraggable && "vkuiBaseGallery--draggable"),
    getRootRef: rootRef,
    children: [
      (0, import_jsx_runtime131.jsx)(Touch, {
        className: "vkuiBaseGallery__viewport",
        onStartX: onStart,
        onMoveX,
        onEnd,
        style: {
          width: slideWidth === "custom" ? "100%" : slideWidth
        },
        getRootRef: viewportRef,
        noSlideClick: true,
        children: (0, import_jsx_runtime131.jsx)("div", {
          className: "vkuiBaseGallery__layer",
          ref: layerRef,
          children: React147.Children.map(children, (item, i) => (0, import_jsx_runtime131.jsx)("div", {
            className: "vkuiBaseGallery__slide",
            ref: (el) => setSlideRef(el, i),
            children: item
          }, `slide-${i}`))
        })
      }),
      bullets && (0, import_jsx_runtime131.jsx)("div", {
        "aria-hidden": true,
        className: clsx("vkuiBaseGallery__bullets", stylesBullets2[bullets]),
        children: React147.Children.map(children, (_item, index2) => (0, import_jsx_runtime131.jsx)("div", {
          className: clsx("vkuiBaseGallery__bullet", index2 === slideIndex && "vkuiBaseGallery__bullet--active")
        }, index2))
      }),
      showArrows && hasPointer && canSlideLeft && (0, import_jsx_runtime131.jsx)(ScrollArrow, {
        className: "vkuiBaseGallery__arrow",
        direction: "left",
        onClick: slideLeft,
        size: arrowSize
      }),
      showArrows && hasPointer && canSlideRight && (0, import_jsx_runtime131.jsx)(ScrollArrow, {
        className: "vkuiBaseGallery__arrow",
        direction: "right",
        onClick: slideRight,
        size: arrowSize
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Gallery/hooks.js
var React148 = __toESM(require_react());
function useAutoPlay({ timeout, slideIndex, onNext }) {
  const { document: document2 } = useDOM();
  const [paused, setPaused] = React148.useState(false);
  const timeoutRef = React148.useRef(null);
  const callbackFn = useStableCallback(onNext);
  const pause = React148.useCallback(() => setPaused(true), []);
  const resume = React148.useCallback(() => setPaused(false), []);
  const clearAutoPlayTimeout = React148.useCallback(() => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
  }, []);
  const startAutoPlayTimeout = React148.useCallback(() => {
    if (!document2 || !timeout || paused) {
      return;
    }
    if (document2.visibilityState === "visible") {
      clearAutoPlayTimeout();
      timeoutRef.current = setTimeout(callbackFn, timeout);
    } else {
      clearAutoPlayTimeout();
    }
  }, [
    document2,
    timeout,
    paused,
    clearAutoPlayTimeout,
    callbackFn
  ]);
  React148.useEffect(function initializeAutoPlay() {
    if (!document2 || !timeout || paused) {
      return;
    }
    startAutoPlayTimeout();
    document2.addEventListener("visibilitychange", startAutoPlayTimeout);
    return () => {
      clearAutoPlayTimeout();
      document2.removeEventListener("visibilitychange", startAutoPlayTimeout);
    };
  }, [
    document2,
    timeout,
    slideIndex,
    startAutoPlayTimeout,
    clearAutoPlayTimeout,
    paused
  ]);
  return {
    resume,
    pause
  };
}

// node_modules/@vkontakte/vkui/dist/components/Gallery/Gallery.js
var Gallery = (_param) => {
  var { initialSlideIndex = 0, children, timeout = 0, onChange, bullets, looped, onDragStart, onDragEnd } = _param, props = _object_without_properties(_param, [
    "initialSlideIndex",
    "children",
    "timeout",
    "onChange",
    "bullets",
    "looped",
    "onDragStart",
    "onDragEnd"
  ]);
  const [localSlideIndex, setSlideIndex] = React149.useState(initialSlideIndex);
  const isControlled = typeof props.slideIndex === "number";
  var _props_slideIndex;
  const slideIndex = isControlled ? (_props_slideIndex = props.slideIndex) !== null && _props_slideIndex !== void 0 ? _props_slideIndex : 0 : localSlideIndex;
  const slides = React149.useMemo(() => React149.Children.toArray(children).filter((item) => Boolean(item)), [
    children
  ]);
  const childCount = slides.length;
  const isClient = useIsClient();
  const handleChange = React149.useCallback((current) => {
    if (current === slideIndex) {
      return;
    }
    !isControlled && setSlideIndex(current);
    onChange && onChange(current);
  }, [
    isControlled,
    onChange,
    slideIndex
  ]);
  const autoPlayControls = useAutoPlay({
    timeout,
    slideIndex,
    onNext: () => handleChange((slideIndex + 1) % childCount)
  });
  const safeSlideIndex = childCount > 0 ? clamp2(slideIndex, 0, childCount - 1) : slideIndex;
  React149.useEffect(() => {
    if (onChange && safeSlideIndex !== slideIndex) {
      onChange(safeSlideIndex);
    }
    setSlideIndex(safeSlideIndex);
  }, [
    onChange,
    safeSlideIndex,
    slideIndex
  ]);
  if (!isClient) {
    return null;
  }
  const Component3 = looped ? CarouselBase : BaseGallery;
  return (0, import_jsx_runtime132.jsx)(Component3, _object_spread_props(_object_spread({
    dragDisabled: isControlled && !onChange
  }, props), {
    onDragStart: callMultiple(onDragStart, autoPlayControls.pause),
    onDragEnd: callMultiple(onDragEnd, autoPlayControls.resume),
    bullets: childCount > 0 && bullets,
    slideIndex: safeSlideIndex,
    onChange: handleChange,
    children: slides
  }));
};

// node_modules/@vkontakte/vkui/dist/components/GridAvatar/GridAvatar.js
var import_jsx_runtime134 = __toESM(require_jsx_runtime());

// node_modules/@vkontakte/vkui/dist/components/GridAvatar/GridAvatarBadge/GridAvatarBadge.js
var import_jsx_runtime133 = __toESM(require_jsx_runtime());
var React150 = __toESM(require_react());
var GridAvatarBadge = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  const { size: size4 } = React150.useContext(ImageBaseContext);
  return (0, import_jsx_runtime133.jsx)(ImageBase.Badge, _object_spread_props(_object_spread({}, restProps), {
    className: clsx("vkuiGridAvatarBadge", size4 < 96 && "vkuiGridAvatarBadge--shifted", className)
  }));
};

// node_modules/@vkontakte/vkui/dist/components/GridAvatar/GridAvatar.js
var GRID_AVATAR_DEFAULT_SIZE = 48;
var MAX_GRID_LENGTH = 4;
var warn17 = warnOnce("GridAvatar");
var GridAvatar = (_param) => {
  var { src = [], size: size4 = GRID_AVATAR_DEFAULT_SIZE, className, children } = _param, restProps = _object_without_properties(_param, [
    "src",
    "size",
    "className",
    "children"
  ]);
  if (true) {
    if (src.length > MAX_GRID_LENGTH) {
      warn17(`Длина массива src (${src.length}) больше максимальной (${MAX_GRID_LENGTH})`, "error");
    }
  }
  return (0, import_jsx_runtime134.jsxs)(ImageBase, _object_spread_props(_object_spread({}, restProps), {
    size: size4,
    className: clsx("vkuiGridAvatar", className),
    children: [
      (0, import_jsx_runtime134.jsx)("div", {
        className: "vkuiGridAvatar__in",
        "aria-hidden": true,
        children: src.map((url, index2) => index2 < MAX_GRID_LENGTH ? (0, import_jsx_runtime134.jsx)("div", {
          className: "vkuiGridAvatar__item",
          style: {
            backgroundImage: `url(${url})`
          }
        }, index2) : null)
      }),
      children
    ]
  }));
};
GridAvatar.Badge = GridAvatarBadge;

// node_modules/@vkontakte/vkui/dist/components/Image/Image.js
var import_jsx_runtime136 = __toESM(require_jsx_runtime());
var React152 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Image/ImageBadge/ImageBadge.js
var import_jsx_runtime135 = __toESM(require_jsx_runtime());
var React151 = __toESM(require_react());
var ImageBadge = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  const { size: size4 } = React151.useContext(ImageBaseContext);
  return (0, import_jsx_runtime135.jsx)(ImageBase.Badge, _object_spread_props(_object_spread({}, restProps), {
    className: clsx("vkuiImageBadge", size4 < 96 && "vkuiImageBadge--shifted", className)
  }));
};
ImageBadge.displayName = "ImageBadge";

// node_modules/@vkontakte/vkui/dist/components/Image/Image.js
var IMAGE_DEFAULT_SIZE = 48;
var getBorderRadiusBySize = (size4, borderRadius) => {
  switch (borderRadius) {
    case "s": {
      if (size4 <= 32) {
        return 2;
      }
      if (size4 <= 56) {
        return 3;
      }
      return 4;
    }
    case "m": {
      if (size4 <= 32) {
        return 3;
      }
      if (size4 <= 48) {
        return 4;
      }
      if (size4 <= 72) {
        return 6;
      }
      if (size4 <= 80) {
        return 8;
      }
      return 10;
    }
    case "l": {
      if (size4 <= 16) {
        return 4;
      }
      if (size4 <= 20) {
        return 5;
      }
      if (size4 <= 32) {
        return 6;
      }
      if (size4 <= 40) {
        return 8;
      }
      if (size4 <= 48) {
        return 10;
      }
      if (size4 <= 56) {
        return 12;
      }
      if (size4 <= 64) {
        return 14;
      }
      return 16;
    }
  }
};
var getBorderRadiusBySizeInPx = (size4, borderRadius) => {
  if (!borderRadius) {
    return void 0;
  }
  return `${getBorderRadiusBySize(size4, borderRadius)}px`;
};
var Image = (_param) => {
  var { size: size4 = IMAGE_DEFAULT_SIZE, borderRadius = "m", borderStartStartRadius, borderStartEndRadius, borderEndStartRadius, borderEndEndRadius, style, className, objectFit = "cover" } = _param, restProps = _object_without_properties(_param, [
    "size",
    "borderRadius",
    "borderStartStartRadius",
    "borderStartEndRadius",
    "borderEndStartRadius",
    "borderEndEndRadius",
    "style",
    "className",
    "objectFit"
  ]);
  const borderStyles = React152.useMemo(() => ({
    "--vkui_internal--Image_border_radius": getBorderRadiusBySizeInPx(size4, borderRadius),
    "--vkui_internal--Image_border_start_start_radius": getBorderRadiusBySizeInPx(size4, borderStartStartRadius),
    "--vkui_internal--Image_border_start_end_radius": getBorderRadiusBySizeInPx(size4, borderStartEndRadius),
    "--vkui_internal--Image_border_end_start_radius": getBorderRadiusBySizeInPx(size4, borderEndStartRadius),
    "--vkui_internal--Image_border_end_end_radius": getBorderRadiusBySizeInPx(size4, borderEndEndRadius)
  }), [
    borderRadius,
    borderStartStartRadius,
    borderStartEndRadius,
    borderEndStartRadius,
    borderEndEndRadius,
    size4
  ]);
  return (0, import_jsx_runtime136.jsx)(ImageBase, _object_spread_props(_object_spread({}, restProps), {
    objectFit,
    size: size4,
    style: _object_spread({}, borderStyles, style),
    className: clsx(className, "vkuiImage", borderStartStartRadius && "vkuiImage--borderStartStartRadius", borderStartEndRadius && "vkuiImage--borderStartEndRadius", borderEndStartRadius && "vkuiImage--borderEndStartRadius", borderEndEndRadius && "vkuiImage--borderEndEndRadius")
  }));
};
Image.displayName = "Image";
Image.Badge = ImageBadge;
Image.Badge.displayName = "Image.Badge";
Image.Overlay = ImageBase.Overlay;
Image.Overlay.displayName = "Image.Overlay";

// node_modules/@vkontakte/vkui/dist/components/Progress/Progress.js
var import_jsx_runtime137 = __toESM(require_jsx_runtime());
var React153 = __toESM(require_react());
var stylesAppearance4 = {
  accent: "vkuiProgress--appearance-accent",
  positive: "vkuiProgress--appearance-positive",
  negative: "vkuiProgress--appearance-negative"
};
function progressCustomHeightStyle(height) {
  return height ? {
    height,
    borderRadius: height / 2
  } : void 0;
}
function progressStyle(height, styleProps) {
  const styleHeight = progressCustomHeightStyle(height);
  const style = styleHeight ? _object_spread({}, styleProps, styleHeight) : styleProps;
  return style;
}
var PROGRESS_MIN_VALUE = 0;
var PROGRESS_MAX_VALUE = 100;
var Progress = (_param) => {
  var { value = 0, appearance = "accent", height, style: styleProps } = _param, restProps = _object_without_properties(_param, [
    "value",
    "appearance",
    "height",
    "style"
  ]);
  const progress = clamp2(value, PROGRESS_MIN_VALUE, PROGRESS_MAX_VALUE);
  const title = `${progress} / ${PROGRESS_MAX_VALUE}`;
  const style = progressStyle(height, styleProps);
  return (0, import_jsx_runtime137.jsx)(RootComponent, _object_spread_props(_object_spread({
    "aria-valuenow": value,
    title,
    style
  }, restProps), {
    role: "progressbar",
    "aria-valuemin": PROGRESS_MIN_VALUE,
    "aria-valuemax": PROGRESS_MAX_VALUE,
    baseClassName: clsx("vkuiProgress", stylesAppearance4[appearance]),
    children: (0, import_jsx_runtime137.jsx)("div", {
      className: "vkuiProgress__in",
      style: {
        width: `${progress}%`
      }
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Search/Search.js
var import_jsx_runtime138 = __toESM(require_jsx_runtime());
var React155 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useBooleanState.js
var React154 = __toESM(require_react());
var useBooleanState = (defaultValue = false) => {
  const [value, setValue] = React154.useState(defaultValue);
  const setTrue = React154.useCallback(() => {
    setValue(true);
  }, []);
  const setFalse = React154.useCallback(() => {
    setValue(false);
  }, []);
  const toggle = React154.useCallback(() => {
    setValue(!value);
  }, [
    value
  ]);
  return {
    value,
    setTrue,
    setFalse,
    toggle
  };
};

// node_modules/@vkontakte/vkui/dist/hooks/useNativeFormResetListener.js
var useNativeFormResetListener = (ref, handler) => {
  useIsomorphicLayoutEffect(() => {
    if (!ref.current) {
      return;
    }
    const formEl = ref.current.closest("form");
    if (!formEl) {
      return;
    }
    formEl.addEventListener("reset", handler);
    return () => {
      formEl.removeEventListener("reset", handler);
    };
  }, [
    ref,
    handler
  ]);
};

// node_modules/@vkontakte/vkui/dist/components/Search/Search.js
var Search = (_param) => {
  var { id: idProp, before = (0, import_jsx_runtime138.jsx)(Icon16SearchOutline, {}), className, placeholder = "Поиск", after = "Отмена", getRef, icon: iconProp, onIconClick, style, autoComplete = "off", onChange, iconLabel, clearLabel = "Очистить", noPadding, getRootRef, findButtonText = "Найти", onFindButtonClick } = _param, inputProps = _object_without_properties(_param, [
    "id",
    "before",
    "className",
    "placeholder",
    "after",
    "getRef",
    "icon",
    "onIconClick",
    "style",
    "autoComplete",
    "onChange",
    "iconLabel",
    "clearLabel",
    "noPadding",
    "getRootRef",
    "findButtonText",
    "onFindButtonClick"
  ]);
  const inputRef = useExternRef(getRef);
  const { value: isFocused, setTrue: setFocusedTrue, setFalse: setFocusedFalse } = useBooleanState(false);
  const generatedId = React155.useId();
  const inputId = idProp ? idProp : `search-${generatedId}`;
  const [hasValue, setHasValue] = React155.useState(() => Boolean(inputProps.value || inputProps.defaultValue));
  const checkHasValue = (e) => setHasValue(Boolean(e.currentTarget.value));
  const { sizeY = "none" } = useAdaptivity();
  const { sizeY: adaptiveSizeY } = useAdaptivityConditionalRender();
  const platform3 = usePlatform();
  const hasAfter = platform3 === "ios" && hasReactNode(after);
  const onFocus = (e) => {
    setFocusedTrue();
    inputProps.onFocus && inputProps.onFocus(e);
  };
  const onBlur = (e) => {
    setFocusedFalse();
    inputProps.onBlur && inputProps.onBlur(e);
  };
  const onCancel = React155.useCallback(() => {
    var _Object_getOwnPropertyDescriptor, _inputRef_current;
    const nativeInputValueSetter = (_Object_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, "value")) === null || _Object_getOwnPropertyDescriptor === void 0 ? void 0 : _Object_getOwnPropertyDescriptor.set;
    nativeInputValueSetter === null || nativeInputValueSetter === void 0 ? void 0 : nativeInputValueSetter.call(inputRef.current, "");
    const ev2 = new Event("input", {
      bubbles: true
    });
    (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : _inputRef_current.dispatchEvent(ev2);
  }, [
    inputRef
  ]);
  const onIconClickStart = React155.useCallback((e) => onIconClick === null || onIconClick === void 0 ? void 0 : onIconClick(e), [
    onIconClick
  ]);
  const onIconCancelClickStart = React155.useCallback((e) => {
    var _inputRef_current;
    e.preventDefault();
    (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : _inputRef_current.focus();
    if (touchEnabled()) {
      onCancel();
    }
  }, [
    inputRef,
    onCancel
  ]);
  useIsomorphicLayoutEffect(() => {
    if (inputProps.value !== void 0) {
      setHasValue(Boolean(inputProps.value));
    }
  }, [
    inputProps.value
  ]);
  useNativeFormResetListener(inputRef, () => {
    setHasValue(Boolean(inputProps.defaultValue));
  });
  const renderIconButton = (icon, props = {}) => (0, import_jsx_runtime138.jsxs)(IconButton, _object_spread_props(_object_spread({
    hoverMode: "opacity",
    onPointerDown: onIconClickStart,
    className: "vkuiSearch__icon",
    onFocus: setFocusedTrue,
    onBlur: setFocusedFalse,
    onClick: noop
  }, props), {
    children: [
      (0, import_jsx_runtime138.jsx)(VisuallyHidden, {
        children: iconLabel
      }),
      icon
    ]
  }));
  return (0, import_jsx_runtime138.jsxs)("div", {
    className: clsx("vkuiInternalSearch", "vkuiSearch", sizeY === "none" && "vkuiSearch--sizeY-none", sizeY === "compact" && "vkuiSearch--sizeY-compact", isFocused && "vkuiSearch--focused", hasValue && "vkuiSearch--has-value", hasAfter && "vkuiSearch--has-after", iconProp && "vkuiSearch--has-icon", inputProps.disabled && "vkuiSearch--disabled", !noPadding && "vkuiSearch--withPadding", className),
    ref: getRootRef,
    style,
    children: [
      (0, import_jsx_runtime138.jsxs)("div", {
        className: "vkuiSearch__field",
        children: [
          (0, import_jsx_runtime138.jsx)("label", {
            htmlFor: inputId,
            className: "vkuiSearch__label",
            children: placeholder
          }),
          (0, import_jsx_runtime138.jsxs)("div", {
            className: "vkuiSearch__input",
            children: [
              before,
              (0, import_jsx_runtime138.jsx)(Headline, _object_spread_props(_object_spread({
                Component: "input",
                type: "search",
                level: "1",
                weight: "3"
              }, inputProps), {
                id: inputId,
                placeholder,
                autoComplete,
                getRootRef: inputRef,
                className: "vkuiSearch__nativeInput",
                onFocus,
                onBlur,
                onChange: callMultiple(onChange, checkHasValue)
              }))
            ]
          }),
          (0, import_jsx_runtime138.jsxs)("div", {
            className: "vkuiSearch__controls",
            children: [
              iconProp && (typeof iconProp === "function" ? iconProp(renderIconButton) : renderIconButton(iconProp)),
              (0, import_jsx_runtime138.jsxs)(IconButton, {
                hoverMode: "opacity",
                onPointerDown: onIconCancelClickStart,
                onClick: onCancel,
                className: "vkuiSearch__icon",
                tabIndex: hasValue ? void 0 : -1,
                disabled: inputProps.disabled,
                children: [
                  (0, import_jsx_runtime138.jsx)(VisuallyHidden, {
                    children: clearLabel
                  }),
                  platform3 === "ios" ? (0, import_jsx_runtime138.jsx)(Icon16Clear, {}) : (0, import_jsx_runtime138.jsx)(Icon24Cancel, {})
                ]
              }),
              adaptiveSizeY.compact && onFindButtonClick && (0, import_jsx_runtime138.jsx)(Button, {
                mode: "primary",
                size: "m",
                className: clsx("vkuiSearch__findButton", adaptiveSizeY.compact.className),
                focusVisibleMode: "inside",
                onClick: onFindButtonClick,
                tabIndex: hasValue ? void 0 : -1,
                children: findButtonText
              })
            ]
          })
        ]
      }),
      hasAfter && (0, import_jsx_runtime138.jsx)("div", {
        className: "vkuiSearch__after",
        children: (0, import_jsx_runtime138.jsx)(Button, {
          mode: "tertiary",
          size: "m",
          focusVisibleMode: "inside",
          hoverMode: "opacity",
          activeMode: "opacity",
          onClick: onCancel,
          onFocus: setFocusedTrue,
          onBlur: setFocusedFalse,
          children: (0, import_jsx_runtime138.jsx)("span", {
            className: "vkuiSearch__afterTextClip",
            children: after
          })
        })
      })
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/Tabs/Tabs.js
var import_jsx_runtime139 = __toESM(require_jsx_runtime());
var React156 = __toESM(require_react());
var TabsModeContext = React156.createContext({
  mode: "default",
  withGaps: false,
  layoutFillMode: "auto",
  withScrollToSelectedTab: false,
  scrollBehaviorToSelectedTab: "nearest"
});
var Tabs = (_param) => {
  var { children, mode = "default", role = "tablist", withScrollToSelectedTab, scrollBehaviorToSelectedTab = "nearest", layoutFillMode = "auto" } = _param, restProps = _object_without_properties(_param, [
    "children",
    "mode",
    "role",
    "withScrollToSelectedTab",
    "scrollBehaviorToSelectedTab",
    "layoutFillMode"
  ]);
  const platform3 = usePlatform();
  const { document: document2 } = useDOM();
  const isTabFlow = role === "tablist";
  const tabsRef = React156.useRef(null);
  const withGaps = mode === "accent" || mode === "secondary";
  const getTabEls = () => {
    if (!tabsRef.current) {
      return [];
    }
    return Array.from(
      // eslint-disable-next-line no-restricted-properties
      tabsRef.current.querySelectorAll("[role=tab]:not([disabled])")
    );
  };
  const handleDocumentKeydown = (event) => {
    if (!document2 || !tabsRef.current || !isTabFlow) {
      return;
    }
    const key = pressedKey(event);
    switch (key) {
      case "ArrowLeft":
      case "ArrowRight":
      case "End":
      case "Home": {
        const tabEls = getTabEls();
        const currentFocusedElIndex = tabEls.findIndex((el) => document2.activeElement === el);
        if (currentFocusedElIndex === -1) {
          return;
        }
        let nextIndex = 0;
        if (key === "Home") {
          nextIndex = 0;
        } else if (key === "End") {
          nextIndex = tabEls.length - 1;
        } else {
          const offset4 = key === "ArrowRight" ? 1 : -1;
          nextIndex = currentFocusedElIndex + offset4;
        }
        const nextTabEl = tabEls[nextIndex];
        if (nextTabEl) {
          event.preventDefault();
          nextTabEl.focus();
        }
        break;
      }
      case "ArrowDown": {
        const tabEls = getTabEls();
        const currentFocusedEl = tabEls.find((el) => document2.activeElement === el);
        if (!currentFocusedEl || currentFocusedEl.getAttribute("aria-selected") !== "true") {
          return;
        }
        const relatedContentElId = currentFocusedEl.getAttribute("aria-controls");
        if (!relatedContentElId) {
          return;
        }
        const relatedContentEl = document2.getElementById(relatedContentElId);
        if (!relatedContentEl) {
          return;
        }
        event.preventDefault();
        relatedContentEl.focus();
        break;
      }
      case "Space":
      case "Enter": {
        const tabEls = getTabEls();
        const currentFocusedEl = tabEls.find((el) => document2.activeElement === el);
        if (currentFocusedEl) {
          currentFocusedEl.click();
        }
      }
    }
  };
  useGlobalEventListener(document2, "keydown", handleDocumentKeydown, {
    capture: true
  });
  return (0, import_jsx_runtime139.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiTabs", "vkuiInternalTabs", platform3 === "vkcom" && "vkuiInternalTabs--vkcom", withGaps && clsx("vkuiTabs--withGaps", "vkuiInternalTabs--withGaps"), mode === "default" && "vkuiTabs--mode-default"),
    role,
    children: (0, import_jsx_runtime139.jsx)("div", {
      className: "vkuiTabs__in",
      ref: tabsRef,
      children: (0, import_jsx_runtime139.jsx)(TabsModeContext.Provider, {
        value: {
          mode,
          withGaps,
          layoutFillMode,
          withScrollToSelectedTab,
          scrollBehaviorToSelectedTab
        },
        children
      })
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/TabsItem/TabsItem.js
var import_jsx_runtime140 = __toESM(require_jsx_runtime());
var React157 = __toESM(require_react());
var sizeYClassNames17 = {
  none: "vkuiTabsItem--sizeY-none",
  compact: "vkuiTabsItem--sizeY-compact"
};
var stylesMode8 = {
  default: "vkuiTabsItem--mode-default",
  accent: "vkuiTabsItem--mode-accent",
  secondary: "vkuiTabsItem--mode-secondary"
};
var fillModeClassNames = {
  stretched: "vkuiTabsItem--stretched",
  shrinked: "vkuiTabsItem--shrinked"
};
var warn18 = warnOnce("TabsItem");
var TabsItem = (_param) => {
  var { before, children, status, after, selected = false, className, role = "tab", tabIndex: tabIndexProp, getRootRef, hoverMode = "vkuiTabsItem--hover", activeMode = "", hovered, activated, hasHover: hasHover2, hasActive = false, focusVisibleMode = "inside" } = _param, restProps = _object_without_properties(_param, [
    "before",
    "children",
    "status",
    "after",
    "selected",
    "className",
    "role",
    "tabIndex",
    "getRootRef",
    "hoverMode",
    "activeMode",
    "hovered",
    "activated",
    "hasHover",
    "hasActive",
    "focusVisibleMode"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const { mode, withGaps, layoutFillMode, scrollBehaviorToSelectedTab, withScrollToSelectedTab } = React157.useContext(TabsModeContext);
  let statusComponent = null;
  const isTabFlow = role === "tab";
  if (hasReactNode(status)) {
    statusComponent = typeof status === "number" ? (0, import_jsx_runtime140.jsxs)(Subhead, {
      Component: "span",
      className: clsx("vkuiTabsItem__status", "vkuiTabsItem__status--count"),
      weight: "2",
      children: [
        (0, import_jsx_runtime140.jsx)(VisuallyHidden, {
          children: " "
        }),
        status
      ]
    }) : (0, import_jsx_runtime140.jsxs)("span", {
      className: "vkuiTabsItem__status",
      children: [
        (0, import_jsx_runtime140.jsx)(VisuallyHidden, {
          children: " "
        }),
        status
      ]
    });
  }
  if (isTabFlow) {
    if (!restProps["aria-controls"]) {
      warn18(`Передайте в "aria-controls" id контролируемого блока`, "warn");
    } else if (!restProps["id"]) {
      warn18(`Передайте "id" компоненту для использования в "aria-labelledby" контролируемого блока`, "warn");
    }
  }
  let tabIndex = tabIndexProp;
  if (isTabFlow && tabIndex === void 0) {
    tabIndex = selected ? 0 : -1;
  }
  const rootRef = useExternRef(getRootRef);
  const prevSelected = usePrevious(selected);
  const isInitialRender = prevSelected === void 0;
  const shouldScrollToSelected = withScrollToSelectedTab && !isInitialRender && prevSelected !== selected && selected;
  const { document: document2 } = useDOM();
  React157.useEffect(function scrollToSelectedItem() {
    if (!shouldScrollToSelected || !rootRef.current || !document2) {
      return;
    }
    const tabDOMRect = rootRef.current.getBoundingClientRect();
    const isTabVerticallyOutsideOfViewport = tabDOMRect.top < 0 || tabDOMRect.bottom > document2.documentElement.clientHeight;
    if (isTabVerticallyOutsideOfViewport) {
      return;
    }
    try {
      rootRef.current.scrollIntoView({
        inline: scrollBehaviorToSelectedTab,
        block: "nearest",
        behavior: "smooth"
      });
    } catch (e) {
    }
  }, [
    rootRef,
    document2,
    shouldScrollToSelected,
    scrollBehaviorToSelectedTab
  ]);
  return (0, import_jsx_runtime140.jsxs)(Tappable, _object_spread_props(_object_spread({}, restProps), {
    getRootRef: rootRef,
    className: clsx("vkuiTabsItem", mode && stylesMode8[mode], selected && "vkuiTabsItem--selected", sizeY !== "regular" && sizeYClassNames17[sizeY], withGaps && "vkuiTabsItem--withGaps", layoutFillMode !== "auto" && fillModeClassNames[layoutFillMode], className),
    hoverMode,
    activeMode,
    hasHover: hasHover2,
    hasActive,
    hovered,
    activated,
    focusVisibleMode,
    role,
    "aria-selected": selected,
    tabIndex,
    children: [
      before && (0, import_jsx_runtime140.jsx)("div", {
        className: "vkuiTabsItem__before",
        children: before
      }),
      (0, import_jsx_runtime140.jsx)(Headline, {
        Component: "span",
        className: "vkuiTabsItem__label",
        level: mode === "default" ? "1" : "2",
        weight: "2",
        children
      }),
      statusComponent,
      after && (0, import_jsx_runtime140.jsx)("div", {
        className: "vkuiTabsItem__after",
        children: after
      }),
      mode === "default" && (0, import_jsx_runtime140.jsx)("div", {
        className: "vkuiTabsItem__underline",
        "aria-hidden": true,
        "data-selected": selected
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/PullToRefresh/PullToRefresh.js
var import_jsx_runtime142 = __toESM(require_jsx_runtime());
var React158 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/PullToRefresh/PullToRefreshSpinner.js
var import_jsx_runtime141 = __toESM(require_jsx_runtime());
function calcStrokeDashOffset(value, radius) {
  const progress = value / 100;
  return 2 * Math.PI * radius * (1 - progress);
}
var PullToRefreshSpinner = (_param) => {
  var { on = true, size: size4 = 24, strokeWidth = 2.5, progress = 0, children = "Пожалуйста, подождите..." } = _param, restProps = _object_without_properties(_param, [
    "on",
    "size",
    "strokeWidth",
    "progress",
    "children"
  ]);
  const radius = 0.5 * size4 - 0.5 * strokeWidth;
  const dasharray = 2 * Math.PI * radius;
  const circleCenter = 0.5 * size4;
  const dashoffset = calcStrokeDashOffset(on ? 80 : progress, radius);
  return (0, import_jsx_runtime141.jsxs)(RootComponent, _object_spread_props(_object_spread({
    baseClassName: clsx("vkuiPullToRefresh__spinner", on && "vkuiPullToRefresh__spinner--on")
  }, restProps), {
    children: [
      on && (0, import_jsx_runtime141.jsx)(VisuallyHidden, {
        children
      }),
      (0, import_jsx_runtime141.jsx)("svg", {
        role: "presentation",
        className: "vkuiPullToRefresh__spinner-self",
        style: {
          width: size4,
          height: size4
        },
        viewBox: `0 0 ${size4} ${size4}`,
        xmlns: "http://www.w3.org/2000/svg",
        children: (0, import_jsx_runtime141.jsx)("g", {
          style: {
            width: size4,
            height: size4,
            transformOrigin: `${circleCenter}px ${circleCenter}px`
          },
          children: (0, import_jsx_runtime141.jsx)("circle", {
            className: "vkuiPullToRefresh__spinner-path",
            fill: "none",
            strokeDasharray: dasharray,
            strokeDashoffset: dashoffset,
            strokeWidth,
            strokeLinecap: "round",
            cx: circleCenter,
            cy: circleCenter,
            r: radius
          })
        })
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/PullToRefresh/PullToRefresh.js
var WAIT_FETCHING_TIMEOUT_MS = 1e3;
function cancelEvent(event) {
  if (!event) {
    return false;
  }
  if ("preventDefault" in event.originalEvent && event.originalEvent.cancelable) {
    event.originalEvent.preventDefault();
  }
  if ("stopPropagation" in event.originalEvent) {
    event.originalEvent.stopPropagation();
  }
  return false;
}
var PullToRefresh = (_param) => {
  var { children, isFetching, onRefresh, className } = _param, restProps = _object_without_properties(_param, [
    "children",
    "isFetching",
    "onRefresh",
    "className"
  ]);
  const platform3 = usePlatform();
  const scroll = useScroll();
  const { window: window2 } = useDOM();
  const prevIsFetching = usePrevious(isFetching);
  const initParams = React158.useMemo(() => ({
    start: platform3 === "ios" ? -10 : -45,
    max: platform3 === "ios" ? 50 : 80,
    maxY: platform3 === "ios" ? 400 : 80,
    refreshing: platform3 === "ios" ? 36 : 50,
    positionMultiplier: platform3 === "ios" ? 0.21 : 1
  }), [
    platform3
  ]);
  const [spinnerY, setSpinnerY] = React158.useState(initParams.start);
  const [watching, setWatching] = React158.useState(false);
  const [refreshing, setRefreshing] = React158.useState(false);
  const [canRefresh, setCanRefresh] = React158.useState(false);
  const [touchDown, setTouchDown] = React158.useState(false);
  const prevTouchDown = usePrevious(touchDown);
  const touchY = React158.useRef(0);
  const [contentShift, setContentShift] = React158.useState(0);
  const [spinnerProgress, setSpinnerProgress] = React158.useState(0);
  const resetRefreshingState = React158.useCallback(() => {
    setWatching(false);
    setCanRefresh(false);
    setRefreshing(false);
    setSpinnerY(initParams.start);
    setSpinnerProgress(0);
    setContentShift(0);
  }, [
    initParams
  ]);
  const onRefreshingFinish = React158.useCallback(() => {
    if (!touchDown) {
      resetRefreshingState();
    }
  }, [
    touchDown,
    resetRefreshingState
  ]);
  const waitFetchingTimeoutId = React158.useRef();
  useIsomorphicLayoutEffect(() => {
    if (prevIsFetching !== void 0 && prevIsFetching && !isFetching) {
      onRefreshingFinish();
    }
  }, [
    prevIsFetching,
    isFetching,
    onRefreshingFinish
  ]);
  useIsomorphicLayoutEffect(() => {
    if (prevIsFetching !== void 0 && !prevIsFetching && isFetching) {
      clearTimeout(waitFetchingTimeoutId.current);
    }
  }, [
    isFetching,
    prevIsFetching
  ]);
  const runRefreshing = React158.useCallback(() => {
    if (!refreshing && onRefresh) {
      clearTimeout(waitFetchingTimeoutId.current);
      waitFetchingTimeoutId.current = setTimeout(onRefreshingFinish, WAIT_FETCHING_TIMEOUT_MS);
      setRefreshing(true);
      setSpinnerY((prevSpinnerY) => platform3 === "ios" ? prevSpinnerY : initParams.refreshing);
      onRefresh();
    }
  }, [
    refreshing,
    onRefresh,
    onRefreshingFinish,
    platform3,
    initParams.refreshing
  ]);
  useIsomorphicLayoutEffect(() => {
    if (prevTouchDown !== void 0 && prevTouchDown && !touchDown) {
      if (!refreshing && canRefresh) {
        runRefreshing();
      } else if (refreshing && !isFetching) {
        resetRefreshingState();
      } else {
        setSpinnerY(refreshing ? initParams.refreshing : initParams.start);
        setSpinnerProgress(0);
        setContentShift(0);
      }
    }
  }, [
    initParams,
    prevIsFetching,
    isFetching,
    onRefreshingFinish,
    prevTouchDown,
    touchDown,
    refreshing,
    canRefresh,
    runRefreshing
  ]);
  useIsomorphicLayoutEffect(function toggleDocumentOverscrollBehavior() {
    return window2 && (watching || refreshing) ? initializeBrowserGesturePreventionEffect(window2) : void 0;
  }, [
    window2,
    watching,
    refreshing
  ]);
  const startYRef = React158.useRef(0);
  const onTouchStart = (event) => {
    if (refreshing) {
      cancelEvent(event);
      return;
    }
    setTouchDown(true);
    startYRef.current = event.startY;
  };
  const iosRefreshStartedRef = React158.useRef(false);
  const onTouchMove = (event) => {
    const { isY, shiftY } = event;
    const { start, max: max3 } = initParams;
    const pageYOffset = scroll === null || scroll === void 0 ? void 0 : scroll.getScroll().y;
    if (watching && touchDown) {
      cancelEvent(event);
      const { positionMultiplier, maxY } = initParams;
      const shift4 = Math.max(0, shiftY - touchY.current);
      const currentY = clamp2(start + shift4 * positionMultiplier, start, maxY);
      const progress = currentY > -10 ? Math.abs((currentY + 10) / max3) * 80 : 0;
      setSpinnerY(currentY);
      setSpinnerProgress(clamp2(progress, 0, 80));
      setCanRefresh(progress > 80);
      setContentShift((currentY + 10) * 2.3);
      const iosCanStartRefreshDuringGesture = platform3 === "ios" && progress > 85 && !refreshing && !iosRefreshStartedRef.current;
      if (iosCanStartRefreshDuringGesture) {
        iosRefreshStartedRef.current = true;
        runRefreshing();
      }
    } else if (isY && pageYOffset === 0 && shiftY > 0 && !refreshing && touchDown) {
      cancelEvent(event);
      touchY.current = shiftY;
      setWatching(true);
      setSpinnerY(start);
      setSpinnerProgress(0);
    }
  };
  const onTouchEnd = () => {
    setWatching(false);
    setTouchDown(false);
    iosRefreshStartedRef.current = false;
  };
  const spinnerTransform = `translate3d(0, ${spinnerY}px, 0)`;
  let contentTransform = "";
  if (platform3 === "ios" && refreshing && !touchDown) {
    contentTransform = "translate3d(0, 100px, 0)";
  } else if (platform3 === "ios" && (contentShift || refreshing)) {
    contentTransform = `translate3d(0, ${contentShift}px, 0)`;
  }
  return (0, import_jsx_runtime142.jsx)(TouchContext_default.Provider, {
    value: true,
    children: (0, import_jsx_runtime142.jsxs)(Touch, _object_spread_props(_object_spread({
      "aria-live": "polite",
      "aria-busy": !!isFetching
    }, restProps), {
      onStart: onTouchStart,
      onMove: onTouchMove,
      onEnd: onTouchEnd,
      className: clsx("vkuiPullToRefresh", platform3 === "ios" && "vkuiPullToRefresh--ios", watching && "vkuiPullToRefresh--watching", refreshing && "vkuiPullToRefresh--refreshing", className),
      children: [
        (0, import_jsx_runtime142.jsx)(FixedLayout, {
          className: "vkuiPullToRefresh__controls",
          useParentWidth: true,
          children: (0, import_jsx_runtime142.jsx)(PullToRefreshSpinner, {
            style: {
              transform: spinnerTransform,
              opacity: watching || refreshing || canRefresh ? 1 : 0
            },
            on: refreshing,
            progress: refreshing ? void 0 : spinnerProgress
          })
        }),
        (0, import_jsx_runtime142.jsx)("div", {
          className: "vkuiPullToRefresh__content",
          style: {
            transform: contentTransform
          },
          children
        })
      ]
    }))
  });
};

// node_modules/@vkontakte/vkui/dist/components/Link/Link.js
var import_jsx_runtime143 = __toESM(require_jsx_runtime());
var Link = (_param) => {
  var { hasVisited, children, className } = _param, restProps = _object_without_properties(_param, [
    "hasVisited",
    "children",
    "className"
  ]);
  return (0, import_jsx_runtime143.jsx)(Tappable, _object_spread_props(_object_spread({
    Component: restProps.href ? "a" : "button"
  }, restProps), {
    className: clsx("vkuiLink", hasVisited && "vkuiLink--has-visited", className),
    hasHover: false,
    activeMode: "opacity",
    hoverMode: "none",
    focusVisibleMode: "outside",
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Mark/Mark.js
var import_jsx_runtime144 = __toESM(require_jsx_runtime());
var React159 = __toESM(require_react());
var Mark = (props) => (0, import_jsx_runtime144.jsx)(RootComponent, _object_spread({
  baseClassName: "vkuiMark",
  Component: "mark"
}, props));

// node_modules/@vkontakte/vkui/dist/components/OnboardingTooltip/OnboardingTooltip.js
var import_jsx_runtime145 = __toESM(require_jsx_runtime());
var React160 = __toESM(require_react());
var warn19 = warnOnce("OnboardingTooltip");
var OnboardingTooltip = (_param) => {
  var { id: idProp, children, shown: shownProp = true, arrowPadding = DEFAULT_ARROW_PADDING, arrowHeight = DEFAULT_ARROW_HEIGHT, offsetByMainAxis = 0, offsetByCrossAxis = 0, arrowOffset = 0, isStaticArrowOffset = false, onClose, placement: placementProp = "bottom-start", maxWidth = TOOLTIP_MAX_WIDTH, style: styleProp, getRootRef, disableArrow = false, onPlacementChange, disableFlipMiddleware = false } = _param, restProps = _object_without_properties(_param, [
    "id",
    "children",
    "shown",
    "arrowPadding",
    "arrowHeight",
    "offsetByMainAxis",
    "offsetByCrossAxis",
    "arrowOffset",
    "isStaticArrowOffset",
    "onClose",
    "placement",
    "maxWidth",
    "style",
    "getRootRef",
    "disableArrow",
    "onPlacementChange",
    "disableFlipMiddleware"
  ]);
  const generatedId = React160.useId();
  const tooltipId = idProp || generatedId;
  const { entering } = useNavTransition();
  const [arrowRef, setArrowRef] = React160.useState(null);
  const [tooltipContainer, setTooltipContainer] = React160.useState(null);
  const [positionStrategy, setPositionStrategy] = React160.useState("absolute");
  const shown = shownProp && tooltipContainer && !entering;
  const { middlewares, strictPlacement } = useFloatingMiddlewaresBootstrap({
    placement: placementProp,
    offsetByMainAxis,
    offsetByCrossAxis,
    arrowRef,
    arrow: !disableArrow,
    arrowHeight,
    arrowPadding,
    disableFlipMiddleware
  });
  const { x: floatingDataX, y: floatingDataY, refs, placement: resolvedPlacement, middlewareData: { arrow: arrowCoords } } = useFloating({
    strategy: positionStrategy,
    placement: strictPlacement,
    middleware: middlewares,
    whileElementsMounted: autoUpdateFloatingElement
  });
  const tooltipRef = useExternRef(getRootRef, refs.setFloating);
  const [childRef, child] = usePatchChildren(children, {
    "aria-describedby": shown ? tooltipId : void 0
  });
  usePlacementChangeCallback(placementProp, resolvedPlacement, onPlacementChange);
  let tooltip = null;
  if (shown) {
    const floatingStyle = convertFloatingDataToReactCSSProperties(positionStrategy, floatingDataX, floatingDataY);
    if (styleProp) {
      Object.assign(floatingStyle, styleProp);
    }
    tooltip = createPortal2((0, import_jsx_runtime145.jsxs)(import_jsx_runtime145.Fragment, {
      children: [
        (0, import_jsx_runtime145.jsx)(TooltipBase, _object_spread_props(_object_spread({}, restProps), {
          id: tooltipId,
          getRootRef: tooltipRef,
          style: floatingStyle,
          maxWidth,
          arrowProps: disableArrow ? void 0 : {
            offset: arrowOffset,
            isStaticOffset: isStaticArrowOffset,
            coords: arrowCoords,
            placement: resolvedPlacement,
            getRootRef: setArrowRef
          }
        })),
        (0, import_jsx_runtime145.jsx)("div", {
          className: "vkuiOnboardingTooltip__overlay",
          onClickCapture: onClose
        })
      ]
    }), tooltipContainer);
  }
  useIsomorphicLayoutEffect(function initialize() {
    const referenceEl = childRef.current;
    if (referenceEl) {
      setTooltipContainer(referenceEl.closest(`[${onboardingTooltipContainerAttr}]`));
      setPositionStrategy(referenceEl.style.position === "fixed" ? "fixed" : "absolute");
      refs.setReference(referenceEl);
    }
  }, [
    childRef
  ]);
  if (true) {
    const multiChildren = React160.Children.count(children) > 1;
    const primitiveChild = hasReactNode(children) && typeof children !== "object";
    (multiChildren || primitiveChild) && warn19([
      "children должен быть одним React элементом, получено",
      multiChildren && "несколько",
      primitiveChild && JSON.stringify(children)
    ].filter(Boolean).join(" "), "error");
    if (refs.reference.current && !tooltipContainer) {
      throw new Error("Use TooltipContainer for Tooltip outside Panel (see docs)");
    }
  }
  return (0, import_jsx_runtime145.jsxs)(React160.Fragment, {
    children: [
      child,
      tooltip
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/Counter/Counter.js
var import_jsx_runtime146 = __toESM(require_jsx_runtime());
var React161 = __toESM(require_react());
var modeClassNames3 = {
  secondary: "vkuiCounter--mode-secondary",
  primary: "vkuiCounter--mode-primary",
  prominent: "vkuiCounter--mode-prominent",
  contrast: "vkuiCounter--mode-contrast",
  inherit: "vkuiCounter--mode-inherit"
};
var sizeClassNames3 = {
  s: "vkuiCounter--size-s",
  m: "vkuiCounter--size-m"
};
var Counter = (_param) => {
  var { mode = "inherit", size: size4 = "m", children, className } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "size",
    "children",
    "className"
  ]);
  if (React161.Children.count(children) === 0) {
    return null;
  }
  const CounterTypography = size4 === "s" ? Caption : Headline;
  const counterLevel = size4 === "s" ? "1" : "2";
  return (0, import_jsx_runtime146.jsx)(CounterTypography, _object_spread_props(_object_spread({}, restProps), {
    Component: "span",
    className: clsx("vkuiInternalCounter", "vkuiCounter", modeClassNames3[mode], sizeClassNames3[size4], className),
    level: counterLevel,
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/UsersStack/UsersStack.js
var import_jsx_runtime147 = __toESM(require_jsx_runtime());
var React162 = __toESM(require_react());
var stylesSize6 = {
  s: "vkuiUsersStack--size-s",
  m: "vkuiUsersStack--size-m",
  l: "vkuiUsersStack--size-l"
};
var stylesDirection4 = {
  "row": "vkuiUsersStack--direction-row",
  "row-reverse": "vkuiUsersStack--direction-row-reverse",
  "column": "vkuiUsersStack--direction-column"
};
function PathElement(_param) {
  var { photoSize, direction } = _param, props = _object_without_properties(_param, [
    "photoSize",
    "direction"
  ]);
  switch (direction) {
    case "circle":
      const radius = photoSize / 2;
      return (0, import_jsx_runtime147.jsx)("circle", _object_spread({
        cx: radius,
        cy: radius,
        r: radius
      }, props));
    case "right":
      switch (photoSize) {
        case 24:
          return (0, import_jsx_runtime147.jsx)("path", _object_spread({
            d: "M22,18.625A12 12 0 0 1 12 24A12 12 0 0 1 12 0A12 12 0 0 1 22 5.375A12 12 0 0 0 22,18.625"
          }, props));
        default:
          return (0, import_jsx_runtime147.jsx)("path", _object_spread({
            d: "M30,23.75A16 16 0 0 1 16 32A16 16 0 0 1 16 0A16 16 0 0 1 30 8.25A16 16 0 0 0 30,23.75"
          }, props));
      }
    default:
      switch (photoSize) {
        case 16:
          return (0, import_jsx_runtime147.jsx)("path", _object_spread({
            d: "M2,13.285A8 8 0 0 0 8 16A8 8 0 0 0 8 0A8 8 0 0 0 2 2.715A8 8 0 0 1 2,13.285"
          }, props));
        case 24:
          return (0, import_jsx_runtime147.jsx)("path", _object_spread({
            d: "M2,18.625A12 12 0 0 0 12 24A12 12 0 0 0 12 0A12 12 0 0 0 2 5.375A12 12 0 0 1 2,18.625"
          }, props));
        default:
          return (0, import_jsx_runtime147.jsx)("path", _object_spread({
            d: "M2,23.75A16 16 0 0 0 16 32A16 16 0 0 0 16 0A16 16 0 0 0 2 8.25A16 16 0 0 1 2,23.75"
          }, props));
      }
  }
}
var photoSizes = {
  s: 16,
  m: 24,
  l: 32
};
var UsersStack = (_param) => {
  var { photos = [], visibleCount = 3, count = Math.max(0, photos.length - visibleCount), size: size4 = "m", children, direction = "row" } = _param, restProps = _object_without_properties(_param, [
    "photos",
    "visibleCount",
    "count",
    "size",
    "children",
    "direction"
  ]);
  const cmpId = React162.useId();
  const canShowOthers = count > 0 && count < 100 && size4 !== "s";
  const CounterTypography = size4 === "l" ? Footnote : Caption;
  const photoSize = photoSizes[size4];
  const directionClip = canShowOthers ? "right" : "left";
  const photosElements = photos.slice(0, visibleCount).map((photo, i) => {
    const direction2 = i === 0 && !canShowOthers ? "circle" : directionClip;
    const id = `UsersStackDefs${cmpId}${i}`;
    const hrefID = `#${id}`;
    const maskID = `UsersStackMask${cmpId}${i}`;
    const isPhotoType = typeof photo === "object";
    const photoSrc = isPhotoType ? photo.src : photo;
    let photoElement = (0, import_jsx_runtime147.jsxs)("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      className: "vkuiUsersStack__photo",
      "aria-hidden": true,
      display: "block",
      children: [
        (0, import_jsx_runtime147.jsx)("defs", {
          children: (0, import_jsx_runtime147.jsx)(PathElement, {
            id,
            direction: direction2,
            photoSize
          })
        }),
        (0, import_jsx_runtime147.jsx)("clipPath", {
          id: maskID,
          children: (0, import_jsx_runtime147.jsx)("use", {
            href: hrefID
          })
        }),
        (0, import_jsx_runtime147.jsxs)("g", {
          clipPath: `url(#${maskID})`,
          children: [
            (0, import_jsx_runtime147.jsx)("use", {
              href: hrefID,
              className: "vkuiUsersStack__fill"
            }),
            (0, import_jsx_runtime147.jsx)("image", {
              href: photoSrc,
              width: photoSize,
              height: photoSize
            }),
            (0, import_jsx_runtime147.jsx)("use", {
              href: hrefID,
              fill: "none",
              stroke: "rgba(0, 0, 0, 0.08)"
            })
          ]
        })
      ]
    });
    if (isPhotoType && photo.renderWrapper) {
      photoElement = photo.renderWrapper({
        "children": photoElement,
        "data-src": photoSrc
      });
    }
    return (0, import_jsx_runtime147.jsx)("div", {
      className: "vkuiUsersStack__photoWrapper",
      children: photoElement
    }, i);
  });
  const othersElement = canShowOthers ? (0, import_jsx_runtime147.jsx)("div", {
    className: "vkuiUsersStack__photoWrapper",
    children: (0, import_jsx_runtime147.jsxs)(CounterTypography, {
      caps: true,
      weight: "1",
      className: clsx("vkuiUsersStack__photo", "vkuiUsersStack__photo--others"),
      children: [
        "+",
        count
      ]
    })
  }) : null;
  return (0, import_jsx_runtime147.jsxs)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiUsersStack", stylesSize6[size4], stylesDirection4[direction]),
    children: [
      (photosElements.length > 0 || othersElement) && (0, import_jsx_runtime147.jsxs)("div", {
        className: "vkuiUsersStack__photos",
        "aria-hidden": true,
        children: [
          photosElements,
          othersElement
        ]
      }),
      hasReactNode(children) && (0, import_jsx_runtime147.jsx)(Footnote, {
        className: "vkuiUsersStack__text",
        children
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Placeholder/Placeholder.js
var import_jsx_runtime148 = __toESM(require_jsx_runtime());
var React163 = __toESM(require_react());
var PlaceholderContainer = (_param) => {
  var { stretched, noPadding = false } = _param, restProps = _object_without_properties(_param, [
    "stretched",
    "noPadding"
  ]);
  return (0, import_jsx_runtime148.jsx)(RootComponent, _object_spread({
    baseClassName: clsx("vkuiPlaceholder", stretched && "vkuiPlaceholder--stretched", !noPadding && "vkuiPlaceholder--withPadding")
  }, restProps));
};
var PlaceholderIcon = (props) => (0, import_jsx_runtime148.jsx)(RootComponent, _object_spread({
  baseClassName: "vkuiPlaceholder__icon"
}, props));
var PlaceholderHeader = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  return (0, import_jsx_runtime148.jsx)(Title, _object_spread({
    level: "2",
    weight: "2",
    className: clsx(className, "vkuiPlaceholder__header")
  }, restProps));
};
var PlaceholderText = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  return (0, import_jsx_runtime148.jsx)(Headline, _object_spread({
    weight: "3",
    className: clsx(className, "vkuiPlaceholder__text")
  }, restProps));
};
var PlaceholderActions = (props) => (0, import_jsx_runtime148.jsx)(RootComponent, _object_spread({
  baseClassName: "vkuiPlaceholder__action"
}, props));
var Placeholder = (_param) => {
  var { icon, header, children, action, noPadding = false } = _param, restProps = _object_without_properties(_param, [
    "icon",
    "header",
    "children",
    "action",
    "noPadding"
  ]);
  return (0, import_jsx_runtime148.jsxs)(PlaceholderContainer, _object_spread_props(_object_spread({
    noPadding
  }, restProps), {
    children: [
      hasReactNode(icon) && (0, import_jsx_runtime148.jsx)(PlaceholderIcon, {
        children: icon
      }),
      hasReactNode(header) && (0, import_jsx_runtime148.jsx)(PlaceholderHeader, {
        children: header
      }),
      hasReactNode(children) && (0, import_jsx_runtime148.jsx)(PlaceholderText, {
        children
      }),
      hasReactNode(action) && (0, import_jsx_runtime148.jsx)(PlaceholderActions, {
        children: action
      })
    ]
  }));
};
Placeholder.Container = PlaceholderContainer;
Placeholder.Icon = PlaceholderIcon;
Placeholder.Header = PlaceholderHeader;
Placeholder.Text = PlaceholderText;
Placeholder.Actions = PlaceholderActions;

// node_modules/@vkontakte/vkui/dist/components/Banner/Banner.js
var import_jsx_runtime149 = __toESM(require_jsx_runtime());
var React164 = __toESM(require_react());
var Banner = (_param) => {
  var { mode = "tint", imageTheme = "dark", size: size4 = "s", before, asideMode, header, subheader, text, children, background, actions, onDismiss, dismissLabel = "Скрыть" } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "imageTheme",
    "size",
    "before",
    "asideMode",
    "header",
    "subheader",
    "text",
    "children",
    "background",
    "actions",
    "onDismiss",
    "dismissLabel"
  ]);
  const platform3 = usePlatform();
  const HeaderTypography = size4 === "m" ? Title : Headline;
  const SubheaderTypography = size4 === "m" ? Text : Subhead;
  const IconDismissIOS = mode === "image" ? Icon24DismissDark : Icon24Dismiss;
  const content = (0, import_jsx_runtime149.jsxs)(import_jsx_runtime149.Fragment, {
    children: [
      mode === "image" && background && (0, import_jsx_runtime149.jsx)("div", {
        "aria-hidden": true,
        className: "vkuiBanner__bg",
        children: background
      }),
      before && (0, import_jsx_runtime149.jsx)("div", {
        className: "vkuiBanner__before",
        children: before
      }),
      (0, import_jsx_runtime149.jsxs)("div", {
        className: "vkuiBanner__content",
        children: [
          hasReactNode(header) && (0, import_jsx_runtime149.jsx)(HeaderTypography, {
            Component: "div",
            weight: "2",
            level: size4 === "m" ? "2" : "1",
            children: header
          }),
          hasReactNode(subheader) && (0, import_jsx_runtime149.jsx)(SubheaderTypography, {
            Component: "div",
            className: "vkuiBanner__subheader",
            children: subheader
          }),
          hasReactNode(text) && (0, import_jsx_runtime149.jsx)(Text, {
            Component: "div",
            className: "vkuiBanner__text",
            children: text
          }),
          hasReactNode(actions) && React164.Children.count(actions) > 0 && (0, import_jsx_runtime149.jsx)("div", {
            className: "vkuiBanner__actions",
            children: actions
          })
        ]
      })
    ]
  });
  return (0, import_jsx_runtime149.jsx)(RootComponent, _object_spread_props(_object_spread({
    Component: "section"
  }, restProps), {
    baseClassName: clsx("vkuiBanner", platform3 === "ios" && "vkuiBanner--ios", mode === "image" && "vkuiBanner--mode-image", size4 === "m" && "vkuiBanner--size-m", mode === "image" && imageTheme === "dark" && "vkuiBanner--inverted"),
    children: asideMode === "expand" ? (0, import_jsx_runtime149.jsxs)(Tappable, {
      className: "vkuiBanner__in",
      activeMode: platform3 === "ios" ? "opacity" : "background",
      onClick: noop,
      children: [
        content,
        (0, import_jsx_runtime149.jsx)("div", {
          className: "vkuiBanner__aside",
          children: (0, import_jsx_runtime149.jsx)(Icon24Chevron, {
            className: "vkuiBanner__expand"
          })
        })
      ]
    }) : (0, import_jsx_runtime149.jsxs)("div", {
      className: "vkuiBanner__in",
      children: [
        content,
        asideMode === "dismiss" && (0, import_jsx_runtime149.jsx)("div", {
          className: "vkuiBanner__aside",
          children: (0, import_jsx_runtime149.jsx)(IconButton, {
            label: dismissLabel,
            className: "vkuiBanner__dismiss",
            onClick: onDismiss,
            hoverMode: "opacity",
            hasActive: false,
            children: platform3 === "ios" ? (0, import_jsx_runtime149.jsx)(IconDismissIOS, {}) : (0, import_jsx_runtime149.jsx)(Icon24Cancel, {})
          })
        })
      ]
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/MiniInfoCell/MiniInfoCell.js
var import_jsx_runtime150 = __toESM(require_jsx_runtime());
var React165 = __toESM(require_react());
var stylesMode9 = {
  add: "vkuiMiniInfoCell--mode-add",
  accent: "vkuiMiniInfoCell--mode-accent",
  more: "vkuiMiniInfoCell--mode-more"
};
var stylesTextWrap = {
  nowrap: "vkuiMiniInfoCell--textWrap-nowrap",
  full: "vkuiMiniInfoCell--textWrap-full",
  short: "vkuiMiniInfoCell--textWrap-short"
};
var MiniInfoCell = (_param) => {
  var { before, after, children, mode = "base", textWrap = "nowrap", expandable = false, className } = _param, restProps = _object_without_properties(_param, [
    "before",
    "after",
    "children",
    "mode",
    "textWrap",
    "expandable",
    "className"
  ]);
  const cellClasses = clsx("vkuiMiniInfoCell", stylesTextWrap[textWrap], mode !== "base" && stylesMode9[mode], className);
  const cellContent = (0, import_jsx_runtime150.jsxs)(React165.Fragment, {
    children: [
      hasReactNode(before) && (0, import_jsx_runtime150.jsx)("span", {
        className: "vkuiMiniInfoCell__before",
        children: before
      }),
      (0, import_jsx_runtime150.jsxs)("div", {
        className: "vkuiMiniInfoCell__middle",
        children: [
          (0, import_jsx_runtime150.jsx)(Paragraph, {
            className: "vkuiMiniInfoCell__content",
            weight: mode === "more" ? "2" : void 0,
            children
          }),
          expandable && (0, import_jsx_runtime150.jsx)(Icon16Chevron, {})
        ]
      }),
      hasReactNode(after) && (0, import_jsx_runtime150.jsx)("span", {
        className: "vkuiMiniInfoCell__after",
        children: after
      })
    ]
  });
  return restProps.onClick ? (0, import_jsx_runtime150.jsx)(Tappable, _object_spread_props(_object_spread({
    Component: "div",
    role: "button"
  }, restProps), {
    className: cellClasses,
    children: cellContent
  })) : (0, import_jsx_runtime150.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: cellClasses,
    children: cellContent
  }));
};

// node_modules/@vkontakte/vkui/dist/components/WriteBar/WriteBar.js
var import_jsx_runtime151 = __toESM(require_jsx_runtime());
var React167 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Textarea/useResizeTextarea.js
var React166 = __toESM(require_react());
function useResizeTextarea(onResize, grow) {
  const elementRef = React166.useRef(null);
  const currentScrollHeight = React166.useRef();
  const resizeElement = React166.useCallback((el) => {
    if (grow && el.offsetParent) {
      el.style.height = "";
      el.style.height = `${el.scrollHeight}px`;
      if (el.scrollHeight !== currentScrollHeight.current && onResize) {
        onResize(el);
        currentScrollHeight.current = el.scrollHeight;
      }
    }
  }, [
    grow,
    onResize
  ]);
  const resize = React166.useCallback(() => {
    const el = elementRef.current;
    if (!el) {
      return;
    }
    resizeElement(el);
  }, [
    elementRef,
    resizeElement
  ]);
  return [
    elementRef,
    resize
  ];
}

// node_modules/@vkontakte/vkui/dist/components/WriteBar/WriteBar.js
var WriteBarTypography = (props) => {
  const platform3 = usePlatform();
  if (platform3 === "ios") {
    return (0, import_jsx_runtime151.jsx)(Title, _object_spread_props(_object_spread({}, props), {
      level: "3",
      weight: "3"
    }));
  }
  return (0, import_jsx_runtime151.jsx)(Headline, _object_spread({
    weight: "3"
  }, props));
};
var WriteBar = (_param) => {
  var { className, style, before, inlineAfter, after, getRootRef, getRef, onHeightChange, shadow = false, onChange } = _param, restProps = _object_without_properties(_param, [
    "className",
    "style",
    "before",
    "inlineAfter",
    "after",
    "getRootRef",
    "getRef",
    "onHeightChange",
    "shadow",
    "onChange"
  ]);
  const platform3 = usePlatform();
  const [refResizeTextarea, resize] = useResizeTextarea(onHeightChange, true);
  const textareaRef = useExternRef(getRef, refResizeTextarea);
  React167.useEffect(resize, [
    resize,
    platform3
  ]);
  return (0, import_jsx_runtime151.jsx)("div", {
    ref: getRootRef,
    className: clsx("vkuiWriteBar", platform3 === "ios" && "vkuiWriteBar--ios", shadow && "vkuiWriteBar--shadow", className),
    style,
    children: (0, import_jsx_runtime151.jsxs)("div", {
      className: "vkuiWriteBar__form",
      children: [
        hasReactNode(before) && (0, import_jsx_runtime151.jsx)("div", {
          className: "vkuiWriteBar__before",
          children: before
        }),
        (0, import_jsx_runtime151.jsxs)("div", {
          className: "vkuiWriteBar__formIn",
          children: [
            (0, import_jsx_runtime151.jsx)(WriteBarTypography, _object_spread_props(_object_spread({}, restProps), {
              Component: "textarea",
              className: "vkuiWriteBar__textarea",
              onChange: callMultiple(onChange, resize),
              getRootRef: textareaRef
            })),
            hasReactNode(inlineAfter) && (0, import_jsx_runtime151.jsx)("div", {
              className: "vkuiWriteBar__inlineAfter",
              children: inlineAfter
            })
          ]
        }),
        hasReactNode(after) && (0, import_jsx_runtime151.jsx)("div", {
          className: "vkuiWriteBar__after",
          children: after
        })
      ]
    })
  });
};

// node_modules/@vkontakte/vkui/dist/components/WriteBarIcon/WriteBarIcon.js
var import_jsx_runtime152 = __toESM(require_jsx_runtime());
var React168 = __toESM(require_react());
var predefinedLabel = {
  attach: "Прикрепить файл",
  send: "Отправить",
  done: "Готово"
};
var warn20 = warnOnce("WriteBarIcon");
var WriteBarIcon = (_param) => {
  var { mode, children, count, className, label: labelProp } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "children",
    "count",
    "className",
    "label"
  ]);
  const platform3 = usePlatform();
  let predefinedIcons;
  switch (mode) {
    case "attach":
      predefinedIcons = {
        IconCompact: platform3 === "ios" ? Icon28AddCircleOutline : Icon24Attach,
        IconRegular: platform3 === "ios" ? Icon28AddCircleOutline : Icon28AttachOutline
      };
      break;
    case "send":
      predefinedIcons = {
        IconCompact: platform3 === "ios" ? Icon48WritebarSend : Icon24Send,
        IconRegular: platform3 === "ios" ? Icon48WritebarSend : Icon28Send
      };
      break;
    case "done":
      predefinedIcons = {
        IconCompact: platform3 === "ios" ? Icon48WritebarDone : Icon24CheckCircleOutline,
        IconRegular: platform3 === "ios" ? Icon48WritebarDone : Icon28CheckCircleOutline
      };
      break;
    default:
      break;
  }
  const label = labelProp !== null && labelProp !== void 0 ? labelProp : mode && predefinedLabel[mode];
  if (true) {
    const isAccessible = hasAccessibleName(_object_spread({
      children: [
        children,
        label
      ]
    }, restProps));
    if (!isAccessible) {
      warn20(COMMON_WARNINGS.a11y["button-name"], "error");
    }
  }
  return (0, import_jsx_runtime152.jsxs)(Tappable, _object_spread_props(_object_spread({}, restProps), {
    Component: "button",
    hasHover: false,
    activeMode: "vkuiWriteBarIcon__active",
    className: clsx("vkuiWriteBarIcon", platform3 === "ios" && "vkuiWriteBarIcon--ios", mode === "send" && "vkuiWriteBarIcon--mode-send", mode === "done" && "vkuiWriteBarIcon--mode-done", className),
    children: [
      (0, import_jsx_runtime152.jsxs)("span", {
        className: "vkuiWriteBarIcon__in",
        children: [
          label && (0, import_jsx_runtime152.jsx)(VisuallyHidden, {
            children: label
          }),
          predefinedIcons ? (0, import_jsx_runtime152.jsx)(AdaptiveIconRenderer, _object_spread({}, predefinedIcons)) : children
        ]
      }),
      hasReactNode(count) && (0, import_jsx_runtime152.jsx)(Counter, {
        className: "vkuiWriteBarIcon__counter",
        size: "s",
        children: count
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/SubnavigationBar/SubnavigationBar.js
var import_jsx_runtime153 = __toESM(require_jsx_runtime());
var React169 = __toESM(require_react());
var defaultScrollToLeft = (x) => x - 240;
var defaultScrollToRight = (x) => x + 240;
var SubnavigationBar = (_param) => {
  var { mode = "overflow", children, showArrows = true, getScrollToLeft = defaultScrollToLeft, getScrollToRight = defaultScrollToRight, scrollAnimationDuration } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "children",
    "showArrows",
    "getScrollToLeft",
    "getScrollToRight",
    "scrollAnimationDuration"
  ]);
  let ScrollWrapper;
  let scrollWrapperProps = {};
  if (mode === "fixed") {
    ScrollWrapper = "div";
  } else {
    ScrollWrapper = HorizontalScroll;
    scrollWrapperProps = {
      showArrows,
      getScrollToLeft,
      getScrollToRight,
      scrollAnimationDuration
    };
  }
  return (0, import_jsx_runtime153.jsx)(RootComponent, _object_spread_props(_object_spread({
    baseClassName: mode === "fixed" && "vkuiSubnavigationBar--mode-fixed"
  }, restProps), {
    children: (0, import_jsx_runtime153.jsx)(ScrollWrapper, _object_spread_props(_object_spread({
      className: "vkuiSubnavigationBar__in"
    }, scrollWrapperProps), {
      children: (0, import_jsx_runtime153.jsx)("ul", {
        className: "vkuiSubnavigationBar__scrollIn",
        children: React169.Children.map(children, (child, idx) => hasReactNode(child) ? (0, import_jsx_runtime153.jsx)("li", {
          className: "vkuiSubnavigationBar__item",
          children: child
        }, idx) : null)
      })
    }))
  }));
};

// node_modules/@vkontakte/vkui/dist/components/SubnavigationButton/SubnavigationButton.js
var import_jsx_runtime154 = __toESM(require_jsx_runtime());
var React170 = __toESM(require_react());
var appearanceStyles = {
  accent: "vkuiSubnavigationButton--appearance-accent",
  neutral: "vkuiSubnavigationButton--appearance-neutral"
};
var modeStyles2 = {
  primary: "vkuiSubnavigationButton--mode-primary",
  outline: "vkuiSubnavigationButton--mode-outline",
  tertiary: "vkuiSubnavigationButton--mode-tertiary"
};
var sizeStyles = {
  s: "vkuiSubnavigationButton--size-s",
  m: "vkuiSubnavigationButton--size-m",
  l: "vkuiSubnavigationButton--size-l"
};
var sizeYClassNames18 = {
  none: "vkuiSubnavigationButton--sizeY-none",
  compact: "vkuiSubnavigationButton--sizeY-compact"
};
var SubnavigationButtonTypography = (_param) => {
  var { textLevel } = _param, restProps = _object_without_properties(_param, [
    "textLevel"
  ]);
  if (textLevel === "1") {
    return (0, import_jsx_runtime154.jsx)(Subhead, _object_spread({}, restProps));
  }
  return (0, import_jsx_runtime154.jsx)(Caption, _object_spread({
    level: textLevel === "2" ? "1" : "2"
  }, restProps));
};
var SubnavigationButton = (_param) => {
  var { mode = "primary", appearance = "accent", size: size4 = "m", selected, textLevel = "1", before, after, expandable, children, className } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "appearance",
    "size",
    "selected",
    "textLevel",
    "before",
    "after",
    "expandable",
    "children",
    "className"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime154.jsx)(Tappable, _object_spread_props(_object_spread({}, restProps), {
    hasActive: false,
    focusVisibleMode: "outside",
    className: clsx("vkuiSubnavigationButton", sizeStyles[size4], modeStyles2[mode], appearanceStyles[appearance], selected && "vkuiSubnavigationButton--selected", sizeY !== "regular" && sizeYClassNames18[sizeY], className),
    children: (0, import_jsx_runtime154.jsxs)("span", {
      className: "vkuiSubnavigationButton__in",
      children: [
        before && (0, import_jsx_runtime154.jsx)("span", {
          className: "vkuiSubnavigationButton__before",
          children: before
        }),
        (0, import_jsx_runtime154.jsx)(SubnavigationButtonTypography, {
          textLevel,
          className: "vkuiSubnavigationButton__label",
          Component: "span",
          children
        }),
        after && (0, import_jsx_runtime154.jsx)("span", {
          className: "vkuiSubnavigationButton__after",
          children: after
        }),
        expandable && (0, import_jsx_runtime154.jsx)(Icon16Dropdown, {
          className: "vkuiSubnavigationButton__expandableIcon"
        })
      ]
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Pagination/Pagination.js
var import_jsx_runtime158 = __toESM(require_jsx_runtime());
var React175 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/usePagination.js
var React171 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/helpers/range.js
function range(from, to, step = 1) {
  const direction = from < to ? 1 : -1;
  const distance = Math.abs(from - to) + 1;
  const arrayLength = Math.ceil(distance / step);
  const arr = Array(arrayLength);
  for (let index2 = 0; index2 < arr.length; index2++) {
    arr[index2] = from + index2 * step * direction;
  }
  return arr;
}
function rangeIncrement(from, to, step = 1) {
  if (from > to) {
    return [];
  }
  return range(from, to, step);
}

// node_modules/@vkontakte/vkui/dist/hooks/usePagination.js
var usePagination = ({ currentPage = 1, siblingCount = 1, boundaryCount = 1, totalPages: endPage = 1 } = {}) => React171.useMemo(() => {
  const startPages = rangeIncrement(1, Math.min(boundaryCount, endPage));
  const endPages = rangeIncrement(Math.max(endPage - boundaryCount + 1, boundaryCount + 1), endPage);
  const lowerBoundaryWhenCurrentPageHigh = endPage - boundaryCount - 1 - 2 * siblingCount;
  const siblingsStart = clamp2(currentPage - siblingCount, boundaryCount + 2, lowerBoundaryWhenCurrentPageHigh);
  const upperBoundaryWhenCurrentPageLow = boundaryCount + 2 + 2 * siblingCount;
  const siblingsEnd = Math.min(Math.max(currentPage + siblingCount, upperBoundaryWhenCurrentPageLow), endPages.length > 0 ? endPages[0] - 2 : endPage - 1);
  const pages = startPages;
  if (siblingsStart > boundaryCount + 2) {
    pages.push("start-ellipsis");
  } else if (boundaryCount + 1 < endPage - boundaryCount) {
    pages.push(boundaryCount + 1);
  }
  pages.push(...rangeIncrement(siblingsStart, siblingsEnd));
  if (siblingsEnd < endPage - boundaryCount - 1) {
    pages.push("end-ellipsis");
  } else if (endPage - boundaryCount > boundaryCount) {
    pages.push(endPage - boundaryCount);
  }
  pages.push(...endPages);
  return pages;
}, [
  currentPage,
  endPage,
  siblingCount,
  boundaryCount
]);

// node_modules/@vkontakte/vkui/dist/components/Pagination/PaginationNavigationButton/PaginationNavigationButton.js
var import_jsx_runtime155 = __toESM(require_jsx_runtime());
var React172 = __toESM(require_react());
var getButtonPropsFromPaginationNavigationButton = (opts) => {
  const icon = opts.style !== "caption" ? (0, import_jsx_runtime155.jsxs)(import_jsx_runtime155.Fragment, {
    children: [
      (0, import_jsx_runtime155.jsx)(VisuallyHidden, {
        children: opts.a11yLabel
      }),
      (0, import_jsx_runtime155.jsx)(opts.Icon, {})
    ]
  }) : null;
  const caption = opts.style === "caption" ? (0, import_jsx_runtime155.jsxs)(import_jsx_runtime155.Fragment, {
    children: [
      (0, import_jsx_runtime155.jsx)(VisuallyHidden, {
        children: opts.a11yLabel
      }),
      (0, import_jsx_runtime155.jsx)("span", {
        "aria-hidden": "true",
        children: opts.caption
      })
    ]
  }) : opts.style !== "icon" ? (0, import_jsx_runtime155.jsx)("span", {
    "aria-hidden": "true",
    children: opts.caption
  }) : null;
  return {
    "size": "l",
    "before": opts.type === "prev" ? icon : null,
    "after": opts.type === "next" ? icon : null,
    "appearance": opts.style === "caption" ? "neutral" : "accent",
    "mode": "tertiary",
    "disabled": opts.disabled,
    "onClick": opts.onClick,
    "children": caption,
    "data-page": opts["data-page"]
  };
};
var PaginationNavigationButton = (_param) => {
  var { renderNavigationButton } = _param, restProps = _object_without_properties(_param, [
    "renderNavigationButton"
  ]);
  const buttonProps = getButtonPropsFromPaginationNavigationButton(restProps);
  if (typeof renderNavigationButton === "function") {
    return renderNavigationButton(buttonProps);
  }
  return (0, import_jsx_runtime155.jsx)(Button, _object_spread({}, buttonProps));
};

// node_modules/@vkontakte/vkui/dist/components/Pagination/PaginationPage/PaginationPageButton.js
var import_jsx_runtime156 = __toESM(require_jsx_runtime());
var React173 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Pagination/utils.js
function getPageLabelDefault(isCurrent) {
  return isCurrent ? `Страница` : `Перейти на страницу`;
}

// node_modules/@vkontakte/vkui/dist/components/Pagination/PaginationPage/usePaginationPageClasses.js
var getPaginationPageClassNames = (opts) => {
  return clsx("vkuiPaginationPage", opts.sizeY == null && "vkuiPaginationPage--sizeY-none", opts.sizeY === "compact" && "vkuiPaginationPage--sizeY-compact", opts.isCurrent && "vkuiPaginationPage--current", opts.disabled && "vkuiPaginationPage--disabled");
};
function usePaginationPageClassNames({ isCurrent, disabled }) {
  const { sizeY } = useAdaptivity();
  return getPaginationPageClassNames({
    isCurrent,
    disabled,
    sizeY
  });
}

// node_modules/@vkontakte/vkui/dist/components/Pagination/PaginationPage/PaginationPageButton.js
var getTappablePropsFromPaginationPage = (opts) => {
  const { isCurrent = false, getPageLabel = getPageLabelDefault, children, className, disabled, sizeY } = opts, restProps = _object_without_properties(opts, [
    "isCurrent",
    "getPageLabel",
    "children",
    "className",
    "disabled",
    "sizeY"
  ]);
  const pageClassNames = getPaginationPageClassNames({
    isCurrent,
    disabled,
    sizeY
  });
  return _object_spread({
    "className": clsx(pageClassNames, className),
    "activeMode": "vkuiPaginationPage--state-active",
    "hoverMode": "vkuiPaginationPage--state-hover",
    "focusVisibleMode": "outside",
    "aria-current": isCurrent ? true : void 0,
    "disabled": disabled,
    "children": (0, import_jsx_runtime156.jsxs)(Text, {
      normalize: false,
      children: [
        (0, import_jsx_runtime156.jsxs)(VisuallyHidden, {
          children: [
            getPageLabel(isCurrent),
            " "
          ]
        }),
        children
      ]
    }),
    "data-page": children
  }, restProps);
};
var PaginationPageButton = (_param) => {
  var { renderPageButton } = _param, restProps = _object_without_properties(_param, [
    "renderPageButton"
  ]);
  const tappableProps = getTappablePropsFromPaginationPage(restProps);
  if (typeof renderPageButton === "function") {
    return renderPageButton(tappableProps);
  }
  return (0, import_jsx_runtime156.jsx)(Tappable, _object_spread({}, tappableProps));
};

// node_modules/@vkontakte/vkui/dist/components/Pagination/PaginationPage/PaginationPageEllipsis.js
var import_jsx_runtime157 = __toESM(require_jsx_runtime());
var React174 = __toESM(require_react());
var PaginationPageEllipsis = (_param) => {
  var { className, disabled } = _param, restProps = _object_without_properties(_param, [
    "className",
    "disabled"
  ]);
  const paginationClassNames = usePaginationPageClassNames({
    isCurrent: false,
    disabled
  });
  return (0, import_jsx_runtime157.jsx)(Text, _object_spread_props(_object_spread({
    className: clsx(paginationClassNames, "vkuiPaginationPage--type-ellipsis", className)
  }, restProps), {
    children: "…"
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Pagination/Pagination.js
var Pagination = (_param) => {
  var { currentPage = 1, siblingCount = 1, boundaryCount = 1, totalPages = 1, disabled, prevButtonCaption = "Назад", nextButtonCaption = "Вперёд", navigationButtonsStyle = "icon", getPageLabel = getPageLabelDefault, navigationLabel = "Навигация по страницам", navigationLabelComponent = "h2", prevButtonLabel = "Перейти на предыдущую страницу", nextButtonLabel = "Перейти на следующую страницу", onChange, renderPageButton, renderNavigationButton } = _param, resetProps2 = _object_without_properties(_param, [
    "currentPage",
    "siblingCount",
    "boundaryCount",
    "totalPages",
    "disabled",
    "prevButtonCaption",
    "nextButtonCaption",
    "navigationButtonsStyle",
    "getPageLabel",
    "navigationLabel",
    "navigationLabelComponent",
    "prevButtonLabel",
    "nextButtonLabel",
    "onChange",
    "renderPageButton",
    "renderNavigationButton"
  ]);
  const pages = usePagination({
    currentPage,
    totalPages,
    siblingCount,
    boundaryCount
  });
  const isFirstPage = currentPage === 1;
  const isLastPage = currentPage === totalPages;
  const prevPage = isFirstPage ? void 0 : currentPage - 1;
  const nextPage = isLastPage ? void 0 : currentPage + 1;
  const handlePrevClick = React175.useCallback((event) => {
    if (onChange && prevPage !== void 0) {
      onChange(prevPage, event);
    }
  }, [
    prevPage,
    onChange
  ]);
  const handleClick = React175.useCallback((event) => {
    const page = event.currentTarget.dataset.page || "1";
    onChange === null || onChange === void 0 ? void 0 : onChange(Number(page), event);
  }, [
    onChange
  ]);
  const handleNextClick = React175.useCallback((event) => {
    if (onChange && nextPage !== void 0) {
      onChange(nextPage, event);
    }
  }, [
    nextPage,
    onChange
  ]);
  const { sizeY } = useAdaptivity();
  const renderPages = React175.useCallback((page) => {
    switch (page) {
      case "start-ellipsis":
      case "end-ellipsis":
        return (0, import_jsx_runtime158.jsx)("li", {
          children: (0, import_jsx_runtime158.jsx)(PaginationPageEllipsis, {
            disabled
          })
        }, page);
      default: {
        const isCurrent = page === currentPage;
        return (0, import_jsx_runtime158.jsx)("li", {
          children: (0, import_jsx_runtime158.jsx)(PaginationPageButton, {
            getPageLabel,
            isCurrent,
            onClick: handleClick,
            disabled,
            sizeY,
            renderPageButton,
            children: page
          })
        }, page);
      }
    }
  }, [
    currentPage,
    disabled,
    getPageLabel,
    handleClick,
    renderPageButton,
    sizeY
  ]);
  return (0, import_jsx_runtime158.jsxs)(RootComponent, _object_spread_props(_object_spread({
    Component: "nav",
    role: "navigation"
  }, resetProps2), {
    children: [
      (0, import_jsx_runtime158.jsx)(VisuallyHidden, {
        Component: navigationLabelComponent,
        children: navigationLabel
      }),
      (0, import_jsx_runtime158.jsxs)("ul", {
        className: "vkuiPagination__list",
        children: [
          (0, import_jsx_runtime158.jsx)("li", {
            className: "vkuiPagination__prevButtonContainer",
            children: (0, import_jsx_runtime158.jsx)(PaginationNavigationButton, {
              type: "prev",
              style: navigationButtonsStyle,
              caption: prevButtonCaption,
              Icon: Icon24ChevronCompactLeft,
              a11yLabel: prevButtonLabel,
              disabled: isFirstPage || disabled,
              onClick: handlePrevClick,
              "data-page": prevPage,
              renderNavigationButton
            })
          }),
          pages.map(renderPages),
          (0, import_jsx_runtime158.jsx)("li", {
            className: "vkuiPagination__nextButtonContainer",
            children: (0, import_jsx_runtime158.jsx)(PaginationNavigationButton, {
              type: "next",
              style: navigationButtonsStyle,
              caption: nextButtonCaption,
              Icon: Icon24ChevronCompactRight,
              a11yLabel: nextButtonLabel,
              disabled: isLastPage || disabled,
              onClick: handleNextClick,
              "data-page": nextPage,
              renderNavigationButton
            })
          })
        ]
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Accordion/Accordion.js
var import_jsx_runtime161 = __toESM(require_jsx_runtime());
var React179 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Accordion/AccordionContent.js
var import_jsx_runtime159 = __toESM(require_jsx_runtime());
var React177 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Accordion/AccordionContext.js
var React176 = __toESM(require_react());
var AccordionContext = React176.createContext({
  labelId: "",
  contentId: "",
  expanded: false,
  onChange: noop
});

// node_modules/@vkontakte/vkui/dist/components/Accordion/AccordionContent.js
var CUSTOM_PROPERTY_ACCORDION_CONTENT_HEIGHT = "--vkui_internal--AccordionContent_height";
var stateClassNames2 = {
  enter: "vkuiAccordionContent__in--enter",
  entering: "vkuiAccordionContent__in--enter",
  entered: "vkuiAccordionContent__in--entered",
  exit: "vkuiAccordionContent__in--exit",
  exiting: "vkuiAccordionContent__in--exit",
  exited: "vkuiAccordionContent__in--exited"
};
var AccordionContent = (_param) => {
  var { getRootRef, getRef, className, children } = _param, restProps = _object_without_properties(_param, [
    "getRootRef",
    "getRef",
    "className",
    "children"
  ]);
  const { expanded, labelId, contentId } = React177.useContext(AccordionContext);
  const inRef = useExternRef(getRef);
  const [animationState, animationHandlers] = useCSSKeyframesAnimationController(expanded ? "enter" : "exit", void 0, true);
  useIsomorphicLayoutEffect(() => {
    const inEl = inRef.current;
    if (!inEl) {
      return;
    }
    switch (animationState) {
      case "enter":
      case "exit":
        inEl.style.setProperty(CUSTOM_PROPERTY_ACCORDION_CONTENT_HEIGHT, `${inEl.scrollHeight}px`);
        break;
      case "entered":
      case "exited":
        inEl.style.removeProperty(CUSTOM_PROPERTY_ACCORDION_CONTENT_HEIGHT);
        break;
    }
  }, [
    animationState,
    inRef
  ]);
  return (0, import_jsx_runtime159.jsx)("div", _object_spread_props(_object_spread({
    ref: getRootRef,
    id: contentId,
    role: "region",
    "aria-labelledby": labelId,
    "aria-hidden": !expanded,
    className: clsx("vkuiAccordionContent", className)
  }, restProps), {
    children: (0, import_jsx_runtime159.jsx)("div", _object_spread_props(_object_spread({
      ref: inRef,
      className: clsx("vkuiAccordionContent__in", stateClassNames2[animationState])
    }, animationHandlers), {
      children
    }))
  }));
};
AccordionContent.displayName = "AccordionContent";

// node_modules/@vkontakte/vkui/dist/components/Accordion/AccordionSummary.js
var import_jsx_runtime160 = __toESM(require_jsx_runtime());
var React178 = __toESM(require_react());
var AccordionSummary = (_param) => {
  var { after, before, ExpandIcon = Icon24ChevronDown, CollapseIcon = Icon24ChevronUp, iconPosition = "after", onClick, children } = _param, restProps = _object_without_properties(_param, [
    "after",
    "before",
    "ExpandIcon",
    "CollapseIcon",
    "iconPosition",
    "onClick",
    "children"
  ]);
  const { expanded, labelId, contentId, onChange } = React178.useContext(AccordionContext);
  const Icon = expanded ? CollapseIcon : ExpandIcon;
  const icon = (
    // Обертка нужна для правильной работы с отступами в SimpleCell
    (0, import_jsx_runtime160.jsx)("span", {
      className: "vkuiIcon",
      children: (0, import_jsx_runtime160.jsx)(Icon, {
        className: "vkuiAccordionSummary__icon"
      })
    })
  );
  const toggle = () => onChange(!expanded);
  return (0, import_jsx_runtime160.jsx)(SimpleCell, _object_spread_props(_object_spread({
    id: labelId,
    "aria-expanded": expanded,
    "aria-controls": contentId,
    onClick: callMultiple(toggle, onClick),
    before: (0, import_jsx_runtime160.jsxs)(import_jsx_runtime160.Fragment, {
      children: [
        iconPosition === "before" && icon,
        before
      ]
    }),
    after: (0, import_jsx_runtime160.jsxs)(import_jsx_runtime160.Fragment, {
      children: [
        after,
        iconPosition === "after" && icon
      ]
    })
  }, restProps), {
    children
  }));
};
AccordionSummary.displayName = "AccordionSummary";

// node_modules/@vkontakte/vkui/dist/components/Accordion/Accordion.js
function useAccordionId(id) {
  const generatedId = React179.useId();
  const labelId = id !== null && id !== void 0 ? id : `Accordion${generatedId}`;
  const contentId = `AccordionContent${id !== null && id !== void 0 ? id : generatedId}`;
  return {
    labelId,
    contentId
  };
}
var Accordion = (_param) => {
  var { id, expanded: expandedProp, defaultExpanded = false, onChange: onChangeProp, children } = _param, restProps = _object_without_properties(_param, [
    "id",
    "expanded",
    "defaultExpanded",
    "onChange",
    "children"
  ]);
  const { labelId, contentId } = useAccordionId(id);
  const [expanded, onChange] = useCustomEnsuredControl({
    value: expandedProp,
    defaultValue: defaultExpanded,
    onChange: onChangeProp,
    disabled: restProps.disabled
  });
  const context = useObjectMemo({
    labelId,
    contentId,
    expanded: expanded || false,
    onChange
  });
  return (0, import_jsx_runtime161.jsx)(AccordionContext.Provider, {
    value: context,
    children
  });
};
Accordion.displayName = "Accordion";
Accordion.Summary = AccordionSummary;
Accordion.Summary.displayName = "Accordion.Summary";
Accordion.Content = AccordionContent;
Accordion.Content.displayName = "Accordion.Content";

// node_modules/@vkontakte/vkui/dist/components/FormItem/FormItem.js
var import_jsx_runtime165 = __toESM(require_jsx_runtime());
var React183 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/FormItem/FormItemTop/FormItemTop.js
var import_jsx_runtime162 = __toESM(require_jsx_runtime());
var FormItemTop = (props) => (0, import_jsx_runtime162.jsx)(RootComponent, _object_spread_props(_object_spread({}, props), {
  baseClassName: "vkuiFormItem__top"
}));
FormItemTop.displayName = "FormItemTop";

// node_modules/@vkontakte/vkui/dist/components/FormItem/FormItemTop/FormItemTopAside.js
var import_jsx_runtime163 = __toESM(require_jsx_runtime());
var React180 = __toESM(require_react());
var FormItemTopAside = (_param) => {
  var { children } = _param, restProps = _object_without_properties(_param, [
    "children"
  ]);
  return (0, import_jsx_runtime163.jsx)(Subhead, _object_spread_props(_object_spread({
    className: "vkuiFormItemTop__aside"
  }, restProps), {
    children
  }));
};
FormItemTopAside.displayName = "FormItemTopAside";

// node_modules/@vkontakte/vkui/dist/components/FormItem/FormItemTop/FormItemTopLabel.js
var import_jsx_runtime164 = __toESM(require_jsx_runtime());
var React182 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/FormItem/context.js
var React181 = __toESM(require_react());
var FormItemContext = React181.createContext({
  required: false,
  topMultiline: false
});

// node_modules/@vkontakte/vkui/dist/components/FormItem/FormItemTop/FormItemTopLabel.js
var FormItemTopLabel = (_param) => {
  var { children, Component: componentProp, htmlFor, multiline } = _param, restProps = _object_without_properties(_param, [
    "children",
    "Component",
    "htmlFor",
    "multiline"
  ]);
  const component2 = componentProp || htmlFor && "label" || "span";
  const { required, topMultiline: multilineContext } = React182.useContext(FormItemContext);
  return (0, import_jsx_runtime164.jsxs)(Subhead, _object_spread_props(_object_spread({
    className: clsx("vkuiFormItemTop__label", (multiline !== null && multiline !== void 0 ? multiline : multilineContext) && "vkuiFormItemTop__label--multiline"),
    Component: component2,
    htmlFor
  }, restProps), {
    children: [
      children,
      required && (0, import_jsx_runtime164.jsx)("span", {
        className: "vkuiFormItemTop__label--required",
        "aria-hidden": true,
        children: "*"
      })
    ]
  }));
};
FormItemTopLabel.displayName = "FormItemTopLabel";

// node_modules/@vkontakte/vkui/dist/components/FormItem/FormItem.js
var sizeYClassNames19 = {
  none: clsx("vkuiFormItem--sizeY-none", "vkuiInternalFormItem--sizeY-none"),
  compact: clsx("vkuiFormItem--sizeY-compact", "vkuiInternalFormItem--sizeY-compact")
};
var stylesStatus = {
  error: clsx("vkuiFormItem--status-error", "vkuiInternalFormItem--status-error"),
  valid: clsx("vkuiFormItem--status-valid", "vkuiInternalFormItem--status-valid")
};
var FormItem = (_param) => {
  var { children, top, topId, topMultiline, topComponent: topComponentProp, bottom, status = "default", removable, onRemove, removePlaceholder = "Удалить", getRootRef, htmlFor, bottomId, noPadding, topNode, required = false } = _param, restProps = _object_without_properties(_param, [
    "children",
    "top",
    "topId",
    "topMultiline",
    "topComponent",
    "bottom",
    "status",
    "removable",
    "onRemove",
    "removePlaceholder",
    "getRootRef",
    "htmlFor",
    "bottomId",
    "noPadding",
    "topNode",
    "required"
  ]);
  const rootEl = useExternRef(getRootRef);
  const { sizeY = "none" } = useAdaptivity();
  const wrappedChildren = (0, import_jsx_runtime165.jsxs)(React183.Fragment, {
    children: [
      hasReactNode(topNode) ? topNode : hasReactNode(top) ? (0, import_jsx_runtime165.jsx)(FormItemTop, {
        children: (0, import_jsx_runtime165.jsx)(FormItemTopLabel, {
          htmlFor,
          Component: topComponentProp,
          multiline: topMultiline,
          id: topId,
          children: top
        })
      }) : null,
      children,
      hasReactNode(bottom) && (0, import_jsx_runtime165.jsx)(Footnote, {
        className: "vkuiFormItem__bottom",
        id: bottomId,
        role: status === "error" ? "alert" : void 0,
        children: bottom
      })
    ]
  });
  const context = useObjectMemo({
    required,
    topMultiline
  });
  return (0, import_jsx_runtime165.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    getRootRef: rootEl,
    baseClassName: clsx("vkuiFormItem", !noPadding && "vkuiFormItem--withPadding", "vkuiInternalFormItem", status !== "default" && stylesStatus[status], sizeY !== "regular" && sizeYClassNames19[sizeY], hasReactNode(top) && clsx("vkuiFormItem--withTop", "vkuiInternalFormItem--withTop"), removable && clsx("vkuiFormItem--removable", "vkuiInternalFormItem--removable")),
    children: (0, import_jsx_runtime165.jsx)(FormItemContext.Provider, {
      value: context,
      children: removable ? (0, import_jsx_runtime165.jsx)(Removable, {
        align: "start",
        onRemove: (e) => {
          if (rootEl === null || rootEl === void 0 ? void 0 : rootEl.current) {
            onRemove === null || onRemove === void 0 ? void 0 : onRemove(e, rootEl.current);
          }
        },
        removePlaceholder,
        indent: removable === "indent",
        children: (0, import_jsx_runtime165.jsx)("div", {
          className: clsx("vkuiFormItem__removable", "vkuiInternalFormItem__removable"),
          children: wrappedChildren
        })
      }) : wrappedChildren
    })
  }));
};
FormItem.displayName = "FormItem";
FormItem.Top = FormItemTop;
FormItem.Top.displayName = "FormItem.Top";
FormItem.TopLabel = FormItemTopLabel;
FormItem.TopLabel.displayName = "FormItem.TopLabel";
FormItem.TopAside = FormItemTopAside;
FormItem.TopAside.displayName = "FormItem.TopAside";

// node_modules/@vkontakte/vkui/dist/components/FormField/FormField.js
var import_jsx_runtime166 = __toESM(require_jsx_runtime());
var React184 = __toESM(require_react());
var sizeYClassNames20 = {
  none: "vkuiFormField--sizeY-none",
  compact: "vkuiFormField--sizeY-compact"
};
var stylesStatus2 = {
  error: "vkuiFormField--status-error",
  valid: "vkuiFormField--status-valid"
};
var iconAlignClassNames = {
  center: void 0,
  start: "vkuiFormField__icon--align-start",
  end: "vkuiFormField__icon--align-end"
};
var renderIcon = (icon, align, className) => {
  return (0, import_jsx_runtime166.jsx)("div", {
    className: "vkuiFormField__iconWrapper",
    children: (0, import_jsx_runtime166.jsx)("span", {
      className: clsx(iconAlignClassNames[align], className),
      children: icon
    })
  });
};
var FormField = (_param) => {
  var { Component: Component3 = "span", status = "default", children, getRootRef, before, after, beforeAlign = "center", afterAlign = "center", disabled, mode = "default", className, maxHeight, style } = _param, restProps = _object_without_properties(_param, [
    "Component",
    "status",
    "children",
    "getRootRef",
    "before",
    "after",
    "beforeAlign",
    "afterAlign",
    "disabled",
    "mode",
    "className",
    "maxHeight",
    "style"
  ]);
  const elRef = useExternRef(getRootRef);
  const { sizeY = "none" } = useAdaptivity();
  const [hover, setHover] = React184.useState(false);
  const focusWithin = useFocusWithin(elRef);
  const focusVisibleClassNames = useFocusVisibleClassName({
    focusVisible: focusWithin,
    mode: "vkuiFormField--focus-visible"
  });
  const handleMouseEnter = (e) => {
    e.stopPropagation();
    setHover(true);
  };
  const handleMouseLeave = (e) => {
    e.stopPropagation();
    setHover(false);
  };
  return (0, import_jsx_runtime166.jsxs)(Component3, _object_spread_props(_object_spread({}, restProps), {
    ref: elRef,
    style: maxHeight !== void 0 ? _object_spread_props(_object_spread({}, style), {
      maxHeight
    }) : style,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    className: clsx("vkuiFormField", mode === "default" && "vkuiFormField--mode-default", status !== "default" && stylesStatus2[status], sizeY !== "regular" && sizeYClassNames20[sizeY], disabled && "vkuiFormField--disabled", !disabled && hover && "vkuiFormField--hover", focusVisibleClassNames, className),
    children: [
      (0, import_jsx_runtime166.jsxs)("div", {
        className: "vkuiFormField_scrollContainer",
        children: [
          before && renderIcon(before, beforeAlign, "vkuiFormField__before"),
          (0, import_jsx_runtime166.jsx)("div", {
            className: "vkuiFormField__content",
            children
          }),
          after && renderIcon(after, afterAlign, clsx("vkuiFormField__after", "vkuiInternalFormField__after"))
        ]
      }),
      (0, import_jsx_runtime166.jsx)("span", {
        "aria-hidden": true,
        className: "vkuiFormField__border"
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/FormLayoutGroup/FormLayoutGroup.js
var import_jsx_runtime167 = __toESM(require_jsx_runtime());
var React185 = __toESM(require_react());
var sizeYClassNames21 = {
  none: clsx("vkuiFormLayoutGroup--sizeY-none", "vkuiInternalFormLayoutGroup--sizeY-none"),
  compact: clsx("vkuiFormLayoutGroup--sizeY-compact", "vkuiInternalFormLayoutGroup--sizeY-compact")
};
var FormLayoutGroup = (_param) => {
  var { children, mode = "vertical", removable, segmented, removePlaceholder = "Удалить", onRemove, getRootRef } = _param, restProps = _object_without_properties(_param, [
    "children",
    "mode",
    "removable",
    "segmented",
    "removePlaceholder",
    "onRemove",
    "getRootRef"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const isRemovable = removable && mode === "horizontal";
  const rootEl = useExternRef(getRootRef);
  return (0, import_jsx_runtime167.jsx)(RootComponent, _object_spread_props(_object_spread({
    getRootRef: rootEl,
    Component: "fieldset",
    baseClassName: clsx("vkuiFormLayoutGroup", sizeY !== "regular" && sizeYClassNames21[sizeY], mode === "horizontal" && clsx("vkuiFormLayoutGroup--mode-horizontal", "vkuiInternalFormLayoutGroup--mode-horizontal"), mode === "vertical" && "vkuiInternalFormLayoutGroup--mode-vertical", isRemovable && clsx("vkuiFormLayoutGroup--removable", "vkuiInternalFormLayoutGroup--removable"), segmented && clsx("vkuiFormLayoutGroup--segmented", "vkuiInternalFormLayoutGroup--segmented"))
  }, restProps), {
    children: isRemovable ? (0, import_jsx_runtime167.jsx)(Removable, {
      className: "vkuiFormLayoutGroup__removable",
      align: "start",
      removePlaceholder,
      onRemove: (e) => {
        if (rootEl === null || rootEl === void 0 ? void 0 : rootEl.current) {
          onRemove === null || onRemove === void 0 ? void 0 : onRemove(e, rootEl.current);
        }
      },
      indent: removable === "indent",
      children
    }) : (0, import_jsx_runtime167.jsxs)(React185.Fragment, {
      children: [
        children,
        (0, import_jsx_runtime167.jsx)("span", {
          className: "vkuiFormLayoutGroup__offset",
          "aria-hidden": true
        })
      ]
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/FormStatus/FormStatus.js
var import_jsx_runtime168 = __toESM(require_jsx_runtime());
var React186 = __toESM(require_react());
var FormStatus = (_param) => {
  var { mode, children, className, role = mode === "error" ? "alert" : "status" } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "children",
    "className",
    "role"
  ]);
  return (0, import_jsx_runtime168.jsx)(Banner, _object_spread_props(_object_spread({}, restProps), {
    role,
    subheader: children,
    className: clsx("vkuiInternalFormStatus", mode === "error" && clsx("vkuiFormStatus--mode-error", "vkuiInternalFormStatus--mode-error"), className)
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Switch/Switch.js
var import_jsx_runtime169 = __toESM(require_jsx_runtime());
var React187 = __toESM(require_react());
var sizeYClassNames22 = {
  none: "vkuiSwitch--sizeY-none",
  compact: "vkuiSwitch--sizeY-compact"
};
var Switch = (_param) => {
  var { style, className, getRootRef, getRef, checked: checkedProp, disabled, onBlur: onBlurProp, onFocus: onFocusProp, onClick } = _param, restProps = _object_without_properties(_param, [
    "style",
    "className",
    "getRootRef",
    "getRef",
    "checked",
    "disabled",
    "onBlur",
    "onFocus",
    "onClick"
  ]);
  const platform3 = usePlatform();
  const { sizeY = "none" } = useAdaptivity();
  const { focusVisible, onBlur, onFocus } = useFocusVisible();
  const focusVisibleClassNames = useFocusVisibleClassName({
    focusVisible,
    mode: "outside"
  });
  const handleBlur = callMultiple(onBlur, onBlurProp);
  const handleFocus = callMultiple(onFocus, onFocusProp);
  const [localUncontrolledChecked, setLocalUncontrolledChecked] = React187.useState(Boolean(restProps.defaultChecked));
  const isControlled = checkedProp !== void 0;
  const syncUncontrolledCheckedStateOnClick = React187.useCallback((e) => {
    if (isControlled) {
      return;
    }
    const switchTarget = e.target;
    setLocalUncontrolledChecked(switchTarget.checked);
  }, [
    isControlled
  ]);
  const inputProps = _object_spread_props(_object_spread({}, restProps), {
    Component: "input",
    getRootRef: getRef,
    type: "checkbox",
    role: "switch",
    disabled,
    onBlur: onBlurProp,
    onFocus: onFocusProp,
    onClick: callMultiple(syncUncontrolledCheckedStateOnClick, onClick)
  });
  if (isControlled) {
    inputProps.checked = checkedProp;
    inputProps["aria-checked"] = checkedProp ? "true" : "false";
  } else {
    inputProps["aria-checked"] = localUncontrolledChecked ? "true" : "false";
  }
  return (0, import_jsx_runtime169.jsxs)("label", {
    className: clsx("vkuiSwitch", sizeY !== "regular" && sizeYClassNames22[sizeY], platform3 === "ios" ? "vkuiSwitch--ios" : "vkuiSwitch--default", disabled && "vkuiSwitch--disabled", focusVisibleClassNames, className),
    style,
    ref: getRootRef,
    children: [
      (0, import_jsx_runtime169.jsx)(VisuallyHidden, _object_spread_props(_object_spread({}, inputProps), {
        className: "vkuiSwitch__inputNative",
        onBlur: handleBlur,
        onFocus: handleFocus
      })),
      (0, import_jsx_runtime169.jsxs)("span", {
        "aria-hidden": true,
        className: "vkuiSwitch__inputFake",
        children: [
          (0, import_jsx_runtime169.jsx)("span", {
            className: "vkuiSwitch__track"
          }),
          (0, import_jsx_runtime169.jsx)("span", {
            "aria-hidden": true,
            className: clsx("vkuiSwitch__handle", platform3 !== "ios" && !disabled && "vkuiSwitch__handle--withRipple")
          })
        ]
      })
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/File/File.js
var import_jsx_runtime170 = __toESM(require_jsx_runtime());
var React188 = __toESM(require_react());
var File = (_param) => {
  var { children = "Выберите файл", align = "left", size: size4, mode, stretched, before, after, loading, className, style, getRef, getRootRef, appearance } = _param, restProps = _object_without_properties(_param, [
    "children",
    "align",
    "size",
    "mode",
    "stretched",
    "before",
    "after",
    "loading",
    "className",
    "style",
    "getRef",
    "getRootRef",
    "appearance"
  ]);
  return (0, import_jsx_runtime170.jsxs)(Button, {
    Component: "label",
    align,
    className,
    stretched,
    mode,
    appearance,
    size: size4,
    before,
    after,
    loading,
    style,
    getRootRef,
    disabled: restProps.disabled,
    children: [
      (0, import_jsx_runtime170.jsx)(VisuallyHidden, _object_spread_props(_object_spread({
        title: ""
      }, restProps), {
        Component: "input",
        type: "file",
        getRootRef: getRef
      })),
      children
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/DropZone/DropZone.js
var import_jsx_runtime172 = __toESM(require_jsx_runtime());
var React189 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/DropZone/components/DropZoneGrid.js
var import_jsx_runtime171 = __toESM(require_jsx_runtime());
var directionStyle = {
  row: "vkuiDropZoneGrid--row",
  column: "vkuiDropZoneGrid--column"
};
var DropZoneGrid = (_param) => {
  var { direction = "column" } = _param, props = _object_without_properties(_param, [
    "direction"
  ]);
  return (0, import_jsx_runtime171.jsx)(RootComponent, _object_spread({
    baseClassName: clsx("vkuiDropZoneGrid", directionStyle[direction])
  }, props));
};
DropZoneGrid.displayName = "DropZoneGrid";

// node_modules/@vkontakte/vkui/dist/components/DropZone/DropZone.js
var DropZone = (_param) => {
  var { onDragOver, onDragLeave, onDrop, children } = _param, props = _object_without_properties(_param, [
    "onDragOver",
    "onDragLeave",
    "onDrop",
    "children"
  ]);
  const [active, setActive] = React189.useState(false);
  const onActive = (event) => {
    if (event.isPropagationStopped()) {
      return;
    }
    setActive(true);
  };
  const offActive = () => {
    setActive(false);
  };
  return (0, import_jsx_runtime172.jsx)(RootComponent, _object_spread_props(_object_spread({
    baseClassName: clsx("vkuiDropZone", active && "vkuiDropZone--active"),
    onDragOver: callMultiple(onDragOver, onActive),
    onDragLeave: callMultiple(onDragLeave, offActive),
    onDrop: callMultiple(onDrop, offActive)
  }, props), {
    children: typeof children === "function" ? children({
      active
    }) : children
  }));
};
DropZone.displayName = "DropZone";
DropZone.Grid = DropZoneGrid;
DropZone.Grid.displayName = "DropZone.Grid";

// node_modules/@vkontakte/vkui/dist/components/Input/Input.js
var import_jsx_runtime173 = __toESM(require_jsx_runtime());
var React190 = __toESM(require_react());
var sizeYClassNames23 = {
  none: "vkuiInput--sizeY-none",
  compact: "vkuiInput--sizeY-compact"
};
var Input = (_param) => {
  var { type = "text", align = "left", getRef, className, getRootRef, style, before, after, status, mode } = _param, restProps = _object_without_properties(_param, [
    "type",
    "align",
    "getRef",
    "className",
    "getRootRef",
    "style",
    "before",
    "after",
    "status",
    "mode"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime173.jsx)(FormField, {
    style,
    className: clsx("vkuiInput", align === "right" && "vkuiInput--align-right", align === "center" && "vkuiInput--align-center", sizeY !== "regular" && sizeYClassNames23[sizeY], before && "vkuiInput--hasBefore", after && "vkuiInput--hasAfter", className),
    getRootRef,
    before,
    after,
    disabled: restProps.disabled,
    mode,
    status,
    children: (0, import_jsx_runtime173.jsx)(UnstyledTextField, _object_spread_props(_object_spread({}, restProps), {
      as: "input",
      type,
      className: "vkuiInput__el",
      getRootRef: getRef
    }))
  });
};

// node_modules/@vkontakte/vkui/dist/components/ChipsInputBase/Chip/Chip.js
var import_jsx_runtime174 = __toESM(require_jsx_runtime());
var React191 = __toESM(require_react());
var sizeYClassNames24 = {
  none: "vkuiChip--sizeY-none",
  compact: "vkuiChip--sizeY-compact"
};
var Chip = (_param) => {
  var { Component: Component3 = "span", value = "", removable = true, onRemove, removeLabel = "Удалить", before, after, disabled, readOnly, children, className, onFocus: onFocusProp, onBlur: onBlurProp } = _param, restProps = _object_without_properties(_param, [
    "Component",
    "value",
    "removable",
    "onRemove",
    "removeLabel",
    "before",
    "after",
    "disabled",
    "readOnly",
    "children",
    "className",
    "onFocus",
    "onBlur"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const { focusVisible, onFocus, onBlur } = useFocusVisible();
  const focusVisibleClassName = useFocusVisibleClassName({
    focusVisible
  });
  const handleFocus = (event) => {
    if (onFocusProp) {
      onFocusProp(event);
    }
    onFocus(event);
  };
  const handleBlur = (event) => {
    if (onBlurProp) {
      onBlurProp(event);
    }
    onBlur(event);
  };
  const onRemoveWrapper = React191.useCallback((event) => {
    onRemove === null || onRemove === void 0 ? void 0 : onRemove(event, value);
  }, [
    onRemove,
    value
  ]);
  return (0, import_jsx_runtime174.jsxs)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    Component: Component3,
    className: clsx("vkuiChip", sizeY !== "regular" && sizeYClassNames24[sizeY], focusVisibleClassName, className),
    "aria-readonly": readOnly,
    "aria-disabled": disabled,
    onFocus: disabled ? void 0 : handleFocus,
    onBlur: disabled ? void 0 : handleBlur,
    children: [
      (0, import_jsx_runtime174.jsxs)("div", {
        className: "vkuiChip__in",
        children: [
          hasReactNode(before) && (0, import_jsx_runtime174.jsx)("div", {
            className: "vkuiChip__before",
            children: before
          }),
          (0, import_jsx_runtime174.jsx)(Footnote, {
            className: "vkuiChip__content",
            children
          }),
          hasReactNode(after) && (0, import_jsx_runtime174.jsx)("div", {
            className: "vkuiChip__after",
            children: after
          })
        ]
      }),
      !readOnly && removable && (0, import_jsx_runtime174.jsx)("div", {
        className: "vkuiChip__removable",
        children: (0, import_jsx_runtime174.jsxs)("button", {
          tabIndex: -1,
          disabled,
          className: "vkuiChip__remove",
          onClick: disabled ? void 0 : onRemoveWrapper,
          children: [
            (0, import_jsx_runtime174.jsxs)(VisuallyHidden, {
              children: [
                "  ",
                removeLabel,
                " ",
                children
              ]
            }),
            (0, import_jsx_runtime174.jsx)(Icon16Cancel, {})
          ]
        })
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ChipsInput/ChipsInput.js
var import_jsx_runtime178 = __toESM(require_jsx_runtime());

// node_modules/@vkontakte/vkui/dist/components/ChipsInputBase/ChipsInputBase.js
var import_jsx_runtime177 = __toESM(require_jsx_runtime());
var React194 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/FormFieldClearButton/FormFieldClearButton.js
var import_jsx_runtime175 = __toESM(require_jsx_runtime());
var React192 = __toESM(require_react());
var FormFieldClearButton = (_param) => {
  var { className, onClick } = _param, restProps = _object_without_properties(_param, [
    "className",
    "onClick"
  ]);
  return (0, import_jsx_runtime175.jsx)(IconButton, _object_spread_props(_object_spread({
    Component: "button",
    label: "Очистить поле",
    onKeyDown: stopPropagation,
    type: "button",
    activeMode: "opacity",
    hoverMode: "opacity"
  }, restProps), {
    className,
    onClick: (e) => {
      stopPropagation(e);
      e.preventDefault();
      onClick();
    },
    children: (0, import_jsx_runtime175.jsx)(Icon16Cancel, {})
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ChipsInputBase/constants.js
var import_jsx_runtime176 = __toESM(require_jsx_runtime());
var React193 = __toESM(require_react());
var DEFAULT_VALUE = [];
var DEFAULT_INPUT_VALUE = "";
function getOptionValueDefault(option) {
  return option.value;
}
function getOptionLabelDefault(option) {
  return option.label;
}
function getNewOptionDataDefault(value, label) {
  return {
    value,
    label
  };
}
function renderChipDefault(props) {
  const { label } = props, rest = _object_without_properties(props, [
    "label"
  ]);
  return (0, import_jsx_runtime176.jsx)(Chip, _object_spread_props(_object_spread({
    removable: !props.disabled
  }, rest), {
    children: label
  }));
}

// node_modules/@vkontakte/vkui/dist/components/ChipsInputBase/helpers.js
var isValueLikeChipOptionObject = (v) => typeof v === "object" && "value" in v;
var isInputValueEmpty = (input) => input ? input.value === DEFAULT_INPUT_VALUE : true;
var getChipOptionIndexByValueProp = (optionProp, valueProp) => {
  const value = isValueLikeChipOptionObject(optionProp) ? optionProp.value : optionProp;
  return valueProp.findIndex((option) => option.value === value);
};
var getChipOptionIndexByHTMLElement = (el) => {
  const value = el && el.dataset.index;
  return typeof value === "string" ? Number(value) : -1;
};
var getChipOptionValueByHTMLElement = (el) => {
  const value = el && el.dataset.value;
  return typeof value === "string" ? value : -1;
};
var getNextChipOptionIndexByNavigateToProp = (currentIndex, navigateTo, length) => {
  const LAST_INDEX = length - 1;
  switch (navigateTo) {
    case "prev":
      const prevIndex = currentIndex - 1;
      return prevIndex < 0 ? LAST_INDEX : prevIndex;
    case "next":
      const nextIndex = currentIndex + 1;
      return nextIndex > LAST_INDEX ? 0 : nextIndex;
    case "last":
      return LAST_INDEX;
    default:
      return -1;
  }
};

// node_modules/@vkontakte/vkui/dist/components/ChipsInputBase/ChipsInputBase.js
var sizeYClassNames25 = {
  none: "vkuiChipsInputBase--sizeY-none",
  compact: "vkuiChipsInputBase--sizeY-compact"
};
var ChipsInputBase = (_param) => {
  var {
    // FormFieldProps
    getRootRef,
    style,
    className,
    before,
    after,
    status,
    mode,
    maxHeight,
    // option
    value = DEFAULT_VALUE,
    onAddChipOption,
    onRemoveChipOption: onRemoveChipOptionProp,
    renderChip = renderChipDefault,
    // input
    getRef,
    id: idProp,
    inputValue = DEFAULT_INPUT_VALUE,
    placeholder,
    disabled,
    readOnly,
    addOnBlur,
    onBlur,
    onInputChange,
    // clear
    ClearButton = FormFieldClearButton,
    clearButtonShown,
    clearButtonTestId,
    onClear
  } = _param, restProps = _object_without_properties(_param, [
    "getRootRef",
    "style",
    "className",
    "before",
    "after",
    "status",
    "mode",
    "maxHeight",
    "value",
    "onAddChipOption",
    "onRemoveChipOption",
    "renderChip",
    "getRef",
    "id",
    "inputValue",
    "placeholder",
    "disabled",
    "readOnly",
    "addOnBlur",
    "onBlur",
    "onInputChange",
    "ClearButton",
    "clearButtonShown",
    "clearButtonTestId",
    "onClear"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const idGenerated = React194.useId();
  const inputRef = useExternRef(getRef);
  const listboxRef = React194.useRef(null);
  const valueLength = value.length;
  const withPlaceholder = valueLength === 0;
  const [lastFocusedChipOptionIndex, setLastFocusedChipOptionIndex] = React194.useState(0);
  const resetChipOptionFocusToInputEl = (inputEl) => {
    setLastFocusedChipOptionIndex(0);
    inputEl.focus();
  };
  const moveFocusToChipOption = (currentIndex, navigateTo, listboxEl) => {
    const index2 = getNextChipOptionIndexByNavigateToProp(currentIndex, navigateTo, valueLength);
    const foundEl = listboxEl.querySelector(`[data-index="${index2}"]`);
    if (foundEl) {
      setLastFocusedChipOptionIndex(index2);
      foundEl.focus();
    }
  };
  const removeChipOption = (o, index2) => {
    if (!inputRef.current || !listboxRef.current) {
      return;
    }
    if (valueLength > 1) {
      if (index2 === valueLength - 1) {
        moveFocusToChipOption(index2, "prev", listboxRef.current);
      } else {
        moveFocusToChipOption(index2, "next", listboxRef.current);
      }
    } else {
      resetChipOptionFocusToInputEl(inputRef.current);
    }
    onRemoveChipOptionProp(o);
  };
  const handleListboxKeyDown = (event) => {
    const targetEl = event.target;
    if (event.defaultPrevented || !listboxRef.current || !isHTMLElement(targetEl)) {
      return;
    }
    switch (event.key) {
      case Keys.ENTER: {
        if (!readOnly && contains(targetEl, inputRef.current) && inputRef.current && !isInputValueEmpty(inputRef.current)) {
          event.preventDefault();
          onAddChipOption(inputRef.current.value);
        }
        break;
      }
      case Keys.DELETE:
      case Keys.BACKSPACE: {
        if (!readOnly && valueLength > 0) {
          if (!contains(targetEl, inputRef.current)) {
            event.preventDefault();
            removeChipOption(getChipOptionValueByHTMLElement(targetEl), getChipOptionIndexByHTMLElement(targetEl));
          } else if (event.key === Keys.BACKSPACE && isInputValueEmpty(inputRef.current)) {
            event.preventDefault();
            moveFocusToChipOption(getChipOptionIndexByHTMLElement(targetEl), "last", listboxRef.current);
          }
        }
        break;
      }
      case Keys.ARROW_UP:
      case Keys.ARROW_LEFT:
      case Keys.ARROW_DOWN:
      case Keys.ARROW_RIGHT: {
        if (valueLength !== 0 && !contains(targetEl, inputRef.current)) {
          event.preventDefault();
          moveFocusToChipOption(getChipOptionIndexByHTMLElement(targetEl), getHorizontalFocusGoTo(event.key), listboxRef.current);
        }
        break;
      }
    }
  };
  const handleInputBlur = (event) => {
    if (onBlur) {
      onBlur(event);
    }
    if (addOnBlur && !event.defaultPrevented && inputRef.current) {
      onAddChipOption(inputRef.current.value);
    }
  };
  const handleChipRemove = (event, v) => {
    event.preventDefault();
    event.stopPropagation();
    removeChipOption(v, getChipOptionIndexByValueProp(v, value));
  };
  const handleRootClick = (event) => {
    if (event.defaultPrevented || contains(event.currentTarget, getActiveElementByAnotherElement(event.currentTarget))) {
      return;
    }
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };
  const clearButton = React194.useMemo(() => {
    if (clearButtonShown) {
      return (0, import_jsx_runtime177.jsx)(ClearButton, {
        onClick: onClear,
        disabled,
        "data-testid": clearButtonTestId
      });
    }
    return void 0;
  }, [
    ClearButton,
    clearButtonShown,
    clearButtonTestId,
    disabled,
    onClear
  ]);
  const afterItems = React194.useMemo(() => {
    if (clearButton || after) {
      return (0, import_jsx_runtime177.jsxs)(import_jsx_runtime177.Fragment, {
        children: [
          clearButton,
          after
        ]
      });
    }
    return void 0;
  }, [
    after,
    clearButton
  ]);
  return (0, import_jsx_runtime177.jsx)(FormField, {
    Component: "div",
    getRootRef,
    style,
    disabled,
    before,
    after: afterItems,
    status,
    mode,
    className,
    maxHeight,
    onClick: disabled ? void 0 : handleRootClick,
    children: (0, import_jsx_runtime177.jsxs)("div", {
      className: clsx("vkuiChipsInputBase", sizeY !== "regular" && sizeYClassNames25[sizeY], withPlaceholder && "vkuiChipsInputBase--hasPlaceholder"),
      // для a11y
      ref: listboxRef,
      role: "listbox",
      "aria-orientation": "horizontal",
      "aria-disabled": disabled,
      "aria-readonly": readOnly,
      onKeyDown: disabled ? void 0 : handleListboxKeyDown,
      children: [
        value.map((option, index2) => (0, import_jsx_runtime177.jsx)(React194.Fragment, {
          children: renderChip({
            "Component": "div",
            "value": option.value,
            "label": option.label,
            "disabled": option.disabled || disabled,
            "readOnly": option.readOnly || readOnly,
            "className": "vkuiChipsInputBase__chip",
            "onRemove": handleChipRemove,
            // чтобы можно было легче найти этот чип в DOM
            "data-index": index2,
            "data-value": option.value,
            // для a11y
            "tabIndex": lastFocusedChipOptionIndex === index2 ? 0 : -1,
            "role": "option",
            "aria-selected": true,
            "aria-posinset": index2 + 1,
            "aria-setsize": valueLength
          }, option)
        }, `${typeof option.value}-${option.value}`)),
        (0, import_jsx_runtime177.jsx)(Text, _object_spread_props(_object_spread({
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          spellCheck: false
        }, restProps), {
          Component: "input",
          type: "text",
          id: idProp || `chips-input-base-generated-id-${idGenerated}`,
          getRootRef: inputRef,
          className: "vkuiChipsInputBase__el",
          disabled,
          readOnly,
          placeholder: withPlaceholder ? placeholder : void 0,
          value: inputValue,
          onChange: onInputChange,
          onBlur: handleInputBlur
        }))
      ]
    })
  });
};

// node_modules/@vkontakte/vkui/dist/components/ChipsInput/useChipsInput.js
var React195 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/react/simulateReactInput.js
var simulateReactInput = (target, nextValue = "") => {
  try {
    const prevValue = target.value;
    target.value = nextValue;
    const tracker = target._valueTracker;
    if (tracker) {
      tracker.setValue(prevValue);
    }
    const event = new Event("input", {
      bubbles: true
    });
    target.dispatchEvent(event);
  } catch (error) {
    if (true) {
      throw error;
    }
  }
};

// node_modules/@vkontakte/vkui/dist/components/ChipsInput/useChipsInput.js
var transformValue = (value, getOptionValue, getOptionLabel) => value.map((option) => _object_spread_props(_object_spread({}, option), {
  label: getOptionLabel(option),
  value: getOptionValue(option)
}));
var useChipsInput = ({
  // option
  value: valueProp,
  defaultValue = DEFAULT_VALUE,
  onChange,
  getOptionLabel = getOptionLabelDefault,
  getOptionValue = getOptionValueDefault,
  getNewOptionData = getNewOptionDataDefault,
  // input
  inputValue: inputValueProp,
  defaultInputValue = DEFAULT_INPUT_VALUE,
  onInputChange,
  // other
  disabled
}) => {
  const [value, setValue] = useCustomEnsuredControl({
    disabled,
    value: valueProp ? transformValue(valueProp, getOptionValue, getOptionLabel) : void 0,
    defaultValue: transformValue(defaultValue, getOptionValue, getOptionLabel),
    onChange
  });
  const inputRef = React195.useRef(null);
  const [inputValue, setInputChange] = useEnsuredControl({
    disabled,
    value: inputValueProp,
    defaultValue: defaultInputValue,
    onChange: onInputChange
  });
  const toggleOption = React195.useCallback((nextValueProp, isNewValue) => {
    setValue((prevValue) => {
      const isLikeObjectOption = isValueLikeChipOptionObject(nextValueProp);
      const resolvedOption = isLikeObjectOption ? getNewOptionData(nextValueProp.value, nextValueProp.label) : getNewOptionData(nextValueProp, typeof nextValueProp === "string" ? nextValueProp : "");
      const nextValue = prevValue.filter((option) => resolvedOption.value !== option.value);
      if (isNewValue === true) {
        nextValue.push(isLikeObjectOption ? _object_spread({}, nextValueProp, resolvedOption) : resolvedOption);
      }
      return nextValue;
    });
  }, [
    setValue,
    getNewOptionData
  ]);
  const clearInput = React195.useCallback(() => {
    if (!inputRef.current) {
      return;
    }
    simulateReactInput(inputRef.current, "");
  }, [
    inputRef
  ]);
  const addOption = React195.useCallback((newValue) => toggleOption(newValue, true), [
    toggleOption
  ]);
  const removeOption = React195.useCallback((newValue) => toggleOption(newValue, false), [
    toggleOption
  ]);
  const addOptionFromInput = React195.useCallback((inputValue2) => {
    const label = inputValue2.trim();
    if (label) {
      addOption(label);
      clearInput();
    }
  }, [
    addOption,
    clearInput
  ]);
  const reset = React195.useCallback(() => {
    setValue(defaultValue);
  }, [
    defaultValue,
    setValue
  ]);
  const clearOptions = React195.useCallback(() => {
    setValue(DEFAULT_VALUE);
    clearInput();
  }, [
    clearInput,
    setValue
  ]);
  useNativeFormResetListener(inputRef, reset);
  return {
    value,
    addOption,
    addOptionFromInput,
    removeOption,
    inputRef,
    inputValue,
    onInputChange: setInputChange,
    clearInput,
    clearOptions
  };
};

// node_modules/@vkontakte/vkui/dist/components/ChipsInput/ChipsInput.js
var ChipsInput = (_param) => {
  var {
    // option
    value: valueProp,
    defaultValue,
    onChange,
    // input
    getRef,
    inputValue: inputValueProp,
    defaultInputValue: inputDefaultValueProp,
    onInputChange: onInputChangeProp,
    getOptionValue,
    getOptionLabel,
    getNewOptionData,
    // other
    disabled,
    allowClearButton
  } = _param, restProps = _object_without_properties(_param, [
    "value",
    "defaultValue",
    "onChange",
    "getRef",
    "inputValue",
    "defaultInputValue",
    "onInputChange",
    "getOptionValue",
    "getOptionLabel",
    "getNewOptionData",
    "disabled",
    "allowClearButton"
  ]);
  const {
    value,
    addOptionFromInput,
    removeOption,
    clearOptions,
    // input
    inputRef: inputRefHook,
    inputValue,
    onInputChange
  } = useChipsInput({
    // option
    value: valueProp,
    defaultValue,
    onChange,
    getOptionLabel,
    getOptionValue,
    getNewOptionData,
    // input
    inputValue: inputValueProp,
    defaultInputValue: inputDefaultValueProp,
    onInputChange: onInputChangeProp,
    // other
    disabled
  });
  const inputRef = useExternRef(getRef, inputRefHook);
  return (0, import_jsx_runtime178.jsx)(ChipsInputBase, _object_spread_props(_object_spread({}, restProps), {
    disabled,
    value,
    clearButtonShown: allowClearButton && (!!value.length || !!inputValue.length),
    onAddChipOption: addOptionFromInput,
    onRemoveChipOption: removeOption,
    onClear: clearOptions,
    getRef: inputRef,
    inputValue,
    onInputChange
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ChipsSelect/ChipsSelect.js
var import_jsx_runtime186 = __toESM(require_jsx_runtime());
var React208 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/select.js
function getOptionLabelDefault2(option) {
  return option.label;
}
function defaultFilterFn(...args) {
  const [rawSearchQuery = "", option, getOptionLabel] = args;
  const foundRawLabel = getOptionLabel ? getOptionLabel(option) : getOptionLabelDefault2(option);
  if (foundRawLabel === void 0) {
    return false;
  }
  const searchQuery = rawSearchQuery.toLocaleLowerCase();
  const label = getTextFromChildren(foundRawLabel).toLocaleLowerCase();
  if (label.startsWith(searchQuery)) {
    return true;
  }
  const findAllIncludes = (target = "", search = "") => {
    const includes2 = [];
    let i = target.indexOf(search);
    while (i !== -1) {
      includes2.push(i);
      i = target.indexOf(search, i + 1);
    }
    return includes2;
  };
  const includes = findAllIncludes(label, searchQuery);
  if (includes.length) {
    const letterRegexp = new RegExp("\\p{L}", "u");
    for (const index2 of includes) {
      if (!letterRegexp.test(label[index2 - 1])) {
        return true;
      }
    }
  }
  return false;
}
var getFormFieldModeFromSelectType = (selectType = "default") => {
  return selectType === "default" ? "default" : "plain";
};

// node_modules/@vkontakte/vkui/dist/components/CustomSelectDropdown/CustomSelectDropdown.js
var import_jsx_runtime182 = __toESM(require_jsx_runtime());
var React204 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/CustomScrollView/CustomScrollView.js
var import_jsx_runtime181 = __toESM(require_jsx_runtime());
var React203 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/CustomScrollView/ScrollX.js
var import_jsx_runtime179 = __toESM(require_jsx_runtime());
var React199 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/CustomScrollView/useDragAndDrop.js
var React196 = __toESM(require_react());
var useDragAndDrop = (onDragStart, onDragMove, onDragEnd) => {
  const { document: document2 } = useDOM();
  const [isPressed, setIsPressed] = React196.useState(false);
  const onDragEndImpl = (e) => {
    if (!isPressed) {
      return;
    }
    e.preventDefault();
    onDragEnd(e);
    unsubscribe();
  };
  const onDragMoveImpl = (e) => {
    if (!isPressed) {
      return;
    }
    e.preventDefault();
    onDragMove(e);
  };
  const listeners = [
    // @ts-expect-error: TS2769 ругается на тип event
    useEventListener("mousemove", onDragMoveImpl),
    // @ts-expect-error: TS2769 ругается на тип event
    useEventListener("mouseup", onDragEndImpl)
  ];
  function subscribe(el) {
    if (el) {
      listeners.forEach((l) => l.add(el));
    }
  }
  function unsubscribe() {
    listeners.forEach((l) => l.remove());
  }
  return {
    onDragStart: (e) => {
      e.preventDefault();
      setIsPressed(true);
      onDragStart(e);
      subscribe(document2);
    }
  };
};

// node_modules/@vkontakte/vkui/dist/components/CustomScrollView/useHorizontalScrollController.js
var React198 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/CustomScrollView/useTrackerVisibility.js
var React197 = __toESM(require_react());
var useTrackerVisibility = (autoHideScrollbar = false, autoHideScrollbarDelay = 500) => {
  const [visibility, setVisibility] = React197.useState(autoHideScrollbar ? "hidden" : "visible");
  const isMouseOver = React197.useRef(false);
  const isTrackerDragging = React197.useRef(false);
  React197.useEffect(() => {
    setVisibility(autoHideScrollbar ? "hidden" : "visible");
  }, [
    autoHideScrollbar
  ]);
  const onTrackerDragStart = React197.useCallback(() => {
    isTrackerDragging.current = true;
    setVisibility("visible");
  }, []);
  const onTrackerDragStop = React197.useCallback(() => {
    isTrackerDragging.current = false;
    if (!isMouseOver.current) {
      setVisibility("temporary-visible");
    }
  }, []);
  const onTrackerMouseEnter = React197.useCallback(() => {
    isMouseOver.current = true;
    setVisibility("visible");
  }, []);
  const onTrackerMouseLeave = React197.useCallback(() => {
    isMouseOver.current = false;
    if (!isTrackerDragging.current) {
      setVisibility("temporary-visible");
    }
  }, []);
  const onTargetScroll = React197.useCallback(() => {
    if (isMouseOver.current || isTrackerDragging.current) {
      return;
    }
    setVisibility("temporary-visible");
  }, []);
  React197.useEffect(function hideAfterDelay() {
    let timeoutId = null;
    if (visibility === "temporary-visible") {
      timeoutId = setTimeout(() => {
        setVisibility("hidden");
      }, autoHideScrollbarDelay);
    }
    return function clearHideAfterDelay() {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  }, [
    visibility,
    autoHideScrollbarDelay
  ]);
  return {
    trackerVisible: visibility !== "hidden",
    onTrackerDragStart,
    onTrackerDragStop,
    onTrackerMouseEnter,
    onTrackerMouseLeave,
    onTargetScroll
  };
};

// node_modules/@vkontakte/vkui/dist/components/CustomScrollView/useHorizontalScrollController.js
var useHorizontalScrollController = (boxRef, autoHideScrollbar, autoHideScrollbarDelay) => {
  const barX = React198.useRef(null);
  const horizontalRatio = React198.useRef(NaN);
  const lastTrackerLeft = React198.useRef(0);
  const clientWidth = React198.useRef(0);
  const trackerWidth = React198.useRef(0);
  const scrollWidth = React198.useRef(0);
  const startX = React198.useRef(0);
  const trackerLeft = React198.useRef(0);
  const trackerX = React198.useRef(null);
  const { trackerVisible, onTargetScroll, onTrackerDragStart, onTrackerDragStop, onTrackerMouseEnter, onTrackerMouseLeave } = useTrackerVisibility(autoHideScrollbar, autoHideScrollbarDelay);
  const setHorizontalTrackerPosition = (scrollLeft) => {
    lastTrackerLeft.current = scrollLeft;
    if (trackerX.current !== null) {
      trackerX.current.style.transform = `translate(${scrollLeft}px, 0)`;
    }
  };
  const setTrackerPositionFromScroll = (scrollLeft) => {
    const progress = scrollLeft / (scrollWidth.current - clientWidth.current);
    setHorizontalTrackerPosition((clientWidth.current - trackerWidth.current) * progress);
  };
  const resize = () => {
    if (!boxRef.current || !barX.current || !trackerX.current) {
      return;
    }
    const localClientWidth = boxRef.current.clientWidth;
    const localScrollWidth = boxRef.current.scrollWidth;
    const localVerticalRatio = localClientWidth / localScrollWidth;
    const localTrackerWidth = Math.max(localClientWidth * localVerticalRatio, 40);
    horizontalRatio.current = localVerticalRatio;
    clientWidth.current = localClientWidth;
    scrollWidth.current = localScrollWidth;
    trackerWidth.current = localTrackerWidth;
    const currentScrollLeft = boxRef.current.scrollLeft;
    if (localVerticalRatio >= 1) {
      barX.current.style.display = "none";
    } else {
      barX.current.style.display = "";
      trackerX.current.style.width = `${localTrackerWidth}px`;
      setTrackerPositionFromScroll(currentScrollLeft);
    }
  };
  const setScrollPositionFromTracker = (trackerLeft2) => {
    const progress = trackerLeft2 / (clientWidth.current - trackerWidth.current);
    if (boxRef.current !== null) {
      boxRef.current.scroll({
        left: (scrollWidth.current - clientWidth.current) * progress
      });
    }
  };
  const dragging = (e) => {
    const diff = e.clientX - startX.current;
    const position = Math.min(Math.max(trackerLeft.current + diff, 0), clientWidth.current - trackerWidth.current);
    setScrollPositionFromTracker(position);
  };
  const dragEnd = () => {
    if (autoHideScrollbar) {
      onTrackerDragStop();
    }
  };
  const scroll = () => {
    if (!boxRef.current) {
      return;
    }
    if (autoHideScrollbar) {
      onTargetScroll();
    }
    setTrackerPositionFromScroll(boxRef.current.scrollLeft);
  };
  const dragStart = (e) => {
    startX.current = e.clientX;
    trackerLeft.current = lastTrackerLeft.current;
    if (autoHideScrollbar) {
      onTrackerDragStart();
    }
  };
  return {
    barRef: barX,
    trackerVisible,
    trackerRef: trackerX,
    resize,
    dragging,
    dragEnd,
    scroll,
    dragStart,
    trackerMouseEnter: onTrackerMouseEnter,
    trackerMouseLeave: onTrackerMouseLeave
  };
};

// node_modules/@vkontakte/vkui/dist/components/CustomScrollView/ScrollX.js
var ScrollX = ({ barHandlers, boxRef, autoHideScrollbar, autoHideScrollbarDelay }) => {
  const { barRef: barX, trackerVisible: horizontalTrackerVisible, trackerRef: trackerX, resize: horizontalScrollResize, scroll: horizontalScroll, dragStart: onHorizontalDragStart, dragging: onHorizontalDragging, dragEnd: onHorizontalDragEnd, trackerMouseEnter: onHorizontalTrackerMouseEnter, trackerMouseLeave: onHorizontalTrackerMouseLeave } = useHorizontalScrollController(boxRef, autoHideScrollbar, autoHideScrollbarDelay);
  const { onDragStart: onMouseDown } = useDragAndDrop(onHorizontalDragStart, onHorizontalDragging, onHorizontalDragEnd);
  React199.useImperativeHandle(barHandlers, () => ({
    resize: horizontalScrollResize,
    scroll: horizontalScroll
  }), [
    horizontalScrollResize,
    horizontalScroll
  ]);
  return (0, import_jsx_runtime179.jsx)("div", {
    className: "vkuiCustomScrollView__barX",
    ref: barX,
    onClick: stopPropagation,
    children: (0, import_jsx_runtime179.jsx)("div", {
      className: clsx("vkuiCustomScrollView__trackerX", !horizontalTrackerVisible && "vkuiCustomScrollView__trackerX--hidden"),
      onMouseEnter: autoHideScrollbar ? onHorizontalTrackerMouseEnter : void 0,
      onMouseLeave: autoHideScrollbar ? onHorizontalTrackerMouseLeave : void 0,
      ref: trackerX,
      onMouseDown
    })
  });
};

// node_modules/@vkontakte/vkui/dist/components/CustomScrollView/ScrollY.js
var import_jsx_runtime180 = __toESM(require_jsx_runtime());
var React201 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/CustomScrollView/useVerticalScrollController.js
var React200 = __toESM(require_react());
var useVerticalScrollController = (boxRef, autoHideScrollbar, autoHideScrollbarDelay) => {
  const barY = React200.useRef(null);
  const verticalRatio = React200.useRef(NaN);
  const lastTrackerTop = React200.useRef(0);
  const clientHeight = React200.useRef(0);
  const trackerHeight = React200.useRef(0);
  const scrollHeight = React200.useRef(0);
  const startY = React200.useRef(0);
  const trackerTop = React200.useRef(0);
  const trackerY = React200.useRef(null);
  const { trackerVisible, onTargetScroll, onTrackerDragStart, onTrackerDragStop, onTrackerMouseEnter, onTrackerMouseLeave } = useTrackerVisibility(autoHideScrollbar, autoHideScrollbarDelay);
  const setVerticalTrackerPosition = (scrollTop) => {
    lastTrackerTop.current = scrollTop;
    if (trackerY.current !== null) {
      trackerY.current.style.transform = `translate(0, ${scrollTop}px)`;
    }
  };
  const setTrackerPositionFromScroll = (scrollTop) => {
    const progress = scrollTop / (scrollHeight.current - clientHeight.current);
    setVerticalTrackerPosition((clientHeight.current - trackerHeight.current) * progress);
  };
  const resize = () => {
    if (!boxRef.current || !barY.current || !trackerY.current) {
      return;
    }
    const localClientHeight = boxRef.current.clientHeight;
    const localScrollHeight = boxRef.current.scrollHeight;
    const localVerticalRatio = localClientHeight / localScrollHeight;
    const localTrackerHeight = Math.max(localClientHeight * localVerticalRatio, 40);
    verticalRatio.current = localVerticalRatio;
    clientHeight.current = localClientHeight;
    scrollHeight.current = localScrollHeight;
    trackerHeight.current = localTrackerHeight;
    const currentScrollTop = boxRef.current.scrollTop;
    if (localVerticalRatio >= 1) {
      barY.current.style.display = "none";
    } else {
      barY.current.style.display = "";
      trackerY.current.style.height = `${localTrackerHeight}px`;
      setTrackerPositionFromScroll(currentScrollTop);
    }
  };
  const setScrollPositionFromTracker = (trackerTop2) => {
    const progress = trackerTop2 / (clientHeight.current - trackerHeight.current);
    if (boxRef.current !== null) {
      boxRef.current.scroll({
        top: (scrollHeight.current - clientHeight.current) * progress
      });
    }
  };
  const dragging = (e) => {
    const diff = e.clientY - startY.current;
    const position = Math.min(Math.max(trackerTop.current + diff, 0), clientHeight.current - trackerHeight.current);
    setScrollPositionFromTracker(position);
  };
  const dragEnd = () => {
    if (autoHideScrollbar) {
      onTrackerDragStop();
    }
  };
  const scroll = () => {
    if (!boxRef.current) {
      return;
    }
    if (autoHideScrollbar) {
      onTargetScroll();
    }
    setTrackerPositionFromScroll(boxRef.current.scrollTop);
  };
  const dragStart = (e) => {
    startY.current = e.clientY;
    trackerTop.current = lastTrackerTop.current;
    if (autoHideScrollbar) {
      onTrackerDragStart();
    }
  };
  return {
    barRef: barY,
    trackerVisible,
    trackerRef: trackerY,
    resize,
    dragging,
    dragEnd,
    scroll,
    dragStart,
    trackerMouseEnter: onTrackerMouseEnter,
    trackerMouseLeave: onTrackerMouseLeave
  };
};

// node_modules/@vkontakte/vkui/dist/components/CustomScrollView/ScrollY.js
var ScrollY = ({ barHandlers, boxRef, autoHideScrollbar, autoHideScrollbarDelay }) => {
  const { barRef: barY, trackerVisible: verticalTrackerVisible, trackerRef: trackerY, resize: verticalScrollResize, scroll: verticalScroll, dragStart: onVerticalDragStart, dragging: onVerticalDragging, dragEnd: onVerticalDragEnd, trackerMouseEnter: onVerticalTrackerMouseEnter, trackerMouseLeave: onVerticalTrackerMouseLeave } = useVerticalScrollController(boxRef, autoHideScrollbar, autoHideScrollbarDelay);
  const { onDragStart: onMouseDown } = useDragAndDrop(onVerticalDragStart, onVerticalDragging, onVerticalDragEnd);
  React201.useImperativeHandle(barHandlers, () => ({
    resize: verticalScrollResize,
    scroll: verticalScroll
  }), [
    verticalScrollResize,
    verticalScroll
  ]);
  return (0, import_jsx_runtime180.jsx)("div", {
    className: "vkuiCustomScrollView__barY",
    ref: barY,
    onClick: stopPropagation,
    children: (0, import_jsx_runtime180.jsx)("div", {
      className: clsx("vkuiCustomScrollView__trackerY", !verticalTrackerVisible && "vkuiCustomScrollView__trackerY--hidden"),
      onMouseEnter: autoHideScrollbar ? onVerticalTrackerMouseEnter : void 0,
      onMouseLeave: autoHideScrollbar ? onVerticalTrackerMouseLeave : void 0,
      ref: trackerY,
      onMouseDown
    })
  });
};

// node_modules/@vkontakte/vkui/dist/components/CustomScrollView/useCustomScrollViewResize.js
var useCustomScrollViewResize = ({ windowResize, onResize, boxContentRef }) => {
  const { window: window2 } = useDOM();
  const resizeCb = useStableCallback(onResize);
  const resizeHandler = useEventListener("resize", resizeCb);
  useIsomorphicLayoutEffect(() => {
    if (windowResize && window2) {
      resizeHandler.add(window2);
    }
  }, [
    windowResize,
    window2
  ]);
  useResizeObserver(boxContentRef, resizeCb);
  useIsomorphicLayoutEffect(resizeCb, []);
};

// node_modules/@vkontakte/vkui/dist/components/CustomScrollView/useDetectScrollDirection.js
var React202 = __toESM(require_react());
var useDetectScrollDirection = () => {
  const lastScrollLeft = React202.useRef(0);
  const lastScrollTop = React202.useRef(0);
  return React202.useCallback((event) => {
    const { scrollTop, scrollLeft } = event.currentTarget;
    if (scrollTop !== lastScrollTop.current) {
      lastScrollTop.current = scrollTop;
      return "vertical";
    } else if (scrollLeft !== lastScrollLeft.current) {
      lastScrollLeft.current = scrollLeft;
      return "horizontal";
    }
    return null;
  }, []);
};

// node_modules/@vkontakte/vkui/dist/components/CustomScrollView/CustomScrollView.js
function hasPointerClassName2(hasPointer) {
  switch (hasPointer) {
    case true:
      return "vkuiCustomScrollView--hasPointer-true";
    case false:
      return "vkuiCustomScrollView--hasPointer-false";
    case void 0:
    default:
      return "vkuiCustomScrollView--hasPointer-none";
  }
}
var overscrollBehaviorClassNames = {
  auto: void 0,
  contain: "vkuiCustomScrollView__box--overscrollBehavior-contain",
  none: "vkuiCustomScrollView__box--overscrollBehavior-none"
};
var CustomScrollView = (_param) => {
  var { className, children, boxRef: externalBoxRef, windowResize, autoHideScrollbar = false, autoHideScrollbarDelay, enableHorizontalScroll = false, onScroll: onScrollProp, getRootRef, overscrollBehavior = "auto" } = _param, restProps = _object_without_properties(_param, [
    "className",
    "children",
    "boxRef",
    "windowResize",
    "autoHideScrollbar",
    "autoHideScrollbarDelay",
    "enableHorizontalScroll",
    "onScroll",
    "getRootRef",
    "overscrollBehavior"
  ]);
  const { hasPointer } = useAdaptivity();
  const boxRef = useExternRef(externalBoxRef);
  const boxContentRef = React203.useRef(null);
  const detectScrollDirection = useDetectScrollDirection();
  const barYHandlers = React203.useRef(null);
  const barXHandlers = React203.useRef(null);
  useCustomScrollViewResize({
    windowResize,
    boxContentRef,
    onResize: () => {
      var _barYHandlers_current, _barXHandlers_current;
      (_barYHandlers_current = barYHandlers.current) === null || _barYHandlers_current === void 0 ? void 0 : _barYHandlers_current.resize();
      (_barXHandlers_current = barXHandlers.current) === null || _barXHandlers_current === void 0 ? void 0 : _barXHandlers_current.resize();
    }
  });
  const onScroll = (event) => {
    const scrollDirection = detectScrollDirection(event);
    switch (scrollDirection) {
      case "horizontal":
        var _barXHandlers_current;
        (_barXHandlers_current = barXHandlers.current) === null || _barXHandlers_current === void 0 ? void 0 : _barXHandlers_current.scroll();
        break;
      case "vertical":
        var _barYHandlers_current;
        (_barYHandlers_current = barYHandlers.current) === null || _barYHandlers_current === void 0 ? void 0 : _barYHandlers_current.scroll();
        break;
    }
    onScrollProp === null || onScrollProp === void 0 ? void 0 : onScrollProp(event);
  };
  return (0, import_jsx_runtime181.jsxs)("div", _object_spread_props(_object_spread({
    className: clsx(className, "vkuiCustomScrollView", hasPointerClassName2(hasPointer)),
    ref: getRootRef
  }, restProps), {
    children: [
      (0, import_jsx_runtime181.jsx)("div", {
        className: clsx("vkuiCustomScrollView__box", enableHorizontalScroll && "vkuiCustomScrollView__box--horizontalEnabled", overscrollBehaviorClassNames[overscrollBehavior]),
        tabIndex: -1,
        ref: boxRef,
        onScroll,
        children: (0, import_jsx_runtime181.jsx)("div", {
          ref: boxContentRef,
          className: "vkuiCustomScrollView__box-content",
          children
        })
      }),
      (0, import_jsx_runtime181.jsx)(ScrollY, {
        barHandlers: barYHandlers,
        boxRef,
        autoHideScrollbar,
        autoHideScrollbarDelay
      }),
      enableHorizontalScroll && (0, import_jsx_runtime181.jsx)(ScrollX, {
        barHandlers: barXHandlers,
        boxRef,
        autoHideScrollbar,
        autoHideScrollbarDelay
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/CustomSelectDropdown/CustomSelectDropdown.js
var CustomSelectDropdown = (_param) => {
  var {
    children,
    targetRef,
    scrollBoxRef,
    placement = "bottom",
    fetching,
    offsetDistance = 0,
    autoWidth = false,
    forcePortal = true,
    autoHideScrollbar,
    autoHideScrollbarDelay,
    className,
    noMaxHeight = false,
    // CustomScrollView
    overscrollBehavior
  } = _param, restProps = _object_without_properties(_param, [
    "children",
    "targetRef",
    "scrollBoxRef",
    "placement",
    "fetching",
    "offsetDistance",
    "autoWidth",
    "forcePortal",
    "autoHideScrollbar",
    "autoHideScrollbarDelay",
    "className",
    "noMaxHeight",
    "overscrollBehavior"
  ]);
  return (0, import_jsx_runtime182.jsx)(Popper, _object_spread_props(_object_spread({
    targetRef,
    offsetByMainAxis: offsetDistance,
    sameWidth: !autoWidth,
    placement,
    className: clsx("vkuiCustomSelectDropdown", "vkuiInternalCustomSelectDropdown", offsetDistance === 0 && (placement.includes("top") ? "vkuiCustomSelectDropdown--top" : "vkuiCustomSelectDropdown--bottom"), autoWidth && clsx("vkuiCustomSelectDropdown--wide", "vkuiInternalCustomSelectDropdown--wide"), className),
    usePortal: forcePortal,
    autoUpdateOnTargetResize: true
  }, restProps), {
    children: (0, import_jsx_runtime182.jsx)(CustomScrollView, {
      boxRef: scrollBoxRef,
      className: noMaxHeight ? void 0 : "vkuiCustomSelectDropdown__in--withMaxHeight",
      autoHideScrollbar,
      autoHideScrollbarDelay,
      overscrollBehavior,
      children: fetching ? (0, import_jsx_runtime182.jsx)("div", {
        className: "vkuiCustomSelectDropdown__fetching",
        children: (0, import_jsx_runtime182.jsx)(Spinner, {
          size: "small"
        })
      }) : children
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/CustomSelectOption/CustomSelectOption.js
var import_jsx_runtime183 = __toESM(require_jsx_runtime());
var React205 = __toESM(require_react());
var sizeYClassNames26 = {
  none: "vkuiCustomSelectOption--sizeY-none",
  regular: "vkuiCustomSelectOption--sizeY-regular"
};
var CustomSelectOption = (_param) => {
  var { children, hierarchy = 0, hovered: hoveredProp, selected, before, after, description, disabled, style: styleProp, className, onClick } = _param, restProps = _object_without_properties(_param, [
    "children",
    "hierarchy",
    "hovered",
    "selected",
    "before",
    "after",
    "description",
    "disabled",
    "style",
    "className",
    "onClick"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const style = React205.useMemo(() => hierarchy > 0 ? _object_spread({
    "--vkui_internal--custom_select_option_hierarchy_level": hierarchy
  }, styleProp) : styleProp, [
    hierarchy,
    styleProp
  ]);
  const hovered = hoveredProp && !disabled ? true : false;
  return (0, import_jsx_runtime183.jsxs)(Paragraph, _object_spread_props(_object_spread({}, restProps), {
    onClick: disabled ? void 0 : onClick,
    Component: "div",
    role: "option",
    "aria-disabled": disabled,
    "aria-selected": selected,
    "data-hovered": hovered,
    className: clsx("vkuiCustomSelectOption", sizeY !== "compact" && sizeYClassNames26[sizeY], hovered && "vkuiCustomSelectOption--hover", disabled && "vkuiCustomSelectOption--disabled", hierarchy > 0 && "vkuiCustomSelectOption--hierarchy", className),
    style,
    children: [
      hasReactNode(before) && (0, import_jsx_runtime183.jsx)("div", {
        className: "vkuiCustomSelectOption__before",
        children: before
      }),
      (0, import_jsx_runtime183.jsxs)("div", {
        className: "vkuiCustomSelectOption__main",
        children: [
          (0, import_jsx_runtime183.jsx)("div", {
            className: "vkuiCustomSelectOption__children",
            children
          }),
          hasReactNode(description) && (0, import_jsx_runtime183.jsxs)(Footnote, {
            className: "vkuiCustomSelectOption__description",
            children: [
              (0, import_jsx_runtime183.jsx)(VisuallyHidden, {
                children: " "
              }),
              description
            ]
          })
        ]
      }),
      (0, import_jsx_runtime183.jsxs)("div", {
        className: "vkuiCustomSelectOption__after",
        children: [
          hasReactNode(after) && (0, import_jsx_runtime183.jsx)("div", {
            children: after
          }),
          selected && (0, import_jsx_runtime183.jsx)(Icon16Done, {
            className: "vkuiCustomSelectOption__selectedIcon"
          })
        ]
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/DropdownIcon/DropdownIcon.js
var import_jsx_runtime184 = __toESM(require_jsx_runtime());
var React206 = __toESM(require_react());
var DropdownIcon = (_param) => {
  var { opened = false, className } = _param, restProps = _object_without_properties(_param, [
    "opened",
    "className"
  ]);
  const { sizeY } = useAdaptivityConditionalRender();
  const IconCompact = opened ? Icon20ChevronUp : Icon20Dropdown;
  const IconRegular = opened ? Icon24ChevronUp : Icon24ChevronDown;
  return (0, import_jsx_runtime184.jsxs)(React206.Fragment, {
    children: [
      sizeY.compact && (0, import_jsx_runtime184.jsx)(IconCompact, _object_spread({
        className: clsx(sizeY.compact.className, className)
      }, restProps)),
      sizeY.regular && (0, import_jsx_runtime184.jsx)(IconRegular, _object_spread({
        className: clsx(sizeY.regular.className, className)
      }, restProps))
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/ChipsSelect/constants.js
var import_jsx_runtime185 = __toESM(require_jsx_runtime());
var DEFAULT_SELECTED_BEHAVIOR = "highlight";
var DEFAULT_EMPTY_TEXT = "Ничего не найдено";
var FOCUS_ACTION_NEXT = "next";
var FOCUS_ACTION_PREV = "prev";
var renderOptionDefault = (props) => (0, import_jsx_runtime185.jsx)(CustomSelectOption, _object_spread({}, props));
var isCreateNewOptionPreset = (option) => option && "actionText" in option;
var isEmptyOptionPreset = (option) => option && "placeholder" in option;
var isNotServicePreset = (option) => !isCreateNewOptionPreset(option) && !isEmptyOptionPreset(option);

// node_modules/@vkontakte/vkui/dist/components/ChipsSelect/useChipsSelect.js
var React207 = __toESM(require_react());
var useChipsSelect = ({
  // common
  disabled,
  // option
  value: valueProp,
  defaultValue,
  onChange,
  getOptionLabel = getOptionLabelDefault,
  getOptionValue = getOptionValueDefault,
  getNewOptionData = getNewOptionDataDefault,
  // input
  inputValue: inputValueProp,
  defaultInputValue = DEFAULT_INPUT_VALUE,
  onInputChange: onInputChangeProp,
  // dropdown
  creatable = false,
  emptyText = DEFAULT_EMPTY_TEXT,
  filterFn = defaultFilterFn,
  selectedBehavior = DEFAULT_SELECTED_BEHAVIOR,
  options: optionsProp = DEFAULT_VALUE,
  onClose,
  onOpen
}) => {
  const _useChipsInput = useChipsInput({
    // option
    value: valueProp,
    defaultValue,
    onChange,
    getOptionValue,
    getOptionLabel,
    getNewOptionData,
    // input
    inputValue: inputValueProp,
    defaultInputValue,
    onInputChange: onInputChangeProp,
    // other
    disabled
  }), { value, inputValue, onInputChange } = _useChipsInput, restChipsInputProps = _object_without_properties(_useChipsInput, [
    "value",
    "inputValue",
    "onInputChange"
  ]);
  const [opened, setOpened] = React207.useState(false);
  const [options, setOptions] = React207.useState(() => opened ? transformOptions({
    value,
    getOptionValue,
    getOptionLabel,
    inputValue,
    emptyText,
    creatable,
    filterFn,
    options: optionsProp,
    selectedBehavior
  }) : []);
  const [focusedOptionIndex, setFocusedOptionIndex] = React207.useState(0);
  const [focusedOption, setFocusedOption] = React207.useState(null);
  const handleOpened = React207.useCallback((isOpened) => {
    isOpened ? onOpen === null || onOpen === void 0 ? void 0 : onOpen() : onClose === null || onClose === void 0 ? void 0 : onClose();
    setOpened(isOpened);
  }, [
    onOpen,
    onClose
  ]);
  const handleInputChange = React207.useCallback((event) => {
    onInputChange(event);
    if (!opened) {
      handleOpened(true);
      setFocusedOptionIndex(0);
    }
  }, [
    onInputChange,
    opened,
    handleOpened
  ]);
  useIsomorphicLayoutEffect(function handleDropdownOpen() {
    if (!opened) {
      return;
    }
    setOptions((prevOptions) => {
      const nextOptions = transformOptions({
        value,
        getOptionValue,
        getOptionLabel,
        inputValue,
        emptyText,
        creatable,
        filterFn,
        options: optionsProp,
        selectedBehavior
      });
      if (isEqual(prevOptions, nextOptions)) {
        return prevOptions;
      }
      return nextOptions;
    });
  }, [
    opened,
    value,
    getOptionLabel,
    getOptionValue,
    inputValue,
    optionsProp,
    creatable,
    selectedBehavior,
    filterFn
  ]);
  return _object_spread_props(_object_spread({}, restChipsInputProps), {
    // options
    value,
    // input
    inputValue,
    onInputChange: handleInputChange,
    // dropdown states
    options,
    opened,
    setOpened: handleOpened,
    focusedOption,
    focusedOptionIndex,
    setFocusedOption,
    setFocusedOptionIndex
  });
};
function transformOptions({ value, getOptionValue = getOptionValueDefault, getOptionLabel = getOptionLabelDefault, inputValue = DEFAULT_INPUT_VALUE, emptyText = DEFAULT_EMPTY_TEXT, creatable = false, filterFn = defaultFilterFn, options: optionsProp = DEFAULT_VALUE, selectedBehavior = DEFAULT_SELECTED_BEHAVIOR }) {
  const filteredOptionsProp = filterFn ? optionsProp.filter((option) => filterFn(inputValue, option, getOptionLabel)) : optionsProp;
  if (filteredOptionsProp.length === 0) {
    if (inputValue !== DEFAULT_INPUT_VALUE && typeof creatable === "string") {
      return [
        {
          actionText: creatable
        }
      ];
    }
    return [
      {
        placeholder: emptyText
      }
    ];
  }
  const parsedOptions = transformValue(filteredOptionsProp, getOptionValue, getOptionLabel);
  if (selectedBehavior === "hide") {
    const selected = value.map((item) => item.value);
    return parsedOptions.filter((item) => isNotServicePreset(item) ? !selected.includes(item.value) : false);
  }
  return parsedOptions;
}

// node_modules/@vkontakte/vkui/dist/components/ChipsSelect/ChipsSelect.js
var findIndexAfter = (options = [], startIndex = -1) => {
  if (startIndex >= options.length - 1) {
    return -1;
  }
  return options.findIndex((option, i) => i > startIndex && (!isNotServicePreset(option) || !option.disabled));
};
var findIndexBefore = (options = [], endIndex = options.length) => {
  let result = -1;
  if (endIndex <= 0) {
    return result;
  }
  for (let i = endIndex - 1; i >= 0; i--) {
    let option = options[i];
    if (!isNotServicePreset(option) || !option.disabled) {
      result = i;
      break;
    }
  }
  return result;
};
var ChipsSelect = (_param) => {
  var {
    // FormFieldProps
    id: labelledbyId,
    getRootRef,
    className,
    status = "default",
    icon: dropdownIconProp,
    onChangeStart,
    // CustomSelectDropdownProps
    options: optionsProp,
    placement: placementProp = "bottom",
    closeAfterSelect = true,
    selectedBehavior = DEFAULT_SELECTED_BEHAVIOR,
    emptyText = DEFAULT_EMPTY_TEXT,
    creatable = false,
    fetching = false,
    dropdownAutoWidth,
    forceDropdownPortal,
    noMaxHeight = false,
    filterFn = defaultFilterFn,
    dropdownTestId,
    onClose,
    onOpen,
    overscrollBehavior,
    renderDropdown,
    // ChipsInputProps
    getRef,
    value: valueProp,
    defaultValue,
    inputValue: inputValueProp,
    defaultInputValue,
    disabled,
    readOnly,
    getOptionValue = getOptionValueDefault,
    getOptionLabel = getOptionLabelDefault,
    getNewOptionData = getNewOptionDataDefault,
    renderChip = renderChipDefault,
    renderOption = renderOptionDefault,
    onChange,
    onFocus: onFocusProp,
    onInputChange: onInputChangeProp,
    onBlur: onBlurProp,
    onKeyDown: onKeyDownProp,
    dropdownOffsetDistance = 0,
    allowClearButton,
    clearButtonTestId
  } = _param, restProps = _object_without_properties(_param, [
    "id",
    "getRootRef",
    "className",
    "status",
    "icon",
    "onChangeStart",
    "options",
    "placement",
    "closeAfterSelect",
    "selectedBehavior",
    "emptyText",
    "creatable",
    "fetching",
    "dropdownAutoWidth",
    "forceDropdownPortal",
    "noMaxHeight",
    "filterFn",
    "dropdownTestId",
    "onClose",
    "onOpen",
    "overscrollBehavior",
    "renderDropdown",
    "getRef",
    "value",
    "defaultValue",
    "inputValue",
    "defaultInputValue",
    "disabled",
    "readOnly",
    "getOptionValue",
    "getOptionLabel",
    "getNewOptionData",
    "renderChip",
    "renderOption",
    "onChange",
    "onFocus",
    "onInputChange",
    "onBlur",
    "onKeyDown",
    "dropdownOffsetDistance",
    "allowClearButton",
    "clearButtonTestId"
  ]);
  const {
    // Связано с ChipsInputProps
    // option
    value,
    addOptionFromInput,
    addOption,
    removeOption,
    clearOptions,
    // input
    inputRef: inputRefHook,
    inputValue,
    clearInput,
    onInputChange,
    // Связано с CustomSelectDropdownProps
    options,
    opened,
    setOpened,
    focusedOption,
    focusedOptionIndex,
    setFocusedOption,
    setFocusedOptionIndex
  } = useChipsSelect({
    // option
    value: valueProp,
    defaultValue,
    onChange,
    getOptionValue,
    getOptionLabel,
    getNewOptionData,
    // input
    inputValue: inputValueProp,
    defaultInputValue,
    onInputChange: onInputChangeProp,
    // dropdown
    options: optionsProp,
    emptyText,
    creatable,
    filterFn,
    selectedBehavior,
    onClose,
    onOpen,
    // other
    disabled
  });
  const rootRef = useExternRef(getRootRef);
  const inputRef = useExternRef(getRef, inputRefHook);
  const [dropdownVerticalPlacement, setDropdownVerticalPlacement] = React208.useState(placementProp);
  const onDropdownPlacementChange = React208.useCallback((placement) => {
    if (placement.startsWith("top")) {
      setDropdownVerticalPlacement("top");
    } else if (placement.startsWith("bottom")) {
      setDropdownVerticalPlacement("bottom");
    }
  }, []);
  const dropdownId = React208.useId();
  const dropdownCurrentItemId = focusedOptionIndex !== null ? `${dropdownId}-${focusedOptionIndex}` : void 0;
  const dropdownScrollBoxRef = React208.useRef(null);
  const handleFocus = (event) => {
    if (onFocusProp) {
      onFocusProp(event);
    }
    if (!readOnly) {
      setOpened(true);
      setFocusedOptionIndex(null);
    }
  };
  const handleBlur = (event) => {
    if (onBlurProp) {
      onBlurProp(event);
    }
    if (!readOnly && !event.defaultPrevented && !creatable) {
      event.preventDefault();
    }
  };
  const chipsSelectOptions = React208.useRef([]).current;
  const scrollToElement = (index2, center = false) => {
    const dropdown = dropdownScrollBoxRef.current;
    const item = chipsSelectOptions[index2];
    if (!item || !dropdown) {
      return;
    }
    const dropdownHeight = dropdown.offsetHeight;
    const scrollTop = dropdown.scrollTop;
    const itemTop = item.offsetTop;
    const itemHeight = item.offsetHeight;
    if (center) {
      dropdown.scrollTop = itemTop - dropdownHeight / 2 + itemHeight / 2;
    } else if (itemTop + itemHeight > dropdownHeight + scrollTop) {
      dropdown.scrollTop = itemTop - dropdownHeight + itemHeight;
    } else if (itemTop < scrollTop) {
      dropdown.scrollTop = itemTop;
    }
  };
  const focusOptionByIndex = (index2, oldIndex) => {
    if (index2 === oldIndex) {
      return;
    }
    const option = options[index2];
    if (isNotServicePreset(option) && option.disabled) {
      return;
    }
    scrollToElement(index2);
    setFocusedOptionIndex(index2);
  };
  const focusOption = (nextIndex, type) => {
    let index2 = nextIndex === null ? -1 : nextIndex;
    if (type === FOCUS_ACTION_NEXT) {
      const nextIndex2 = findIndexAfter(options, index2);
      index2 = nextIndex2 === -1 ? findIndexAfter(options) : nextIndex2;
    } else if (type === FOCUS_ACTION_PREV) {
      const beforeIndex = findIndexBefore(options, index2);
      index2 = beforeIndex === -1 ? findIndexBefore(options) : beforeIndex;
    }
    focusOptionByIndex(index2, focusedOptionIndex);
  };
  const handleKeyDown = (event) => {
    if (onKeyDownProp) {
      onKeyDownProp(event);
    }
    if (event.defaultPrevented || readOnly) {
      return;
    }
    switch (event.key) {
      case Keys.ARROW_UP:
      case Keys.ARROW_DOWN:
        event.preventDefault();
        if (!opened) {
          setOpened(true);
          focusOption(null, FOCUS_ACTION_NEXT);
        } else {
          focusOption(focusedOptionIndex, event.key === Keys.ARROW_UP ? FOCUS_ACTION_PREV : FOCUS_ACTION_NEXT);
        }
        break;
      case Keys.ENTER: {
        if (!opened) {
          break;
        }
        if (focusedOptionIndex != null) {
          const foundOption = options[focusedOptionIndex];
          if (foundOption && isNotServicePreset(foundOption)) {
            event.preventDefault();
            if (onChangeStart) {
              onChangeStart(event, foundOption);
            }
            addOption(foundOption);
            setFocusedOptionIndex(null);
            clearInput();
            if (closeAfterSelect) {
              setOpened(false);
            }
            break;
          }
        }
        if (!creatable) {
          event.preventDefault();
        }
        break;
      }
      case Keys.ESCAPE:
      case Keys.TAB:
        if (opened) {
          setOpened(false);
        }
    }
  };
  React208.useEffect(() => {
    if (focusedOptionIndex === null) {
      setFocusedOption(null);
    } else {
      const foundFocusedOptionIndex = options[focusedOptionIndex];
      if (foundFocusedOptionIndex && isNotServicePreset(foundFocusedOptionIndex)) {
        setFocusedOption(foundFocusedOptionIndex);
      }
    }
  }, [
    options,
    focusedOptionIndex,
    setFocusedOption
  ]);
  const onDropdownMouseLeave = React208.useCallback(() => {
    setFocusedOptionIndex(null);
  }, [
    setFocusedOptionIndex
  ]);
  const handleClickOutside = React208.useCallback(() => {
    setOpened(false);
  }, [
    setOpened
  ]);
  useGlobalOnClickOutside(handleClickOutside, opened ? rootRef : null, opened ? dropdownScrollBoxRef : null);
  const onDropdownIconClick = React208.useCallback((e) => {
    if (opened) {
      e.preventDefault();
      setOpened(false);
    }
  }, [
    opened,
    setOpened
  ]);
  const dropdownContent = React208.useMemo(() => {
    const defaultDropdownContent = options.map((option, index2) => {
      const dropdownItemId = `${dropdownId}-${index2}`;
      if (isEmptyOptionPreset(option)) {
        return (0, import_jsx_runtime186.jsx)(Footnote, {
          className: "vkuiChipsSelect__empty",
          children: option.placeholder
        }, "empty-text");
      }
      if (isCreateNewOptionPreset(option)) {
        return (0, import_jsx_runtime186.jsx)(CustomSelectOption, {
          id: dropdownItemId,
          hovered: focusedOptionIndex === index2,
          onMouseDown: () => addOptionFromInput(inputValue),
          onMouseEnter: () => setFocusedOptionIndex(index2),
          children: option.actionText
        }, "create-new-option");
      }
      return (0, import_jsx_runtime186.jsx)(React208.Fragment, {
        children: renderOption({
          id: dropdownItemId,
          disabled: option.disabled,
          hovered: focusedOption ? getOptionValue(option) === getOptionValue(focusedOption) : false,
          children: option.label,
          selected: !!value.find((selectedOption) => getOptionValue(selectedOption) === getOptionValue(option)),
          getRootRef(node) {
            if (node) {
              chipsSelectOptions[index2] = node;
            }
          },
          onMouseDown(event) {
            if (option.disabled) {
              return;
            }
            if (onChangeStart) {
              onChangeStart(event, option);
            }
            if (!event.defaultPrevented) {
              closeAfterSelect && setOpened(false);
              addOption(option);
              clearInput();
            }
          },
          onMouseEnter() {
            setFocusedOptionIndex(index2);
          }
        }, option)
      }, `${typeof option.value}-${option.value}`);
    });
    if (renderDropdown) {
      return renderDropdown({
        defaultDropdownContent
      });
    }
    return defaultDropdownContent;
  }, [
    addOption,
    addOptionFromInput,
    chipsSelectOptions,
    clearInput,
    closeAfterSelect,
    dropdownId,
    focusedOption,
    focusedOptionIndex,
    getOptionValue,
    inputValue,
    onChangeStart,
    options,
    renderDropdown,
    renderOption,
    setFocusedOptionIndex,
    setOpened,
    value
  ]);
  const openedClassNames = React208.useMemo(() => opened && dropdownOffsetDistance === 0 && (dropdownVerticalPlacement.includes("top") ? "vkuiChipsSelect--pop-up" : "vkuiChipsSelect--pop-down") || void 0, [
    dropdownOffsetDistance,
    opened,
    dropdownVerticalPlacement
  ]);
  const clearButtonShown = allowClearButton && (!!value.length || !!inputValue.length);
  return (0, import_jsx_runtime186.jsxs)(import_jsx_runtime186.Fragment, {
    children: [
      (0, import_jsx_runtime186.jsx)(ChipsInputBase, _object_spread_props(_object_spread({}, restProps), {
        disabled,
        readOnly,
        clearButtonShown,
        clearButtonTestId,
        // FormFieldProps
        id: labelledbyId,
        getRootRef: rootRef,
        className: clsx("vkuiChipsSelect", openedClassNames, className),
        status,
        after: dropdownIconProp || (0, import_jsx_runtime186.jsx)(DropdownIcon, {
          opened,
          onClick: onDropdownIconClick,
          className: clsx("vkuiChipsSelect__dropdown-icon", clearButtonShown && "vkuiChipsSelect__dropdown-icon--withOffset")
        }),
        // option
        value,
        onAddChipOption: addOptionFromInput,
        onRemoveChipOption: removeOption,
        renderChip,
        onClear: clearOptions,
        // input
        getRef: inputRef,
        inputValue,
        onInputChange,
        onFocus: handleFocus,
        onBlur: handleBlur,
        onKeyDown: handleKeyDown,
        // a11y
        role: "combobox",
        "aria-expanded": opened,
        "aria-autocomplete": "list",
        "aria-controls": opened ? dropdownId : void 0,
        "aria-activedescendant": opened ? dropdownCurrentItemId : void 0,
        "aria-haspopup": "listbox"
      })),
      opened && (0, import_jsx_runtime186.jsx)(CustomSelectDropdown, {
        "data-testid": dropdownTestId,
        targetRef: rootRef,
        placement: dropdownVerticalPlacement,
        scrollBoxRef: dropdownScrollBoxRef,
        onPlacementChange: onDropdownPlacementChange,
        onMouseLeave: onDropdownMouseLeave,
        fetching,
        autoWidth: dropdownAutoWidth,
        forcePortal: forceDropdownPortal,
        noMaxHeight,
        offsetDistance: dropdownOffsetDistance,
        overscrollBehavior,
        // a11y
        id: dropdownId,
        role: "listbox",
        "aria-labelledby": labelledbyId,
        children: dropdownContent
      })
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/Slider/Slider.js
var import_jsx_runtime188 = __toESM(require_jsx_runtime());
var React210 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Slider/SliderThumb/SliderThumb.js
var import_jsx_runtime187 = __toESM(require_jsx_runtime());
var React209 = __toESM(require_react());
var SliderThumb = (_param) => {
  var { className, getRootRef, inputProps, withTooltip, isActive } = _param, restProps = _object_without_properties(_param, [
    "className",
    "getRootRef",
    "inputProps",
    "withTooltip",
    "isActive"
  ]);
  const { focusVisible, onBlur, onFocus } = useFocusVisible();
  const focusVisibleClassNames = useFocusVisibleClassName({
    focusVisible,
    mode: "vkuiSliderThumb--focus-visible"
  });
  const [arrowRef, setArrowRef] = React209.useState(null);
  const memoizedMiddlewares = React209.useMemo(() => {
    return [
      offset3({
        crossAxis: 0,
        mainAxis: 15
      }),
      flip3(),
      shift3({
        padding: 8
      }),
      arrow3({
        element: arrowRef
      })
    ];
  }, [
    arrowRef
  ]);
  const { x: floatingDataX, y: floatingDataY, placement: resolvedPlacement, refs, strategy: floatingPositionStrategy, middlewareData: { arrow: arrowCoords }, update: updateTooltipPosition } = useFloating({
    placement: "top",
    middleware: memoizedMiddlewares
  });
  const { value: isHovered, setTrue: setHoveredTrue, setFalse: setHoveredFalse } = useBooleanState(false);
  const handleRootRef = useExternRef(getRootRef, refs.setReference);
  const shouldShowTooltip = withTooltip && (focusVisible || isHovered || isActive);
  const inputValue = inputProps && inputProps.value;
  React209.useEffect(function udpateTooltipPositionOnValueChange() {
    if (shouldShowTooltip && inputValue !== "undefined") {
      updateTooltipPosition();
    }
  }, [
    inputValue,
    updateTooltipPosition,
    shouldShowTooltip
  ]);
  return (0, import_jsx_runtime187.jsxs)(React209.Fragment, {
    children: [
      (0, import_jsx_runtime187.jsx)("span", _object_spread_props(_object_spread({}, restProps), {
        ref: handleRootRef,
        onMouseEnter: setHoveredTrue,
        onMouseLeave: setHoveredFalse,
        className: clsx("vkuiSliderThumb", focusVisibleClassNames, isActive && "vkuiSliderThumb--active", isHovered && "vkuiSliderThumb--hover", className),
        children: (0, import_jsx_runtime187.jsx)("input", _object_spread_props(_object_spread({}, inputProps), {
          type: "range",
          className: "vkuiSliderThumb__nativeInput",
          "aria-orientation": "horizontal",
          onBlur,
          onFocus
        }))
      })),
      shouldShowTooltip && (0, import_jsx_runtime187.jsx)(TooltipBase, {
        appearance: "neutral",
        getRootRef: refs.setFloating,
        style: convertFloatingDataToReactCSSProperties(floatingPositionStrategy, floatingDataX, floatingDataY),
        arrowProps: {
          coords: arrowCoords,
          placement: resolvedPlacement,
          getRootRef: setArrowRef
        },
        text: inputValue
      })
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/Slider/helpers.js
var toPercent = (v, min3, max3) => (v - min3) / (max3 - min3) * 100;
var offsetToValue = (startX, width, min3, max3, step) => {
  return rescale(startX, [
    0,
    width
  ], [
    min3,
    max3
  ], {
    step
  });
};
var restrictValueByMinMax = (value, min3, max3) => {
  if (value < min3) {
    return min3;
  }
  if (value > max3) {
    return max3;
  }
  return value;
};
var updateInternalStateValue = (prevValue, nextValue, min3, max3, dragging) => {
  const [prevStartValue, prevEndValue] = prevValue;
  if (prevEndValue === null) {
    return [
      restrictValueByMinMax(nextValue, min3, max3),
      null
    ];
  }
  switch (dragging) {
    case "start":
      return nextValue > prevEndValue ? [
        prevEndValue,
        prevEndValue
      ] : [
        restrictValueByMinMax(nextValue, min3, max3),
        prevEndValue
      ];
    case "end":
      return nextValue < prevStartValue ? [
        prevStartValue,
        prevStartValue
      ] : [
        prevStartValue,
        restrictValueByMinMax(nextValue, min3, max3)
      ];
    case null:
    default:
      return prevValue;
  }
};
var updateInternalStateValueByNativeChange = (prevValue, nextValue, dragging) => {
  const [prevStartValue, prevEndValue] = prevValue;
  switch (dragging) {
    case "start":
      return [
        nextValue,
        prevEndValue
      ];
    case "end":
      return [
        prevStartValue,
        nextValue
      ];
    case null:
    default:
      return prevValue;
  }
};
function isMultipleValues(value) {
  return value[1] !== null;
}
var snapDirection = (prevValue, nextValue, type) => {
  if (type === "start") {
    return "start";
  }
  if (type === "end") {
    return "end";
  }
  const [startRaw, endRaw] = prevValue;
  const FORCE_DIFF_VALUE = 0.1;
  const start = endRaw !== null ? startRaw - FORCE_DIFF_VALUE : startRaw;
  const end = endRaw !== null ? endRaw + FORCE_DIFF_VALUE : 0;
  return Math.abs(start - nextValue) <= Math.abs(end - nextValue) ? "start" : "end";
};
var getDraggingTypeByTargetDataset = (target) => {
  if (target) {
    if (target.dataset.type === "start") {
      return "start";
    }
    if (target.dataset.type === "end") {
      return "end";
    }
  }
  return null;
};
var resetProps = {
  "aria-label": void 0,
  "aria-valuetext": void 0,
  "aria-labelledby": void 0
};
var extractSliderAriaAttributesFromRestProps = (restProps) => {
  const ariaLabel = restProps["aria-label"];
  const ariaValueText = restProps["aria-valuetext"];
  const ariaLabelledBy = restProps["aria-labelledby"];
  return _object_spread_props(_object_spread({}, restProps, resetProps), {
    ariaLabel,
    ariaValueText,
    ariaLabelledBy
  });
};

// node_modules/@vkontakte/vkui/dist/components/Slider/Slider.js
var sizeYClassNames27 = {
  none: "vkuiSlider--sizeY-none",
  compact: "vkuiSlider--sizeY-compact"
};
var sizeClassNames4 = {
  l: "vkuiSlider--size-l",
  m: "vkuiSlider--size-m",
  s: "vkuiSlider--size-s"
};
var Slider = (_param) => {
  var { step = 1, min: min3 = 0, max: max3 = 100, value: valueProp, multiple: multipleProp, defaultValue = multipleProp ? [
    min3,
    max3
  ] : min3, disabled, className, getRootRef, getAriaLabel, getAriaValueText, onChange, withTooltip, size: size4 = "l" } = _param, restProps = _object_without_properties(_param, [
    "step",
    "min",
    "max",
    "value",
    "multiple",
    "defaultValue",
    "disabled",
    "className",
    "getRootRef",
    "getAriaLabel",
    "getAriaValueText",
    "onChange",
    "withTooltip",
    "size"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const isControlled = valueProp !== void 0;
  const [localValue, setValue] = React210.useState(defaultValue);
  const value = React210.useMemo(() => {
    const resolvedValue = isControlled ? valueProp : localValue;
    return Array.isArray(resolvedValue) ? [
      clamp2(resolvedValue[0], min3, max3),
      clamp2(resolvedValue[1], min3, max3)
    ] : [
      clamp2(resolvedValue, min3, max3),
      null
    ];
  }, [
    isControlled,
    valueProp,
    localValue,
    min3,
    max3
  ]);
  const [startValue, endValue] = value;
  const multiple = multipleProp && endValue !== null;
  const startValueInPercent = toPercent(startValue, min3, max3);
  const endReversedValueInPercent = multiple ? toPercent(endValue, min3, max3) : 0;
  const [activeThumb, setActiveThumb] = React210.useState(null);
  const gesture = React210.useRef({
    dragging: null,
    startX: 0,
    containerWidth: 0
  }).current;
  const thumbsContainerRef = useExternRef(getRootRef);
  const thumbStartInputRef = React210.useRef(null);
  const thumbEndInputRef = React210.useRef(null);
  const _extractSliderAriaAttributesFromRestProps = extractSliderAriaAttributesFromRestProps(restProps), { ariaLabel, ariaValueText, ariaLabelledBy } = _extractSliderAriaAttributesFromRestProps, restPropsWithoutAriaAttributes = _object_without_properties(_extractSliderAriaAttributesFromRestProps, [
    "ariaLabel",
    "ariaValueText",
    "ariaLabelledBy"
  ]);
  const changeValue = (nextValue, event) => {
    if (disabled || value[0] === nextValue[0] && value[1] === nextValue[1]) {
      return;
    }
    if (multipleProp) {
      if (isMultipleValues(nextValue)) {
        !isControlled && setValue(nextValue);
        onChange && onChange(nextValue, event);
      }
    } else {
      !isControlled && setValue(nextValue[0]);
      onChange && onChange(nextValue[0], event);
    }
  };
  const handlePointerStart = (event) => {
    if (!thumbsContainerRef.current) {
      return;
    }
    const { left: nextContainerX, width: nextContainerWidth } = thumbsContainerRef.current.getBoundingClientRect();
    const foundDraggingType = getDraggingTypeByTargetDataset(event.originalEvent.target);
    const nextStartX = event.startX - nextContainerX;
    const nextValue = offsetToValue(nextStartX, nextContainerWidth, min3, max3, step);
    const nextDragging = snapDirection(value, nextValue, foundDraggingType);
    gesture.dragging = nextDragging;
    gesture.containerWidth = nextContainerWidth;
    gesture.startX = nextStartX;
    const updatedInternalStateValue = updateInternalStateValue(value, nextValue, min3, max3, nextDragging);
    const [nextStartValue, nextEndValue] = updatedInternalStateValue;
    if (thumbStartInputRef.current && (foundDraggingType === "start" || nextStartValue !== startValue && nextEndValue === endValue)) {
      thumbStartInputRef.current.focus();
      event.originalEvent.preventDefault();
    } else if (thumbEndInputRef.current && (foundDraggingType === "end" || nextEndValue !== endValue && nextStartValue === startValue)) {
      thumbEndInputRef.current.focus();
      event.originalEvent.preventDefault();
    }
    changeValue(updatedInternalStateValue, event);
    event.originalEvent.stopPropagation();
    setActiveThumb(gesture.dragging);
  };
  const handlePointerMove = (event) => {
    const { startX, containerWidth, dragging } = gesture;
    const { shiftX = 0 } = event;
    const nextStartX = startX + shiftX;
    const nextValue = offsetToValue(nextStartX, containerWidth, min3, max3, step);
    changeValue(updateInternalStateValue(value, nextValue, min3, max3, dragging), event);
    event.originalEvent.stopPropagation();
    event.originalEvent.preventDefault();
  };
  const handlePointerEnd = (event) => {
    gesture.dragging = null;
    event.originalEvent.stopPropagation();
    setActiveThumb(null);
  };
  const handleChangeByNativeInput = (event) => {
    changeValue(updateInternalStateValueByNativeChange(value, Number(event.target.value), getDraggingTypeByTargetDataset(event.target)), event);
  };
  return (0, import_jsx_runtime188.jsxs)(Touch, _object_spread_props(_object_spread({
    "data-value": multiple ? `${startValue},${endValue}` : startValue
  }, restPropsWithoutAriaAttributes), {
    className: clsx("vkuiSlider", disabled && "vkuiSlider--disabled", sizeY !== "regular" && sizeYClassNames27[sizeY], sizeClassNames4[size4], className),
    onStart: disabled ? void 0 : handlePointerStart,
    onMove: disabled ? void 0 : handlePointerMove,
    onEnd: disabled ? void 0 : handlePointerEnd,
    children: [
      (0, import_jsx_runtime188.jsx)("div", {
        className: "vkuiSlider__track"
      }),
      (0, import_jsx_runtime188.jsx)("div", {
        className: "vkuiSlider__track-fill",
        style: multiple ? {
          left: `${startValueInPercent}%`,
          right: `${100 - endReversedValueInPercent}%`
        } : {
          width: `${startValueInPercent}%`
        }
      }),
      (0, import_jsx_runtime188.jsxs)("div", {
        ref: thumbsContainerRef,
        className: "vkuiSlider__thumbs",
        children: [
          (0, import_jsx_runtime188.jsx)(SliderThumb, {
            "data-type": "start",
            className: "vkuiSlider__thumb",
            style: {
              left: `${startValueInPercent}%`,
              // Меняем местами порядок слоёв, иначе, при достижении `start` и `end` 100%, `end` будет перекрывать `start`.
              zIndex: multiple && startValueInPercent >= 50 ? 2 : void 0
            },
            withTooltip,
            inputProps: {
              "data-type": "start",
              "ref": thumbStartInputRef,
              "step": step,
              "min": min3,
              "value": startValue,
              "max": multiple ? endValue : max3,
              "disabled": disabled,
              "aria-label": getAriaLabel ? getAriaLabel(0) : ariaLabel,
              "aria-valuetext": getAriaValueText ? getAriaValueText(startValue, 0) : ariaValueText,
              "aria-labelledby": ariaLabelledBy,
              "onChange": handleChangeByNativeInput
            },
            isActive: activeThumb === "start"
          }),
          multiple && (0, import_jsx_runtime188.jsx)(SliderThumb, {
            "data-type": "end",
            className: "vkuiSlider__thumb",
            style: {
              left: `${endReversedValueInPercent}%`
            },
            withTooltip,
            inputProps: {
              "data-type": "end",
              "ref": thumbEndInputRef,
              "step": step,
              "min": startValue,
              "value": endValue,
              "max": max3,
              "disabled": disabled,
              "aria-label": getAriaLabel ? getAriaLabel(1) : ariaLabel,
              "aria-valuetext": getAriaValueText ? getAriaValueText(endValue, 1) : ariaValueText,
              "aria-labelledby": ariaLabelledBy,
              "onChange": handleChangeByNativeInput
            },
            isActive: activeThumb === "end"
          })
        ]
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Textarea/Textarea.js
var import_jsx_runtime189 = __toESM(require_jsx_runtime());
var React211 = __toESM(require_react());
var sizeYClassNames28 = {
  none: "vkuiTextarea--sizeY-none",
  compact: "vkuiTextarea--sizeY-compact"
};
var Textarea = (_param) => {
  var { grow = true, style, onResize, className, getRootRef, getRef, rows = 2, maxHeight, status, onChange, align, mode, after, before, afterAlign, beforeAlign, value } = _param, restProps = _object_without_properties(_param, [
    "grow",
    "style",
    "onResize",
    "className",
    "getRootRef",
    "getRef",
    "rows",
    "maxHeight",
    "status",
    "onChange",
    "align",
    "mode",
    "after",
    "before",
    "afterAlign",
    "beforeAlign",
    "value"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const platform3 = usePlatform();
  const { window: window2 } = useDOM();
  const [refResizeTextarea, resize] = useResizeTextarea(onResize, grow);
  const elementRef = useExternRef(getRef, refResizeTextarea);
  React211.useEffect(resize, [
    resize,
    sizeY,
    platform3,
    value
  ]);
  useGlobalEventListener(window2, "resize", resize);
  return (0, import_jsx_runtime189.jsx)(FormField, {
    className: clsx("vkuiTextarea", sizeY !== "regular" && sizeYClassNames28[sizeY], align === "right" && "vkuiTextarea--align-right", align === "center" && "vkuiTextarea--align-center", className),
    style,
    getRootRef,
    disabled: restProps.disabled,
    status,
    mode,
    after,
    before,
    afterAlign,
    beforeAlign,
    maxHeight,
    children: (0, import_jsx_runtime189.jsx)(UnstyledTextField, _object_spread_props(_object_spread({}, restProps), {
      value,
      as: "textarea",
      rows,
      className: "vkuiTextarea__el",
      onChange: callMultiple(onChange, resize),
      getRootRef: elementRef
    }))
  });
};

// node_modules/@vkontakte/vkui/dist/components/SelectionControl/SelectionControl.js
var import_jsx_runtime191 = __toESM(require_jsx_runtime());
var React212 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/SelectionControl/SelectionControlLabel/SelectionControlLabel.js
var import_jsx_runtime190 = __toESM(require_jsx_runtime());
var sizeYClassNames29 = {
  none: "vkuiSelectionControlLabel--sizeY-none",
  compact: "vkuiSelectionControlLabel--sizeY-compact"
};
function SelectionControlLabel(_param) {
  var { children, titleAfter, description } = _param, restProps = _object_without_properties(_param, [
    "children",
    "titleAfter",
    "description"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime190.jsxs)(RootComponent, _object_spread_props(_object_spread({
    baseClassName: clsx("vkuiSelectionControlLabel", sizeY !== "regular" && sizeYClassNames29[sizeY])
  }, restProps), {
    children: [
      (0, import_jsx_runtime190.jsxs)("div", {
        className: "vkuiSelectionControlLabel__titleLayout",
        children: [
          (0, import_jsx_runtime190.jsx)(Text, {
            className: "vkuiSelectionControlLabel__title",
            children
          }),
          (0, import_jsx_runtime190.jsx)("div", {
            className: "vkuiSelectionControlLabel__titleAfter",
            children: titleAfter
          })
        ]
      }),
      hasReactNode(description) && (0, import_jsx_runtime190.jsx)(Footnote, {
        className: "vkuiSelectionControlLabel__description",
        children: description
      })
    ]
  }));
}

// node_modules/@vkontakte/vkui/dist/components/SelectionControl/SelectionControl.js
var sizeYClassNames30 = {
  none: "vkuiSelectionControl--sizeY-none",
  compact: "vkuiSelectionControl--sizeY-compact"
};
var SelectionControl = (restProps) => {
  const { sizeY = "none" } = useAdaptivity();
  const platform3 = usePlatform();
  return (0, import_jsx_runtime191.jsx)(Tappable, _object_spread({
    Component: "label",
    baseClassName: clsx("vkuiSelectionControl", sizeY !== "regular" && sizeYClassNames30[sizeY]),
    activeEffectDelay: platform3 === "ios" ? 100 : DEFAULT_ACTIVE_EFFECT_DELAY
  }, restProps));
};
SelectionControl.Label = SelectionControlLabel;

// node_modules/@vkontakte/vkui/dist/components/Radio/Radio.js
var import_jsx_runtime193 = __toESM(require_jsx_runtime());
var React214 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Radio/RadioInput/RadioInput.js
var import_jsx_runtime192 = __toESM(require_jsx_runtime());
var React213 = __toESM(require_react());
function RadioIcon24(props) {
  return (0, import_jsx_runtime192.jsxs)("svg", _object_spread_props(_object_spread({
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    "aria-hidden": true
  }, props), {
    children: [
      (0, import_jsx_runtime192.jsx)("circle", {
        cx: "12",
        cy: "12",
        r: "10",
        stroke: "currentColor",
        strokeWidth: "2",
        fill: "none"
      }),
      (0, import_jsx_runtime192.jsx)("circle", {
        cx: "12",
        cy: "12",
        r: "7",
        className: "vkuiRadioInput__pin",
        fill: "currentColor"
      })
    ]
  }));
}
function RadioIcon20(props) {
  return (0, import_jsx_runtime192.jsxs)("svg", _object_spread_props(_object_spread({
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    "aria-hidden": true
  }, props), {
    children: [
      (0, import_jsx_runtime192.jsx)("circle", {
        cx: "10",
        cy: "10",
        r: "7.75",
        stroke: "currentColor",
        strokeWidth: "1.5",
        fill: "none"
      }),
      (0, import_jsx_runtime192.jsx)("circle", {
        cx: "10",
        cy: "10",
        r: "5.5",
        className: "vkuiRadioInput__pin",
        fill: "currentColor"
      })
    ]
  }));
}
function RadioIcon() {
  return (0, import_jsx_runtime192.jsx)("div", {
    className: "vkuiRadioInput__icon",
    children: (0, import_jsx_runtime192.jsx)(AdaptiveIconRenderer, {
      IconCompact: RadioIcon20,
      IconRegular: RadioIcon24
    })
  });
}
function RadioInput(_param) {
  var { className, style, getRootRef, getRef } = _param, restProps = _object_without_properties(_param, [
    "className",
    "style",
    "getRootRef",
    "getRef"
  ]);
  return (0, import_jsx_runtime192.jsxs)(RootComponent, {
    className,
    style,
    getRootRef,
    children: [
      (0, import_jsx_runtime192.jsx)(VisuallyHidden, _object_spread_props(_object_spread({}, restProps), {
        Component: "input",
        type: "radio",
        baseClassName: "vkuiRadioInput__input",
        getRootRef: getRef
      })),
      (0, import_jsx_runtime192.jsx)(RadioIcon, {})
    ]
  });
}

// node_modules/@vkontakte/vkui/dist/components/Radio/Radio.js
var Radio2 = (_param) => {
  var { children, description, style, className, getRootRef, titleAfter, getRef, labelProps, hoverMode, activeMode, hasHover: hasHover2, hasActive, focusVisibleMode } = _param, restProps = _object_without_properties(_param, [
    "children",
    "description",
    "style",
    "className",
    "getRootRef",
    "titleAfter",
    "getRef",
    "labelProps",
    "hoverMode",
    "activeMode",
    "hasHover",
    "hasActive",
    "focusVisibleMode"
  ]);
  return (0, import_jsx_runtime193.jsxs)(SelectionControl, _object_spread_props(_object_spread({
    style,
    className: clsx("vkuiRadio", className),
    disabled: restProps.disabled,
    getRootRef,
    hoverMode,
    activeMode,
    hasHover: hasHover2,
    hasActive,
    focusVisibleMode
  }, labelProps), {
    children: [
      (0, import_jsx_runtime193.jsx)(RadioInput, _object_spread_props(_object_spread({}, restProps), {
        getRef
      })),
      (0, import_jsx_runtime193.jsx)(SelectionControlLabel, {
        titleAfter,
        description,
        children
      })
    ]
  }));
};
Radio2.Input = RadioInput;

// node_modules/@vkontakte/vkui/dist/components/RadioGroup/RadioGroup.js
var import_jsx_runtime194 = __toESM(require_jsx_runtime());
var React215 = __toESM(require_react());
var RadioGroup = (_param) => {
  var { mode = "vertical" } = _param, restProps = _object_without_properties(_param, [
    "mode"
  ]);
  return (0, import_jsx_runtime194.jsx)(RootComponent, _object_spread({
    baseClassName: clsx("vkuiRadioGroup", "vkuiInternalRadioGroup", mode === "horizontal" && "vkuiRadioGroup--mode-horizontal"),
    role: "radiogroup"
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Checkbox/Checkbox.js
var import_jsx_runtime197 = __toESM(require_jsx_runtime());
var React217 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Checkbox/CheckboxInput/CheckboxInput.js
var import_jsx_runtime195 = __toESM(require_jsx_runtime());
var React216 = __toESM(require_react());
function setIndeterminate(el, indeterminate) {
  el.indeterminate = indeterminate;
}
var warn21 = warnOnce("Checkbox");
function CheckboxInput(_param) {
  var { className, style, getRootRef, getRef, indeterminate, defaultIndeterminate, onChange } = _param, restProps = _object_without_properties(_param, [
    "className",
    "style",
    "getRootRef",
    "getRef",
    "indeterminate",
    "defaultIndeterminate",
    "onChange"
  ]);
  const inputRef = useExternRef(getRef);
  const platform3 = usePlatform();
  const { sizeY: adaptiveSizeY } = useAdaptivityConditionalRender();
  React216.useEffect(() => {
    const indeterminateValue = indeterminate === void 0 ? defaultIndeterminate : indeterminate;
    if (inputRef.current) {
      setIndeterminate(inputRef.current, Boolean(indeterminateValue));
    }
  }, [
    defaultIndeterminate,
    indeterminate,
    inputRef
  ]);
  const handleChange = React216.useCallback((event) => {
    if (defaultIndeterminate !== void 0 && indeterminate === void 0 && restProps.checked === void 0 && inputRef.current) {
      setIndeterminate(inputRef.current, false);
    }
    if (indeterminate !== void 0 && inputRef.current) {
      setIndeterminate(inputRef.current, Boolean(indeterminate));
    }
    onChange && onChange(event);
  }, [
    defaultIndeterminate,
    indeterminate,
    restProps.checked,
    onChange,
    inputRef
  ]);
  if (true) {
    if (defaultIndeterminate && restProps.defaultChecked) {
      warn21("defaultIndeterminate и defaultChecked не могут быть true одновременно", "error");
    }
    if (indeterminate && restProps.checked) {
      warn21("indeterminate и checked не могут быть true одновременно", "error");
    }
    if (restProps.defaultChecked && restProps.checked) {
      warn21("defaultChecked и checked не могут быть true одновременно", "error");
    }
  }
  return (0, import_jsx_runtime195.jsxs)(RootComponent, {
    baseClassName: "vkuiCheckboxInput",
    className,
    style,
    getRootRef,
    children: [
      (0, import_jsx_runtime195.jsx)(VisuallyHidden, _object_spread_props(_object_spread({}, restProps), {
        Component: "input",
        type: "checkbox",
        onChange: handleChange,
        className: "vkuiCheckboxInput__input",
        getRootRef: inputRef
      })),
      platform3 === "vkcom" ? (0, import_jsx_runtime195.jsx)(Icon20CheckBoxOn, {
        className: "vkuiCheckboxInput__icon--on"
      }) : (0, import_jsx_runtime195.jsxs)(React216.Fragment, {
        children: [
          adaptiveSizeY.compact && (0, import_jsx_runtime195.jsx)(Icon20CheckBoxOn, {
            className: clsx("vkuiCheckboxInput__icon--on", adaptiveSizeY.compact.className)
          }),
          adaptiveSizeY.regular && (0, import_jsx_runtime195.jsx)(Icon24CheckBoxOn, {
            className: clsx("vkuiCheckboxInput__icon--on", adaptiveSizeY.regular.className)
          })
        ]
      }),
      platform3 === "vkcom" ? (0, import_jsx_runtime195.jsx)(Icon20CheckBoxOff, {
        className: "vkuiCheckboxInput__icon--off"
      }) : (0, import_jsx_runtime195.jsxs)(React216.Fragment, {
        children: [
          adaptiveSizeY.compact && (0, import_jsx_runtime195.jsx)(Icon20CheckBoxOff, {
            className: clsx("vkuiCheckboxInput__icon--off", adaptiveSizeY.compact.className)
          }),
          adaptiveSizeY.regular && (0, import_jsx_runtime195.jsx)(Icon24CheckBoxOff, {
            className: clsx("vkuiCheckboxInput__icon--off", adaptiveSizeY.regular.className)
          })
        ]
      }),
      platform3 === "vkcom" ? (0, import_jsx_runtime195.jsx)(Icon20CheckBoxIndetermanate, {
        width: 20,
        height: 20,
        className: "vkuiCheckboxInput__icon--indeterminate"
      }) : (0, import_jsx_runtime195.jsxs)(React216.Fragment, {
        children: [
          adaptiveSizeY.compact && (0, import_jsx_runtime195.jsx)(Icon20CheckBoxIndetermanate, {
            className: clsx("vkuiCheckboxInput__icon--indeterminate", adaptiveSizeY.compact.className),
            width: 20,
            height: 20
          }),
          adaptiveSizeY.regular && (0, import_jsx_runtime195.jsx)(Icon20CheckBoxIndetermanate, {
            className: clsx("vkuiCheckboxInput__icon--indeterminate", adaptiveSizeY.regular.className),
            width: 24,
            height: 24
          })
        ]
      })
    ]
  });
}

// node_modules/@vkontakte/vkui/dist/components/Checkbox/CheckboxSimple/CheckboxSimple.js
var import_jsx_runtime196 = __toESM(require_jsx_runtime());
var sizeYClassNames31 = {
  none: "vkuiCheckboxSimple--sizeY-none",
  compact: "vkuiCheckboxSimple--sizeY-compact"
};
function CheckboxSimple(_param) {
  var { children, className, style, getRootRef, description, hoverMode, activeMode, hasHover: hasHover2, hasActive, focusVisibleMode, titleAfter } = _param, restProps = _object_without_properties(_param, [
    "children",
    "className",
    "style",
    "getRootRef",
    "description",
    "hoverMode",
    "activeMode",
    "hasHover",
    "hasActive",
    "focusVisibleMode",
    "titleAfter"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return (0, import_jsx_runtime196.jsx)(Tappable, {
    className: clsx(className, "vkuiCheckboxSimple", sizeY !== "regular" && sizeYClassNames31[sizeY]),
    style,
    disabled: restProps.disabled,
    getRootRef,
    hoverMode,
    activeMode,
    hasHover: hasHover2,
    hasActive,
    focusVisibleMode,
    Component: "label",
    children: (0, import_jsx_runtime196.jsx)(CheckboxInput, _object_spread({}, restProps))
  });
}

// node_modules/@vkontakte/vkui/dist/components/Checkbox/Checkbox.js
var CheckboxComponent = (_param) => {
  var { children, className, style, getRootRef, description, hoverMode, activeMode, hasHover: hasHover2, hasActive, focusVisibleMode, titleAfter } = _param, restProps = _object_without_properties(_param, [
    "children",
    "className",
    "style",
    "getRootRef",
    "description",
    "hoverMode",
    "activeMode",
    "hasHover",
    "hasActive",
    "focusVisibleMode",
    "titleAfter"
  ]);
  return (0, import_jsx_runtime197.jsxs)(SelectionControl, {
    className,
    style,
    disabled: restProps.disabled,
    getRootRef,
    hoverMode,
    activeMode,
    hasHover: hasHover2,
    hasActive,
    focusVisibleMode,
    children: [
      (0, import_jsx_runtime197.jsx)(CheckboxInput, _object_spread({}, restProps)),
      (0, import_jsx_runtime197.jsx)(SelectionControlLabel, {
        titleAfter,
        description,
        children
      })
    ]
  });
};
var Checkbox = (props) => {
  const simple = !(hasReactNode(props.children) || hasReactNode(props.description));
  if (simple) {
    return (0, import_jsx_runtime197.jsx)(CheckboxSimple, _object_spread({}, props));
  }
  return (0, import_jsx_runtime197.jsx)(CheckboxComponent, _object_spread({}, props));
};
Checkbox.Input = CheckboxInput;

// node_modules/@vkontakte/vkui/dist/components/Select/Select.js
var import_jsx_runtime203 = __toESM(require_jsx_runtime());
var React222 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/CustomSelect/CustomSelect.js
var import_jsx_runtime201 = __toESM(require_jsx_runtime());
var React220 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/CustomSelect/CustomSelectClearButton.js
var import_jsx_runtime198 = __toESM(require_jsx_runtime());
var React218 = __toESM(require_react());
var CustomSelectClearButton = (_param) => {
  var { className, onClick } = _param, restProps = _object_without_properties(_param, [
    "className",
    "onClick"
  ]);
  return (0, import_jsx_runtime198.jsx)(IconButton, _object_spread_props(_object_spread({
    Component: "button",
    label: "Очистить поле",
    onKeyDown: stopPropagation,
    type: "button",
    activeMode: "opacity",
    hoverMode: "opacity"
  }, restProps), {
    className,
    onClick: (e) => {
      stopPropagation(e);
      e.preventDefault();
      onClick();
    },
    children: (0, import_jsx_runtime198.jsx)(Icon16Cancel, {})
  }));
};

// node_modules/@vkontakte/vkui/dist/components/CustomSelect/CustomSelectInput.js
var import_jsx_runtime200 = __toESM(require_jsx_runtime());
var React219 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/SelectTypography/SelectTypography.js
var import_jsx_runtime199 = __toESM(require_jsx_runtime());
var SelectTypography = (_param) => {
  var { selectType = "default", children } = _param, restProps = _object_without_properties(_param, [
    "selectType",
    "children"
  ]);
  return (0, import_jsx_runtime199.jsx)(Text, _object_spread_props(_object_spread({
    weight: selectType === "accent" ? "2" : "3"
  }, restProps), {
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/CustomSelect/CustomSelectInput.js
var sizeYClassNames32 = {
  none: "vkuiCustomSelectInput--sizeY-none",
  compact: "vkuiCustomSelectInput--sizeY-compact"
};
var CustomSelectInput = (_param) => {
  var { align = "left", getRef, className, getRootRef, style, before, after, status, children, placeholder, selectType = "default", multiline, disabled, fetching, labelTextTestId } = _param, restProps = _object_without_properties(_param, [
    "align",
    "getRef",
    "className",
    "getRootRef",
    "style",
    "before",
    "after",
    "status",
    "children",
    "placeholder",
    "selectType",
    "multiline",
    "disabled",
    "fetching",
    "labelTextTestId"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const title = children || placeholder;
  const showLabelOrPlaceholder = !Boolean(restProps.value);
  const handleRootRef = useExternRef(getRootRef);
  const focusWithin = useFocusWithin(handleRootRef);
  const input = (0, import_jsx_runtime200.jsx)(Text, _object_spread_props(_object_spread({
    type: "text"
  }, restProps), {
    disabled: disabled && !fetching,
    readOnly: restProps.readOnly || disabled && fetching,
    Component: "input",
    normalize: false,
    className: clsx("vkuiCustomSelectInput__el", (restProps.readOnly || showLabelOrPlaceholder && !focusWithin) && "vkuiCustomSelectInput__el--cursor-pointer"),
    getRootRef: getRef,
    placeholder: children ? "" : placeholder
  }));
  const platform3 = usePlatform();
  return (0, import_jsx_runtime200.jsx)(FormField, {
    Component: "div",
    style,
    className: clsx("vkuiCustomSelectInput", align === "right" && "vkuiCustomSelectInput--align-right", align === "center" && "vkuiCustomSelectInput--align-center", !children && "vkuiCustomSelectInput--empty", multiline && "vkuiCustomSelectInput--multiline", sizeY !== "regular" && sizeYClassNames32[sizeY], before && "vkuiCustomSelectInput--hasBefore", after && "vkuiCustomSelectInput--hasAfter", className),
    getRootRef: handleRootRef,
    before,
    after,
    disabled,
    mode: getFormFieldModeFromSelectType(selectType),
    status,
    children: (0, import_jsx_runtime200.jsxs)("div", {
      className: "vkuiCustomSelectInput__input-group",
      children: [
        (0, import_jsx_runtime200.jsx)("div", {
          className: clsx("vkuiCustomSelectInput__container", className),
          tabIndex: -1,
          "aria-hidden": true,
          "data-testid": labelTextTestId,
          children: (0, import_jsx_runtime200.jsx)(SelectTypography, {
            selectType,
            className: "vkuiCustomSelectInput__title",
            children: showLabelOrPlaceholder && title
          })
        }),
        restProps.readOnly && platform3 === "ios" ? (0, import_jsx_runtime200.jsx)(VisuallyHidden, {
          children: input
        }) : input
      ]
    })
  });
};

// node_modules/@vkontakte/vkui/dist/components/CustomSelect/CustomSelect.js
var sizeYClassNames33 = {
  none: "vkuiCustomSelect--sizeY-none",
  compact: "vkuiCustomSelect--sizeY-compact"
};
var findIndexAfter2 = (options = [], startIndex = -1) => {
  if (startIndex >= options.length - 1) {
    return -1;
  }
  return options.findIndex((option, i) => i > startIndex && !option.disabled);
};
var findIndexBefore2 = (options = [], endIndex = options.length) => {
  let result = -1;
  if (endIndex <= 0) {
    return result;
  }
  for (let i = endIndex - 1; i >= 0; i--) {
    let option = options[i];
    if (!option.disabled) {
      result = i;
      break;
    }
  }
  return result;
};
var warn22 = warnOnce("CustomSelect");
var checkOptionsValueType = (options) => {
  if (new Set(options.map((item) => typeof item.value)).size > 1) {
    warn22("Некоторые значения ваших опций имеют разные типы. onChange всегда возвращает строковый тип.", "error");
  }
};
function defaultRenderOptionFn(_param) {
  var { option } = _param, props = _object_without_properties(_param, [
    "option"
  ]);
  return (0, import_jsx_runtime201.jsx)(CustomSelectOption, _object_spread({}, props));
}
var handleOptionDown = (e) => {
  e.preventDefault();
};
function findSelectedIndex(options = [], value, withClear) {
  if (withClear && value === "") {
    return -1;
  }
  var _options_findIndex;
  return (_options_findIndex = options.findIndex((item) => {
    value = typeof item.value === "number" ? Number(value) : value;
    return item.value === value;
  })) !== null && _options_findIndex !== void 0 ? _options_findIndex : -1;
}
var filter = (options, inputValue, filterFn) => {
  return typeof filterFn === "function" ? options.filter((option) => filterFn(inputValue, option)) : options;
};
function CustomSelect(props) {
  const [opened, setOpened] = React220.useState(false);
  const { before, name, className, getRef, getRootRef, popupDirection = "bottom", style, onChange, children, "onInputChange": onInputChangeProp, renderDropdown, onOpen, onClose, fetching, forceDropdownPortal, selectType = "default", autoHideScrollbar, autoHideScrollbarDelay, searchable = false, "renderOption": renderOptionProp = defaultRenderOptionFn, "options": optionsProp, emptyText = "Ничего не найдено", filterFn = defaultFilterFn, "icon": iconProp, ClearButton = CustomSelectClearButton, allowClearButton = false, dropdownOffsetDistance = 0, dropdownAutoWidth = false, noMaxHeight = false, "aria-labelledby": ariaLabelledBy, clearButtonTestId, nativeSelectTestId, defaultValue, required, getSelectInputRef, overscrollBehavior } = props, restProps = _object_without_properties(props, [
    "before",
    "name",
    "className",
    "getRef",
    "getRootRef",
    "popupDirection",
    "style",
    "onChange",
    "children",
    "onInputChange",
    "renderDropdown",
    "onOpen",
    "onClose",
    "fetching",
    "forceDropdownPortal",
    "selectType",
    "autoHideScrollbar",
    "autoHideScrollbarDelay",
    "searchable",
    "renderOption",
    "options",
    "emptyText",
    "filterFn",
    "icon",
    "ClearButton",
    "allowClearButton",
    "dropdownOffsetDistance",
    "dropdownAutoWidth",
    "noMaxHeight",
    "aria-labelledby",
    "clearButtonTestId",
    "nativeSelectTestId",
    "defaultValue",
    "required",
    "getSelectInputRef",
    "overscrollBehavior"
  ]);
  if (true) {
    checkOptionsValueType(optionsProp);
  }
  const { sizeY = "none" } = useAdaptivity();
  const containerRef = React220.useRef(null);
  const handleRootRef = useExternRef(containerRef, getRootRef);
  const scrollBoxRef = React220.useRef(null);
  const selectElRef = useExternRef(getRef);
  const optionsWrapperRef = React220.useRef(null);
  const [focusedOptionIndex, setFocusedOptionIndex] = React220.useState(-1);
  const [isControlledOutside, setIsControlledOutside] = React220.useState(props.value !== void 0);
  const [inputValue, setInputValue] = React220.useState("");
  const [nativeSelectValue, setNativeSelectValue] = React220.useState(() => {
    var _props_value2, _ref;
    return (_ref = (_props_value2 = props.value) !== null && _props_value2 !== void 0 ? _props_value2 : defaultValue) !== null && _ref !== void 0 ? _ref : allowClearButton ? "" : void 0;
  });
  const [popperPlacement, setPopperPlacement] = React220.useState(popupDirection);
  const [options, setOptions] = React220.useState(optionsProp);
  var _props_value;
  const [selectedOptionIndex, setSelectedOptionIndex] = React220.useState(findSelectedIndex(optionsProp, (_props_value = props.value) !== null && _props_value !== void 0 ? _props_value : defaultValue, allowClearButton));
  React220.useEffect(() => {
    setIsControlledOutside(props.value !== void 0);
    setNativeSelectValue((nativeSelectValue2) => {
      var _props_value2;
      return (_props_value2 = props.value) !== null && _props_value2 !== void 0 ? _props_value2 : nativeSelectValue2;
    });
  }, [
    props.value
  ]);
  useIsomorphicLayoutEffect(() => {
    if (options.some(({ value }) => nativeSelectValue === value) || allowClearButton && nativeSelectValue === "") {
      var _selectElRef_current;
      const event = new Event("change", {
        bubbles: true
      });
      (_selectElRef_current = selectElRef.current) === null || _selectElRef_current === void 0 ? void 0 : _selectElRef_current.dispatchEvent(event);
    }
  }, [
    nativeSelectValue
  ]);
  const selected = React220.useMemo(() => {
    if (!options.length) {
      return null;
    }
    return selectedOptionIndex !== void 0 ? options[selectedOptionIndex] : void 0;
  }, [
    options,
    selectedOptionIndex
  ]);
  const openedClassNames = React220.useMemo(() => opened && dropdownOffsetDistance === 0 && (popperPlacement.includes("top") ? "vkuiCustomSelect--pop-up" : "vkuiCustomSelect--pop-down") || void 0, [
    dropdownOffsetDistance,
    opened,
    popperPlacement
  ]);
  const scrollToElement = React220.useCallback((index2, center = false) => {
    const dropdown = scrollBoxRef.current;
    const optionsWrapper = optionsWrapperRef.current;
    const item = dropdown && optionsWrapper ? optionsWrapper.children[index2] : null;
    if (!item || !dropdown) {
      return;
    }
    const dropdownHeight = dropdown.offsetHeight;
    const scrollTop = dropdown.scrollTop;
    const itemTop = item.offsetTop;
    const itemHeight = item.offsetHeight;
    if (center) {
      dropdown.scrollTop = itemTop - dropdownHeight / 2 + itemHeight / 2;
    } else if (itemTop + itemHeight > dropdownHeight + scrollTop) {
      dropdown.scrollTop = itemTop - dropdownHeight + itemHeight;
    } else if (itemTop < scrollTop) {
      dropdown.scrollTop = itemTop;
    }
  }, []);
  const focusOptionByIndex = React220.useCallback((index2, scrollTo = true) => {
    var _options_length;
    if (index2 === void 0 || index2 < 0 || index2 > ((_options_length = options.length) !== null && _options_length !== void 0 ? _options_length : 0) - 1) {
      return;
    }
    const option = options[index2];
    if (option === null || option === void 0 ? void 0 : option.disabled) {
      return;
    }
    if (scrollTo) {
      scrollToElement(index2);
    }
    setFocusedOptionIndex((focusedOptionIndex2) => focusedOptionIndex2 !== index2 ? index2 : focusedOptionIndex2);
  }, [
    options,
    scrollToElement
  ]);
  const isValidIndex = React220.useCallback((index2) => {
    var _options_length;
    return index2 >= 0 && index2 < ((_options_length = options.length) !== null && _options_length !== void 0 ? _options_length : 0);
  }, [
    options.length
  ]);
  const setScrollBoxRef = React220.useCallback((ref) => {
    scrollBoxRef.current = ref;
    if (ref && selectedOptionIndex !== void 0 && isValidIndex(selectedOptionIndex)) {
      {
        scrollToElement(selectedOptionIndex, true);
      }
    }
  }, [
    isValidIndex,
    scrollToElement,
    selectedOptionIndex
  ]);
  const [keyboardInput, setKeyboardInput] = React220.useState("");
  const resetKeyboardInput = React220.useCallback(() => {
    setKeyboardInput("");
  }, []);
  const resetFocusedOption = React220.useCallback(() => {
    setFocusedOptionIndex(-1);
  }, []);
  const onKeyboardInput = React220.useCallback((key) => {
    if (!opened) {
      setOpened(true);
    }
    resetFocusedOption();
    const fullInput = keyboardInput + key;
    setKeyboardInput(fullInput);
  }, [
    keyboardInput,
    opened,
    resetFocusedOption
  ]);
  const close = React220.useCallback(() => {
    resetKeyboardInput();
    setInputValue("");
    setOpened(false);
    resetFocusedOption();
    onClose === null || onClose === void 0 ? void 0 : onClose();
  }, [
    onClose,
    resetKeyboardInput,
    resetFocusedOption
  ]);
  const selectOption = React220.useCallback((index2) => {
    const item = options[index2];
    setNativeSelectValue(item === null || item === void 0 ? void 0 : item.value);
    close();
    const shouldTriggerOnChangeWhenControlledAndInnerValueIsOutOfSync = isControlledOutside && props.value !== nativeSelectValue && nativeSelectValue === (item === null || item === void 0 ? void 0 : item.value);
    if (shouldTriggerOnChangeWhenControlledAndInnerValueIsOutOfSync) {
      var _selectElRef_current;
      const event = new Event("change", {
        bubbles: true
      });
      (_selectElRef_current = selectElRef.current) === null || _selectElRef_current === void 0 ? void 0 : _selectElRef_current.dispatchEvent(event);
    }
  }, [
    close,
    options,
    selectElRef,
    isControlledOutside,
    props.value,
    nativeSelectValue
  ]);
  const selectFocused = React220.useCallback(() => {
    if (focusedOptionIndex === void 0 || !isValidIndex(focusedOptionIndex)) {
      return;
    }
    selectOption(focusedOptionIndex);
  }, [
    focusedOptionIndex,
    isValidIndex,
    selectOption
  ]);
  const open = React220.useCallback(() => {
    setOpened(true);
    setFocusedOptionIndex(selectedOptionIndex);
    if (typeof onOpen === "function") {
      onOpen();
    }
  }, [
    onOpen,
    selectedOptionIndex
  ]);
  const onBlur = React220.useCallback(() => {
    var _selectElRef_current;
    close();
    const event = new Event("focusout", {
      bubbles: true
    });
    (_selectElRef_current = selectElRef.current) === null || _selectElRef_current === void 0 ? void 0 : _selectElRef_current.dispatchEvent(event);
  }, [
    close,
    selectElRef
  ]);
  const onFocus = React220.useCallback(() => {
    var _selectElRef_current;
    const event = new Event("focusin", {
      bubbles: true
    });
    (_selectElRef_current = selectElRef.current) === null || _selectElRef_current === void 0 ? void 0 : _selectElRef_current.dispatchEvent(event);
  }, [
    selectElRef
  ]);
  const onClick = React220.useCallback(() => {
    if (opened) {
      close();
    } else {
      open();
    }
  }, [
    close,
    open,
    opened
  ]);
  const handleKeyUp = React220.useMemo(() => debounce(resetKeyboardInput, 1e3), [
    resetKeyboardInput
  ]);
  const focusOption = React220.useCallback((type) => {
    let index2 = focusedOptionIndex;
    if (type === "next") {
      const nextIndex = findIndexAfter2(options, index2);
      index2 = nextIndex === -1 ? findIndexAfter2(options) : nextIndex;
    } else if (type === "prev") {
      const beforeIndex = findIndexBefore2(options, index2);
      index2 = beforeIndex === -1 ? findIndexBefore2(options) : beforeIndex;
    }
    focusOptionByIndex(index2);
  }, [
    focusOptionByIndex,
    focusedOptionIndex,
    options
  ]);
  React220.useEffect(function updateOptionsAndSelectedOptionIndex() {
    var _props_value2, _ref;
    const value = (_ref = (_props_value2 = props.value) !== null && _props_value2 !== void 0 ? _props_value2 : nativeSelectValue) !== null && _ref !== void 0 ? _ref : defaultValue;
    const options2 = searchable && inputValue !== void 0 ? filter(optionsProp, inputValue, filterFn) : optionsProp;
    setOptions(options2);
    setSelectedOptionIndex(findSelectedIndex(options2, value, allowClearButton));
  }, [
    filterFn,
    inputValue,
    nativeSelectValue,
    optionsProp,
    defaultValue,
    props.value,
    searchable,
    allowClearButton
  ]);
  const onNativeSelectChange = (e) => {
    const newSelectedOptionIndex = findSelectedIndex(options, e.currentTarget.value, allowClearButton);
    if (selectedOptionIndex !== newSelectedOptionIndex) {
      if (!isControlledOutside) {
        setSelectedOptionIndex(newSelectedOptionIndex);
      }
      onChange === null || onChange === void 0 ? void 0 : onChange(e);
    }
  };
  const onInputChange = React220.useCallback((e) => {
    onInputChangeProp && onInputChangeProp(e);
    const options2 = filter(optionsProp, e.target.value, filterFn);
    setOptions(options2);
    setSelectedOptionIndex(findSelectedIndex(options2, nativeSelectValue, allowClearButton));
    setInputValue(e.target.value);
  }, [
    filterFn,
    nativeSelectValue,
    onInputChangeProp,
    optionsProp,
    allowClearButton
  ]);
  const areOptionsShown = React220.useCallback(() => {
    return scrollBoxRef.current !== null;
  }, []);
  const handleKeyDownSelect = React220.useCallback((event) => {
    if (event.key.length === 1 && event.key !== " ") {
      onKeyboardInput(event.key);
      return;
    }
    [
      "ArrowUp",
      "ArrowDown",
      "Escape",
      "Enter"
    ].includes(event.key) && areOptionsShown() && event.preventDefault();
    switch (event.key) {
      case "ArrowUp":
        if (opened) {
          areOptionsShown() && focusOption("prev");
        } else {
          open();
        }
        break;
      case "ArrowDown":
        if (opened) {
          areOptionsShown() && focusOption("next");
        } else {
          open();
        }
        break;
      case "Escape":
        close();
        break;
      case "Backspace":
      case "Delete": {
        if (!opened) {
          setOpened(true);
        }
        resetFocusedOption();
        break;
      }
      case "Enter":
      case "Spacebar":
      case " ":
        if (opened) {
          areOptionsShown() && selectFocused();
        } else {
          open();
        }
        break;
    }
  }, [
    areOptionsShown,
    close,
    focusOption,
    onKeyboardInput,
    open,
    opened,
    selectFocused,
    resetFocusedOption
  ]);
  const handleOptionClick = React220.useCallback((e) => {
    var _e_currentTarget_parentNode;
    const index2 = Array.prototype.indexOf.call((_e_currentTarget_parentNode = e.currentTarget.parentNode) === null || _e_currentTarget_parentNode === void 0 ? void 0 : _e_currentTarget_parentNode.children, e.currentTarget);
    const option = options[index2];
    if (option && !option.disabled) {
      selectOption(index2);
    }
  }, [
    options,
    selectOption
  ]);
  const prevMousePositionRef = React220.useRef({
    x: 0,
    y: 0
  });
  const focusOptionOnMouseMove = React220.useCallback((e, index2) => {
    const isMouseChangedPosition = Math.abs(prevMousePositionRef.current.x - e.clientX) >= 1 || Math.abs(prevMousePositionRef.current.y - e.clientY) >= 1;
    if (isMouseChangedPosition) {
      focusOptionByIndex(index2, false);
    }
    prevMousePositionRef.current = {
      x: e.clientX,
      y: e.clientY
    };
  }, [
    focusOptionByIndex
  ]);
  const popupAriaId = React220.useId();
  const renderOption = React220.useCallback((option, index2) => {
    const hovered = index2 === focusedOptionIndex;
    const selected2 = index2 === selectedOptionIndex;
    return (0, import_jsx_runtime201.jsx)(React220.Fragment, {
      children: renderOptionProp({
        option,
        hovered,
        children: option.label,
        selected: selected2,
        disabled: option.disabled,
        onClick: handleOptionClick,
        onMouseDown: handleOptionDown,
        // Используем `onMouseMove` вместо `onMouseEnter/onMouseOver`.
        // Потому что если при навигации с клавиатуры курсор наведён на
        // список, то при первом автоматическом скролле списка вызывается событие MouseOver/MouseEnter
        // обработчик которого фокусирует опцию под курсором, хотя при навигация с клавиатуры пользователь мог уйти дальше по списку, это путает.
        // Причём координаты события меняются на пару пикселей по сравнению с прошлым вызовом,
        // а значит нельзя на них опираться, чтобы запретить обработку такого события.
        // C mousemove такой проблемы нет, что позволяет реализовать поведение при наведении с клавиатуры и при наведении мышью идентично `<select>`.
        onMouseMove: (e) => focusOptionOnMouseMove(e, index2),
        id: `${popupAriaId}-${option.value}`
      })
    }, `${typeof option.value}-${option.value}`);
  }, [
    focusedOptionIndex,
    handleOptionClick,
    focusOptionOnMouseMove,
    renderOptionProp,
    selectedOptionIndex,
    popupAriaId
  ]);
  const resolvedContent = React220.useMemo(() => {
    const defaultDropdownContent = options.length > 0 ? (0, import_jsx_runtime201.jsx)("div", {
      ref: optionsWrapperRef,
      children: options.map(renderOption)
    }) : (0, import_jsx_runtime201.jsx)(Footnote, {
      className: "vkuiCustomSelect__empty",
      children: emptyText
    });
    if (typeof renderDropdown === "function") {
      return renderDropdown({
        defaultDropdownContent
      });
    } else {
      return defaultDropdownContent;
    }
  }, [
    emptyText,
    options,
    renderDropdown,
    renderOption
  ]);
  const selectInputRef = useExternRef(getSelectInputRef);
  const controlledValueSet = isControlledOutside && props.value !== "";
  const uncontrolledValueSet = !isControlledOutside && nativeSelectValue !== "";
  const clearButtonShown = allowClearButton && !opened && (controlledValueSet || uncontrolledValueSet);
  const clearButton = React220.useMemo(() => {
    if (!clearButtonShown) {
      return null;
    }
    return (0, import_jsx_runtime201.jsx)(ClearButton, {
      className: iconProp === void 0 ? "vkuiCustomSelect--clear-icon" : void 0,
      onClick: function clearSelectState() {
        setNativeSelectValue("");
        setInputValue("");
        selectInputRef.current && selectInputRef.current.focus();
      },
      disabled: restProps.disabled,
      "data-testid": clearButtonTestId
    });
  }, [
    clearButtonShown,
    ClearButton,
    iconProp,
    restProps.disabled,
    clearButtonTestId,
    selectInputRef
  ]);
  const icon = React220.useMemo(() => {
    if (iconProp !== void 0) {
      return iconProp;
    }
    return (0, import_jsx_runtime201.jsx)(DropdownIcon, {
      className: clearButtonShown ? "vkuiCustomSelect__dropdown-icon" : void 0,
      opened
    });
  }, [
    clearButtonShown,
    iconProp,
    opened
  ]);
  const afterIcons = (icon || clearButtonShown) && (0, import_jsx_runtime201.jsxs)(React220.Fragment, {
    children: [
      clearButton,
      icon
    ]
  });
  const { document: document2 } = useDOM();
  const passClickAndFocusToInputOnClick = React220.useCallback((e) => {
    if (!selectInputRef.current || !document2) {
      return;
    }
    const clickTargetIsNotAnInput = e.target !== selectInputRef.current;
    if (clickTargetIsNotAnInput) {
      selectInputRef.current.click();
      const inputIsNotFocused = document2.activeElement !== selectInputRef.current;
      if (inputIsNotFocused) {
        selectInputRef.current.focus();
      }
    }
  }, [
    document2,
    selectInputRef
  ]);
  const preventInputBlurWhenClickInsideFocusedSelectArea = (e) => {
    const isInputFocused = document2 && document2.activeElement === selectInputRef.current;
    if (isInputFocused) {
      e.preventDefault();
    }
  };
  const ariaActiveDescendantOptionIndex = focusedOptionIndex !== -1 ? focusedOptionIndex : void 0;
  const ariaActiveDescendantId = ariaActiveDescendantOptionIndex !== void 0 ? options[ariaActiveDescendantOptionIndex] && options[ariaActiveDescendantOptionIndex].value : null;
  const selectInputAriaProps = {
    "role": "combobox",
    "aria-controls": popupAriaId,
    "aria-owns": popupAriaId,
    "aria-expanded": opened,
    "aria-activedescendant": ariaActiveDescendantId && opened ? `${popupAriaId}-${ariaActiveDescendantId}` : void 0,
    "aria-labelledby": ariaLabelledBy,
    "aria-haspopup": "listbox",
    "aria-autocomplete": "none"
  };
  const focusWithin = useFocusWithin(handleRootRef);
  return (0, import_jsx_runtime201.jsxs)("div", {
    className: clsx("vkuiCustomSelect", sizeY !== "regular" && sizeYClassNames33[sizeY], className),
    style,
    ref: handleRootRef,
    onClick: passClickAndFocusToInputOnClick,
    onMouseDown: preventInputBlurWhenClickInsideFocusedSelectArea,
    children: [
      focusWithin && selected && !opened && (0, import_jsx_runtime201.jsx)(VisuallyHidden, {
        "aria-live": "polite",
        children: selected.label
      }),
      (0, import_jsx_runtime201.jsx)(CustomSelectInput, _object_spread_props(_object_spread({
        autoComplete: "off",
        autoCapitalize: "none",
        autoCorrect: "off",
        spellCheck: "false"
      }, restProps, selectInputAriaProps), {
        getRef: selectInputRef,
        onFocus,
        onBlur,
        className: openedClassNames,
        readOnly: !searchable,
        fetching,
        value: inputValue,
        onKeyUp: handleKeyUp,
        onKeyDown: handleKeyDownSelect,
        onChange: onInputChange,
        onClick,
        before,
        after: afterIcons,
        selectType,
        children: selected === null || selected === void 0 ? void 0 : selected.label
      })),
      (0, import_jsx_runtime201.jsxs)("select", {
        ref: selectElRef,
        name,
        onChange: onNativeSelectChange,
        onBlur: props.onBlur,
        onFocus: props.onFocus,
        onClick: props.onClick,
        value: nativeSelectValue,
        "aria-hidden": true,
        className: "vkuiCustomSelect__control",
        "data-testid": nativeSelectTestId,
        required,
        children: [
          allowClearButton && (0, import_jsx_runtime201.jsx)("option", {
            value: ""
          }, ""),
          optionsProp.map((item) => (0, import_jsx_runtime201.jsx)("option", {
            value: item.value
          }, `${item.value}`))
        ]
      }),
      opened && (0, import_jsx_runtime201.jsx)(CustomSelectDropdown, {
        targetRef: containerRef,
        placement: popperPlacement,
        scrollBoxRef: setScrollBoxRef,
        onPlacementChange: setPopperPlacement,
        onMouseLeave: resetFocusedOption,
        fetching,
        overscrollBehavior,
        offsetDistance: dropdownOffsetDistance,
        autoWidth: dropdownAutoWidth,
        forcePortal: forceDropdownPortal,
        autoHideScrollbar,
        autoHideScrollbarDelay,
        noMaxHeight,
        role: "listbox",
        id: popupAriaId,
        "aria-labelledby": ariaLabelledBy,
        tabIndex: -1,
        children: resolvedContent
      })
    ]
  });
}

// node_modules/@vkontakte/vkui/dist/components/NativeSelect/NativeSelect.js
var import_jsx_runtime202 = __toESM(require_jsx_runtime());
var React221 = __toESM(require_react());
var sizeYClassNames34 = {
  none: "vkuiSelect--sizeY-none",
  compact: "vkuiSelect--sizeY-compact"
};
var NativeSelect = (_param) => {
  var { style, align, placeholder, children, className, getRef, getRootRef, disabled, multiline, selectType = "default", status, icon = (0, import_jsx_runtime202.jsx)(DropdownIcon, {}), before, onChange } = _param, restProps = _object_without_properties(_param, [
    "style",
    "align",
    "placeholder",
    "children",
    "className",
    "getRef",
    "getRootRef",
    "disabled",
    "multiline",
    "selectType",
    "status",
    "icon",
    "before",
    "onChange"
  ]);
  const [title, setTitle] = React221.useState("");
  const [empty, setEmpty] = React221.useState(false);
  const selectRef = useExternRef(getRef);
  const { sizeY = "none" } = useAdaptivity();
  const checkSelectedOption = () => {
    var _selectRef_current;
    const selectedOption = (_selectRef_current = selectRef.current) === null || _selectRef_current === void 0 ? void 0 : _selectRef_current.options[selectRef.current.selectedIndex];
    if (selectedOption) {
      setTitle(selectedOption.text);
      setEmpty(selectedOption.value === "" && placeholder != null);
    }
  };
  useIsomorphicLayoutEffect(checkSelectedOption, [
    children
  ]);
  return (0, import_jsx_runtime202.jsxs)(FormField, {
    Component: "div",
    className: clsx("vkuiSelect", "vkuiInternalNativeSelect", before && "vkuiSelect--hasBefore", empty && "vkuiSelect--empty", multiline && "vkuiSelect--multiline", align === "center" && "vkuiSelect--align-center", align === "right" && "vkuiSelect--align-right", sizeY !== "regular" && sizeYClassNames34[sizeY], className),
    style,
    getRootRef,
    disabled,
    before,
    after: icon,
    status,
    mode: getFormFieldModeFromSelectType(selectType),
    children: [
      (0, import_jsx_runtime202.jsxs)("select", _object_spread_props(_object_spread({}, restProps), {
        disabled,
        className: "vkuiSelect__el",
        onChange: callMultiple(onChange, checkSelectedOption),
        ref: selectRef,
        children: [
          placeholder && (0, import_jsx_runtime202.jsx)("option", {
            value: "",
            children: placeholder
          }),
          children
        ]
      })),
      (0, import_jsx_runtime202.jsx)("div", {
        className: "vkuiSelect__container",
        "aria-hidden": true,
        children: (0, import_jsx_runtime202.jsx)(SelectTypography, {
          className: "vkuiSelect__title",
          selectType,
          children: title
        })
      })
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/Select/Select.js
var Select = (_param) => {
  var { children, className } = _param, props = _object_without_properties(_param, [
    "children",
    "className"
  ]);
  const { options = [], searchable, emptyText, onInputChange, filterFn, popupDirection, renderOption, renderDropdown, fetching, onClose, onOpen, icon, ClearButton, allowClearButton, clearButtonTestId, dropdownOffsetDistance, dropdownAutoWidth, forceDropdownPortal, noMaxHeight, autoHideScrollbar, autoHideScrollbarDelay, labelTextTestId, nativeSelectTestId, after, mode, pattern, minLength, maxLength, readOnly, getSelectInputRef, overscrollBehavior, beforeAlign, afterAlign } = props, restProps = _object_without_properties(props, [
    "options",
    "searchable",
    "emptyText",
    "onInputChange",
    "filterFn",
    "popupDirection",
    "renderOption",
    "renderDropdown",
    "fetching",
    "onClose",
    "onOpen",
    "icon",
    "ClearButton",
    "allowClearButton",
    "clearButtonTestId",
    "dropdownOffsetDistance",
    "dropdownAutoWidth",
    "forceDropdownPortal",
    "noMaxHeight",
    "autoHideScrollbar",
    "autoHideScrollbarDelay",
    "labelTextTestId",
    "nativeSelectTestId",
    "after",
    "mode",
    "pattern",
    "minLength",
    "maxLength",
    "readOnly",
    "getSelectInputRef",
    "overscrollBehavior",
    "beforeAlign",
    "afterAlign"
  ]);
  const { deviceType } = useAdaptivityConditionalRender();
  const nativeProps = restProps;
  return (0, import_jsx_runtime203.jsxs)(React222.Fragment, {
    children: [
      deviceType.desktop && (0, import_jsx_runtime203.jsx)(CustomSelect, _object_spread({
        className: clsx(className, deviceType.desktop.className)
      }, props)),
      deviceType.mobile && (0, import_jsx_runtime203.jsx)(NativeSelect, _object_spread_props(_object_spread({
        className: clsx(className, deviceType.mobile.className)
      }, nativeProps), {
        children: options.map(({ label, value, disabled }) => (0, import_jsx_runtime203.jsx)("option", {
          value,
          disabled,
          children: label
        }, `${value}`))
      }))
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/SelectMimicry/SelectMimicry.js
var import_jsx_runtime204 = __toESM(require_jsx_runtime());
var React223 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useAutoFocus.js
function useAutoFocus(ref, autoFocus) {
  useIsomorphicLayoutEffect(() => {
    if (!autoFocus || !ref.current) {
      return;
    }
    ref.current.focus();
  }, []);
}

// node_modules/@vkontakte/vkui/dist/components/SelectMimicry/SelectMimicry.js
var sizeYClassNames35 = {
  none: "vkuiSelect--sizeY-none",
  compact: "vkuiSelect--sizeY-compact"
};
var SelectMimicry = (_param) => {
  var { tabIndex = 0, placeholder, children, align, getRootRef, multiline, disabled, onClick, before, after = (0, import_jsx_runtime204.jsx)(DropdownIcon, {}), selectType = "default", status, className, autoFocus } = _param, restProps = _object_without_properties(_param, [
    "tabIndex",
    "placeholder",
    "children",
    "align",
    "getRootRef",
    "multiline",
    "disabled",
    "onClick",
    "before",
    "after",
    "selectType",
    "status",
    "className",
    "autoFocus"
  ]);
  const rootRef = useExternRef(getRootRef);
  const { sizeY = "none" } = useAdaptivity();
  const title = children || placeholder;
  useAutoFocus(rootRef, autoFocus);
  return (0, import_jsx_runtime204.jsx)(FormField, _object_spread_props(_object_spread({}, restProps), {
    tabIndex: disabled ? void 0 : tabIndex,
    className: clsx("vkuiSelect", sizeY !== "regular" && sizeYClassNames35[sizeY], !children && "vkuiSelect--empty", multiline && "vkuiSelect--multiline", align === "center" && "vkuiSelect--align-center", align === "right" && "vkuiSelect--align-right", before && "vkuiSelect--hasBefore", className),
    getRootRef: rootRef,
    onClick: disabled ? void 0 : onClick,
    disabled,
    before,
    after,
    mode: getFormFieldModeFromSelectType(selectType),
    status,
    children: (0, import_jsx_runtime204.jsx)("div", {
      className: "vkuiSelect__container",
      children: (0, import_jsx_runtime204.jsx)(SelectTypography, {
        selectType,
        className: "vkuiSelect__title",
        children: title
      })
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/DatePicker/DatePicker.js
var import_jsx_runtime205 = __toESM(require_jsx_runtime());
var React224 = __toESM(require_react());
var DefaultMonths = [
  "Января",
  "Февраля",
  "Марта",
  "Апреля",
  "Мая",
  "Июня",
  "Июля",
  "Августа",
  "Сентября",
  "Октября",
  "Ноября",
  "Декабря"
];
var DEFAULT_EMPTY_DATE = {
  day: 0,
  month: 0,
  year: 0
};
function convertToInputFormat(value) {
  if (!value) {
    return void 0;
  }
  const { day = 0, month = 0, year = 0 } = value;
  return `${year}-${leadingZero2(month)}-${leadingZero2(day)}`;
}
function parseInputDate(date) {
  if (date.length === 0) {
    return DEFAULT_EMPTY_DATE;
  }
  const splited = date.split("-");
  return {
    day: Number(splited[2]),
    month: Number(splited[1]),
    year: Number(splited[0])
  };
}
function getMonthMaxDay(month, year) {
  return month ? new Date(year || 2016, month, 0).getDate() : 31;
}
var DatePickerCustom = (_param) => {
  var { name, min: min3 = {
    day: 0,
    month: 0,
    year: 0
  }, max: max3 = {
    day: 31,
    month: 12,
    year: 2100
  }, dayPlaceholder, monthPlaceholder, yearPlaceholder, popupDirection, value, monthNames, onDateChange, disabled, defaultValue = DEFAULT_EMPTY_DATE } = _param, restProps = _object_without_properties(_param, [
    "name",
    "min",
    "max",
    "dayPlaceholder",
    "monthPlaceholder",
    "yearPlaceholder",
    "popupDirection",
    "value",
    "monthNames",
    "onDateChange",
    "disabled",
    "defaultValue"
  ]);
  const isControlled = value !== void 0;
  const [internalValue, setInternalValue] = useCustomEnsuredControl({
    value,
    defaultValue
  });
  const hiddenInput = React224.useRef(null);
  const onSelectChange = (e) => {
    const nextDate = {
      day: internalValue.day,
      month: internalValue.month,
      year: internalValue.year
    };
    nextDate[e.target.name] = Number(e.target.value);
    nextDate.day = nextDate.day ? clamp2(nextDate.day, 1, getMonthMaxDay(nextDate.month, nextDate.year)) : nextDate.day;
    setInternalValue(nextDate);
    onDateChange === null || onDateChange === void 0 ? void 0 : onDateChange(nextDate);
  };
  const dayOptions = range(1, getMonthMaxDay(internalValue.month, internalValue.year)).map((value2) => ({
    label: String(value2),
    value: value2
  }));
  const monthOptions = (monthNames || DefaultMonths).map((name2, index2) => ({
    label: name2,
    value: index2 + 1
  }));
  const yearOptions = range(max3.year, min3.year).map((value2) => ({
    label: String(value2),
    value: value2
  }));
  useNativeFormResetListener(hiddenInput, () => {
    if (!isControlled) {
      setInternalValue(defaultValue);
    }
  });
  return (0, import_jsx_runtime205.jsxs)(RootComponent, _object_spread_props(_object_spread({
    baseClassName: "vkuiDatePicker"
  }, restProps), {
    children: [
      (0, import_jsx_runtime205.jsxs)("div", {
        className: "vkuiDatePicker__container",
        children: [
          (0, import_jsx_runtime205.jsx)("div", {
            className: "vkuiDatePicker__day",
            children: (0, import_jsx_runtime205.jsx)(CustomSelect, {
              name: "day",
              value: internalValue.day,
              options: dayOptions,
              placeholder: dayPlaceholder,
              popupDirection,
              onChange: onSelectChange,
              disabled
            })
          }),
          (0, import_jsx_runtime205.jsx)("div", {
            className: "vkuiDatePicker__month",
            children: (0, import_jsx_runtime205.jsx)(CustomSelect, {
              className: "vkuiDatePicker__monthSelect",
              name: "month",
              value: internalValue.month,
              options: monthOptions,
              placeholder: monthPlaceholder,
              popupDirection,
              onChange: onSelectChange,
              disabled
            })
          }),
          (0, import_jsx_runtime205.jsx)("div", {
            className: "vkuiDatePicker__year",
            children: (0, import_jsx_runtime205.jsx)(CustomSelect, {
              name: "year",
              value: internalValue.year,
              options: yearOptions,
              placeholder: yearPlaceholder,
              popupDirection,
              onChange: onSelectChange,
              disabled
            })
          })
        ]
      }),
      (0, import_jsx_runtime205.jsx)("input", {
        type: "hidden",
        name,
        ref: hiddenInput,
        value: convertToInputFormat(internalValue)
      })
    ]
  }));
};
var DatePickerNative = (_param) => {
  var { min: min3 = {
    day: 0,
    month: 0,
    year: 0
  }, max: max3 = {
    day: 31,
    month: 12,
    year: 2100
  }, monthNames, popupDirection, dayPlaceholder, monthPlaceholder, yearPlaceholder, value, defaultValue = DEFAULT_EMPTY_DATE, onDateChange } = _param, restProps = _object_without_properties(_param, [
    "min",
    "max",
    "monthNames",
    "popupDirection",
    "dayPlaceholder",
    "monthPlaceholder",
    "yearPlaceholder",
    "value",
    "defaultValue",
    "onDateChange"
  ]);
  const onStringChange = React224.useCallback((e) => {
    onDateChange === null || onDateChange === void 0 ? void 0 : onDateChange(parseInputDate(e.currentTarget.value));
  }, [
    onDateChange
  ]);
  const inputProps = restProps;
  const valueProps = value ? {
    value: convertToInputFormat(value)
  } : {
    defaultValue: convertToInputFormat(defaultValue)
  };
  return (0, import_jsx_runtime205.jsx)(Input, _object_spread_props(_object_spread({}, inputProps, valueProps), {
    type: "date",
    onChange: onStringChange,
    min: convertToInputFormat(min3),
    max: convertToInputFormat(max3)
  }));
};
var DatePicker = (_param) => {
  var { onDateChange } = _param, props = _object_without_properties(_param, [
    "onDateChange"
  ]);
  const hasPointer = useAdaptivityHasPointer();
  const onChange = (update) => {
    onDateChange && onDateChange(_object_spread({}, update));
  };
  const Cmp = hasPointer ? DatePickerCustom : DatePickerNative;
  return (0, import_jsx_runtime205.jsx)(Cmp, _object_spread_props(_object_spread({}, props), {
    onDateChange: onChange
  }));
};

// node_modules/@vkontakte/vkui/dist/components/SegmentedControl/SegmentedControl.js
var import_jsx_runtime207 = __toESM(require_jsx_runtime());
var React226 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/SegmentedControl/SegmentedControlOption/SegmentedControlOption.js
var import_jsx_runtime206 = __toESM(require_jsx_runtime());
var React225 = __toESM(require_react());
var SegmentedControlOption = (_param) => {
  var { getRef, className, style, children, getRootRef, before } = _param, restProps = _object_without_properties(_param, [
    "getRef",
    "className",
    "style",
    "children",
    "getRootRef",
    "before"
  ]);
  return (0, import_jsx_runtime206.jsxs)(Clickable, {
    Component: "label",
    baseClassName: "vkuiSegmentedControlOption",
    hoverClassName: "vkuiSegmentedControlOption--hover",
    activeClassName: "vkuiSegmentedControlOption--hover",
    className,
    getRootRef,
    style,
    children: [
      (0, import_jsx_runtime206.jsx)(VisuallyHidden, _object_spread_props(_object_spread({}, restProps), {
        Component: "input",
        getRootRef: getRef,
        type: "radio"
      })),
      hasReactNode(before) && (0, import_jsx_runtime206.jsx)("div", {
        className: "vkuiSegmentedControlOption__before",
        children: before
      }),
      (0, import_jsx_runtime206.jsx)(Headline, {
        level: "2",
        weight: "2",
        children
      })
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/SegmentedControl/SegmentedControl.js
var _options_;
var sizeYClassNames36 = {
  none: "vkuiSegmentedControl--sizeY-none",
  regular: "vkuiSegmentedControl--sizeY-regular"
};
var warn23 = warnOnce("SegmentedControl");
var SegmentedControl = (_param) => {
  var { size: size4 = "l", name, options, defaultValue = (_options_ = options[0]) === null || _options_ === void 0 ? void 0 : _options_.value, children, onChange: onChangeProp, value: valueProp } = _param, restProps = _object_without_properties(_param, [
    "size",
    "name",
    "options",
    "defaultValue",
    "children",
    "onChange",
    "value"
  ]);
  const id = React226.useId();
  const [value, onChange] = useCustomEnsuredControl({
    onChange: onChangeProp,
    value: valueProp,
    defaultValue
  });
  const { sizeY = "none" } = useAdaptivity();
  const actualIndex = options.findIndex((option) => option.value === value);
  useIsomorphicLayoutEffect(() => {
    if (actualIndex === -1 && true) {
      warn23("defaultValue: такого значения нет среди опций!", "error");
    }
  }, [
    actualIndex
  ]);
  const translateX = `translateX(${100 * actualIndex}%)`;
  return (0, import_jsx_runtime207.jsx)(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: clsx("vkuiSegmentedControl", sizeY !== "compact" && sizeYClassNames36[sizeY], size4 === "l" && "vkuiSegmentedControl--size-l"),
    children: (0, import_jsx_runtime207.jsxs)("div", {
      role: "radiogroup",
      className: "vkuiSegmentedControl__in",
      children: [
        actualIndex > -1 && (0, import_jsx_runtime207.jsx)("div", {
          "aria-hidden": true,
          className: "vkuiSegmentedControl__slider",
          style: {
            width: `${100 / options.length}%`,
            transform: translateX
          }
        }),
        options.map((_param2) => {
          var { label } = _param2, optionProps = _object_without_properties(_param2, [
            "label"
          ]);
          return (0, import_jsx_runtime207.jsx)(SegmentedControlOption, _object_spread_props(_object_spread({}, optionProps), {
            name: name !== null && name !== void 0 ? name : id,
            checked: value === optionProps.value,
            onChange: () => onChange(optionProps.value),
            children: label
          }), `${optionProps.value}`);
        })
      ]
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Calendar/Calendar.js
var import_jsx_runtime213 = __toESM(require_jsx_runtime());
var React234 = __toESM(require_react());

// node_modules/date-fns/toDate.mjs
function toDate(argument) {
  const argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new argument.constructor(+argument);
  } else if (typeof argument === "number" || argStr === "[object Number]" || typeof argument === "string" || argStr === "[object String]") {
    return new Date(argument);
  } else {
    return /* @__PURE__ */ new Date(NaN);
  }
}

// node_modules/date-fns/constructFrom.mjs
function constructFrom(date, value) {
  if (date instanceof Date) {
    return new date.constructor(value);
  } else {
    return new Date(value);
  }
}

// node_modules/date-fns/addDays.mjs
function addDays2(date, amount) {
  const _date = toDate(date);
  if (isNaN(amount)) return constructFrom(date, NaN);
  if (!amount) {
    return _date;
  }
  _date.setDate(_date.getDate() + amount);
  return _date;
}

// node_modules/date-fns/addMonths.mjs
function addMonths(date, amount) {
  const _date = toDate(date);
  if (isNaN(amount)) return constructFrom(date, NaN);
  if (!amount) {
    return _date;
  }
  const dayOfMonth = _date.getDate();
  const endOfDesiredMonth = constructFrom(date, _date.getTime());
  endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
  const daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    _date.setFullYear(
      endOfDesiredMonth.getFullYear(),
      endOfDesiredMonth.getMonth(),
      dayOfMonth
    );
    return _date;
  }
}

// node_modules/date-fns/constants.mjs
var daysInYear = 365.2425;
var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
var minTime = -maxTime;
var millisecondsInWeek = 6048e5;
var millisecondsInMinute = 6e4;
var millisecondsInHour = 36e5;
var millisecondsInSecond = 1e3;
var secondsInHour = 3600;
var secondsInDay = secondsInHour * 24;
var secondsInWeek = secondsInDay * 7;
var secondsInYear = secondsInDay * daysInYear;
var secondsInMonth = secondsInYear / 12;
var secondsInQuarter = secondsInMonth * 3;

// node_modules/date-fns/_lib/defaultOptions.mjs
var defaultOptions2 = {};
function getDefaultOptions() {
  return defaultOptions2;
}

// node_modules/date-fns/startOfWeek.mjs
function startOfWeek(date, options) {
  var _a, _b, _c, _d;
  const defaultOptions3 = getDefaultOptions();
  const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions3.weekStartsOn ?? ((_d = (_c = defaultOptions3.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
  const _date = toDate(date);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// node_modules/date-fns/startOfISOWeek.mjs
function startOfISOWeek(date) {
  return startOfWeek(date, { weekStartsOn: 1 });
}

// node_modules/date-fns/getISOWeekYear.mjs
function getISOWeekYear(date) {
  const _date = toDate(date);
  const year = _date.getFullYear();
  const fourthOfJanuaryOfNextYear = constructFrom(date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  const fourthOfJanuaryOfThisYear = constructFrom(date, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/startOfDay.mjs
function startOfDay(date) {
  const _date = toDate(date);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.mjs
function getTimezoneOffsetInMilliseconds(date) {
  const _date = toDate(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}

// node_modules/date-fns/startOfISOWeekYear.mjs
function startOfISOWeekYear(date) {
  const year = getISOWeekYear(date);
  const fourthOfJanuary = constructFrom(date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}

// node_modules/date-fns/addWeeks.mjs
function addWeeks(date, amount) {
  const days = amount * 7;
  return addDays2(date, days);
}

// node_modules/date-fns/isSameDay.mjs
function isSameDay(dateLeft, dateRight) {
  const dateLeftStartOfDay = startOfDay(dateLeft);
  const dateRightStartOfDay = startOfDay(dateRight);
  return +dateLeftStartOfDay === +dateRightStartOfDay;
}

// node_modules/date-fns/isDate.mjs
function isDate(value) {
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}

// node_modules/date-fns/isValid.mjs
function isValid(date) {
  if (!isDate(date) && typeof date !== "number") {
    return false;
  }
  const _date = toDate(date);
  return !isNaN(Number(_date));
}

// node_modules/date-fns/differenceInMilliseconds.mjs
function differenceInMilliseconds(dateLeft, dateRight) {
  return +toDate(dateLeft) - +toDate(dateRight);
}

// node_modules/date-fns/endOfDay.mjs
function endOfDay(date) {
  const _date = toDate(date);
  _date.setHours(23, 59, 59, 999);
  return _date;
}

// node_modules/date-fns/endOfMonth.mjs
function endOfMonth(date) {
  const _date = toDate(date);
  const month = _date.getMonth();
  _date.setFullYear(_date.getFullYear(), month + 1, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}

// node_modules/date-fns/isLastDayOfMonth.mjs
function isLastDayOfMonth(date) {
  const _date = toDate(date);
  return +endOfDay(_date) === +endOfMonth(_date);
}

// node_modules/date-fns/eachDayOfInterval.mjs
function eachDayOfInterval(interval, options) {
  const startDate = toDate(interval.start);
  const endDate = toDate(interval.end);
  let reversed = +startDate > +endDate;
  const endTime = reversed ? +startDate : +endDate;
  const currentDate = reversed ? endDate : startDate;
  currentDate.setHours(0, 0, 0, 0);
  let step = (options == null ? void 0 : options.step) ?? 1;
  if (!step) return [];
  if (step < 0) {
    step = -step;
    reversed = !reversed;
  }
  const dates = [];
  while (+currentDate <= endTime) {
    dates.push(toDate(currentDate));
    currentDate.setDate(currentDate.getDate() + step);
    currentDate.setHours(0, 0, 0, 0);
  }
  return reversed ? dates.reverse() : dates;
}

// node_modules/date-fns/startOfMinute.mjs
function startOfMinute(date) {
  const _date = toDate(date);
  _date.setSeconds(0, 0);
  return _date;
}

// node_modules/date-fns/startOfMonth.mjs
function startOfMonth(date) {
  const _date = toDate(date);
  _date.setDate(1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// node_modules/date-fns/endOfWeek.mjs
function endOfWeek(date, options) {
  var _a, _b, _c, _d;
  const defaultOptions3 = getDefaultOptions();
  const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions3.weekStartsOn ?? ((_d = (_c = defaultOptions3.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
  const _date = toDate(date);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  _date.setDate(_date.getDate() + diff);
  _date.setHours(23, 59, 59, 999);
  return _date;
}

// node_modules/date-fns/endOfToday.mjs
function endOfToday() {
  return endOfDay(Date.now());
}

// node_modules/date-fns/locale/_lib/buildFormatLongFn.mjs
function buildFormatLongFn(args) {
  return (options = {}) => {
    const width = options.width ? String(options.width) : args.defaultWidth;
    const format3 = args.formats[width] || args.formats[args.defaultWidth];
    return format3;
  };
}

// node_modules/date-fns/locale/en-US/_lib/formatLong.mjs
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};

// node_modules/date-fns/locale/_lib/buildLocalizeFn.mjs
function buildLocalizeFn(args) {
  return (value, options) => {
    const context = (options == null ? void 0 : options.context) ? String(options.context) : "standalone";
    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = (options == null ? void 0 : options.width) ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = (options == null ? void 0 : options.width) ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index2 = args.argumentCallback ? args.argumentCallback(value) : value;
    return valuesArray[index2];
  };
}

// node_modules/date-fns/locale/en-US/_lib/localize.mjs
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};

// node_modules/date-fns/locale/_lib/buildMatchFn.mjs
function buildMatchFn(args) {
  return (string, options = {}) => {
    const width = options.width;
    const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];
    const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      findKey(parsePatterns, (pattern) => pattern.test(matchedString))
    );
    let value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      options.valueCallback(value)
    ) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
function findKey(object, predicate) {
  for (const key in object) {
    if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (let key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}

// node_modules/date-fns/locale/_lib/buildMatchPatternFn.mjs
function buildMatchPatternFn(args) {
  return (string, options = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    const matchedString = matchResult[0];
    const parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}

// node_modules/date-fns/locale/en-US/_lib/match.mjs
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};

// node_modules/date-fns/getISOWeek.mjs
function getISOWeek(date) {
  const _date = toDate(date);
  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// node_modules/date-fns/getWeekYear.mjs
function getWeekYear(date, options) {
  var _a, _b, _c, _d;
  const _date = toDate(date);
  const year = _date.getFullYear();
  const defaultOptions3 = getDefaultOptions();
  const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions3.firstWeekContainsDate ?? ((_d = (_c = defaultOptions3.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const firstWeekOfNextYear = constructFrom(date, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
  const firstWeekOfThisYear = constructFrom(date, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/startOfWeekYear.mjs
function startOfWeekYear(date, options) {
  var _a, _b, _c, _d;
  const defaultOptions3 = getDefaultOptions();
  const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions3.firstWeekContainsDate ?? ((_d = (_c = defaultOptions3.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const year = getWeekYear(date, options);
  const firstWeek = constructFrom(date, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options);
  return _date;
}

// node_modules/date-fns/getWeek.mjs
function getWeek(date, options) {
  const _date = toDate(date);
  const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// node_modules/date-fns/_lib/addLeadingZeros.mjs
function addLeadingZeros(number, targetLength) {
  const sign = number < 0 ? "-" : "";
  const output = Math.abs(number).toString().padStart(targetLength, "0");
  return sign + output;
}

// node_modules/date-fns/_lib/format/lightFormatters.mjs
var lightFormatters = {
  // Year
  y(date, token) {
    const signedYear = date.getFullYear();
    const year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  // Month
  M(date, token) {
    const month = date.getMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d(date, token) {
    return addLeadingZeros(date.getDate(), token.length);
  },
  // AM or PM
  a(date, token) {
    const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(date, token) {
    return addLeadingZeros(date.getHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H(date, token) {
    return addLeadingZeros(date.getHours(), token.length);
  },
  // Minute
  m(date, token) {
    return addLeadingZeros(date.getMinutes(), token.length);
  },
  // Second
  s(date, token) {
    return addLeadingZeros(date.getSeconds(), token.length);
  },
  // Fraction of second
  S(date, token) {
    const numberOfDigits = token.length;
    const milliseconds = date.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, numberOfDigits - 3)
    );
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};

// node_modules/date-fns/getDaysInMonth.mjs
function getDaysInMonth(date) {
  const _date = toDate(date);
  const year = _date.getFullYear();
  const monthIndex = _date.getMonth();
  const lastDayOfMonth2 = constructFrom(date, 0);
  lastDayOfMonth2.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth2.setHours(0, 0, 0, 0);
  return lastDayOfMonth2.getDate();
}

// node_modules/date-fns/getISODay.mjs
function getISODay(date) {
  const _date = toDate(date);
  let day = _date.getDay();
  if (day === 0) {
    day = 7;
  }
  return day;
}

// node_modules/date-fns/isAfter.mjs
function isAfter(date, dateToCompare) {
  const _date = toDate(date);
  const _dateToCompare = toDate(dateToCompare);
  return _date.getTime() > _dateToCompare.getTime();
}

// node_modules/date-fns/isBefore.mjs
function isBefore(date, dateToCompare) {
  const _date = toDate(date);
  const _dateToCompare = toDate(dateToCompare);
  return +_date < +_dateToCompare;
}

// node_modules/date-fns/isFirstDayOfMonth.mjs
function isFirstDayOfMonth(date) {
  return toDate(date).getDate() === 1;
}

// node_modules/date-fns/parse/_lib/Setter.mjs
var Setter = class {
  constructor() {
    __publicField(this, "subPriority", 0);
  }
  validate(_utcDate, _options) {
    return true;
  }
};
var ValueSetter = class extends Setter {
  constructor(value, validateValue, setValue, priority, subPriority) {
    super();
    this.value = value;
    this.validateValue = validateValue;
    this.setValue = setValue;
    this.priority = priority;
    if (subPriority) {
      this.subPriority = subPriority;
    }
  }
  validate(date, options) {
    return this.validateValue(date, this.value, options);
  }
  set(date, flags, options) {
    return this.setValue(date, flags, this.value, options);
  }
};

// node_modules/date-fns/parse/_lib/Parser.mjs
var Parser = class {
  run(dateString, token, match2, options) {
    const result = this.parse(dateString, token, match2, options);
    if (!result) {
      return null;
    }
    return {
      setter: new ValueSetter(
        result.value,
        this.validate,
        this.set,
        this.priority,
        this.subPriority
      ),
      rest: result.rest
    };
  }
  validate(_utcDate, _value, _options) {
    return true;
  }
};

// node_modules/date-fns/parse/_lib/parsers/EraParser.mjs
var EraParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 140);
    __publicField(this, "incompatibleTokens", ["R", "u", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return match2.era(dateString, { width: "abbreviated" }) || match2.era(dateString, { width: "narrow" });
      case "GGGGG":
        return match2.era(dateString, { width: "narrow" });
      case "GGGG":
      default:
        return match2.era(dateString, { width: "wide" }) || match2.era(dateString, { width: "abbreviated" }) || match2.era(dateString, { width: "narrow" });
    }
  }
  set(date, flags, value) {
    flags.era = value;
    date.setFullYear(value, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/constants.mjs
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};

// node_modules/date-fns/parse/_lib/utils.mjs
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  const sign = matchResult[1] === "+" ? 1 : -1;
  const hours2 = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  const minutes2 = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  const seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours2 * millisecondsInHour + minutes2 * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
  }
}
function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  const isCommonEra = currentYear > 0;
  const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  let result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    const rangeEnd = absCurrentYear + 50;
    const rangeEndCentury = Math.trunc(rangeEnd / 100) * 100;
    const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

// node_modules/date-fns/parse/_lib/parsers/YearParser.mjs
var YearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token, match2) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "yy"
    });
    switch (token) {
      case "y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "yo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "year"
          }),
          valueCallback
        );
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }
  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }
  set(date, flags, value) {
    const currentYear = date.getFullYear();
    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = normalizeTwoDigitYear(
        value.year,
        currentYear
      );
      date.setFullYear(normalizedTwoDigitYear, 0, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }
    const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date.setFullYear(year, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/LocalWeekYearParser.mjs
var LocalWeekYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "YY"
    });
    switch (token) {
      case "Y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "Yo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "year"
          }),
          valueCallback
        );
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }
  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }
  set(date, flags, value, options) {
    const currentYear = getWeekYear(date, options);
    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = normalizeTwoDigitYear(
        value.year,
        currentYear
      );
      date.setFullYear(
        normalizedTwoDigitYear,
        0,
        options.firstWeekContainsDate
      );
      date.setHours(0, 0, 0, 0);
      return startOfWeek(date, options);
    }
    const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date.setFullYear(year, 0, options.firstWeekContainsDate);
    date.setHours(0, 0, 0, 0);
    return startOfWeek(date, options);
  }
};

// node_modules/date-fns/parse/_lib/parsers/ISOWeekYearParser.mjs
var ISOWeekYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", [
      "G",
      "y",
      "Y",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token) {
    if (token === "R") {
      return parseNDigitsSigned(4, dateString);
    }
    return parseNDigitsSigned(token.length, dateString);
  }
  set(date, _flags, value) {
    const firstWeekOfYear = constructFrom(date, 0);
    firstWeekOfYear.setFullYear(value, 0, 4);
    firstWeekOfYear.setHours(0, 0, 0, 0);
    return startOfISOWeek(firstWeekOfYear);
  }
};

// node_modules/date-fns/parse/_lib/parsers/ExtendedYearParser.mjs
var ExtendedYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token) {
    if (token === "u") {
      return parseNDigitsSigned(4, dateString);
    }
    return parseNDigitsSigned(token.length, dateString);
  }
  set(date, _flags, value) {
    date.setFullYear(value, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/QuarterParser.mjs
var QuarterParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 120);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "Q":
      case "QQ":
        return parseNDigits(token.length, dateString);
      case "Qo":
        return match2.ordinalNumber(dateString, { unit: "quarter" });
      case "QQQ":
        return match2.quarter(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQQ":
        return match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return match2.quarter(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 4;
  }
  set(date, _flags, value) {
    date.setMonth((value - 1) * 3, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/StandAloneQuarterParser.mjs
var StandAloneQuarterParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 120);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "q":
      case "qq":
        return parseNDigits(token.length, dateString);
      case "qo":
        return match2.ordinalNumber(dateString, { unit: "quarter" });
      case "qqq":
        return match2.quarter(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqqq":
        return match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return match2.quarter(dateString, {
          width: "wide",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 4;
  }
  set(date, _flags, value) {
    date.setMonth((value - 1) * 3, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/MonthParser.mjs
var MonthParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "L",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
    __publicField(this, "priority", 110);
  }
  parse(dateString, token, match2) {
    const valueCallback = (value) => value - 1;
    switch (token) {
      case "M":
        return mapValue(
          parseNumericPattern(numericPatterns.month, dateString),
          valueCallback
        );
      case "MM":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      case "Mo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "month"
          }),
          valueCallback
        );
      case "MMM":
        return match2.month(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.month(dateString, { width: "narrow", context: "formatting" });
      case "MMMMM":
        return match2.month(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return match2.month(dateString, { width: "wide", context: "formatting" }) || match2.month(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.month(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    date.setMonth(value, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/StandAloneMonthParser.mjs
var StandAloneMonthParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 110);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    const valueCallback = (value) => value - 1;
    switch (token) {
      case "L":
        return mapValue(
          parseNumericPattern(numericPatterns.month, dateString),
          valueCallback
        );
      case "LL":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      case "Lo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "month"
          }),
          valueCallback
        );
      case "LLL":
        return match2.month(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.month(dateString, { width: "narrow", context: "standalone" });
      case "LLLLL":
        return match2.month(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return match2.month(dateString, { width: "wide", context: "standalone" }) || match2.month(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.month(dateString, { width: "narrow", context: "standalone" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    date.setMonth(value, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/setWeek.mjs
function setWeek(date, week, options) {
  const _date = toDate(date);
  const diff = getWeek(_date, options) - week;
  _date.setDate(_date.getDate() - diff * 7);
  return _date;
}

// node_modules/date-fns/parse/_lib/parsers/LocalWeekParser.mjs
var LocalWeekParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 100);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "w":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "wo":
        return match2.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 53;
  }
  set(date, _flags, value, options) {
    return startOfWeek(setWeek(date, value, options), options);
  }
};

// node_modules/date-fns/setISOWeek.mjs
function setISOWeek(date, week) {
  const _date = toDate(date);
  const diff = getISOWeek(_date) - week;
  _date.setDate(_date.getDate() - diff * 7);
  return _date;
}

// node_modules/date-fns/parse/_lib/parsers/ISOWeekParser.mjs
var ISOWeekParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 100);
    __publicField(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "I":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "Io":
        return match2.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 53;
  }
  set(date, _flags, value) {
    return startOfISOWeek(setISOWeek(date, value));
  }
};

// node_modules/date-fns/parse/_lib/parsers/DateParser.mjs
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [
  31,
  29,
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
];
var DateParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "subPriority", 1);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "d":
        return parseNumericPattern(numericPatterns.date, dateString);
      case "do":
        return match2.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(date, value) {
    const year = date.getFullYear();
    const isLeapYear3 = isLeapYearIndex(year);
    const month = date.getMonth();
    if (isLeapYear3) {
      return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
    } else {
      return value >= 1 && value <= DAYS_IN_MONTH[month];
    }
  }
  set(date, _flags, value) {
    date.setDate(value);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/DayOfYearParser.mjs
var DayOfYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "subpriority", 1);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "E",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "D":
      case "DD":
        return parseNumericPattern(numericPatterns.dayOfYear, dateString);
      case "Do":
        return match2.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(date, value) {
    const year = date.getFullYear();
    const isLeapYear3 = isLeapYearIndex(year);
    if (isLeapYear3) {
      return value >= 1 && value <= 366;
    } else {
      return value >= 1 && value <= 365;
    }
  }
  set(date, _flags, value) {
    date.setMonth(0, value);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/setDay.mjs
function setDay(date, day, options) {
  var _a, _b, _c, _d;
  const defaultOptions3 = getDefaultOptions();
  const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions3.weekStartsOn ?? ((_d = (_c = defaultOptions3.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
  const _date = toDate(date);
  const currentDay = _date.getDay();
  const remainder = day % 7;
  const dayIndex = (remainder + 7) % 7;
  const delta = 7 - weekStartsOn;
  const diff = day < 0 || day > 6 ? day - (currentDay + delta) % 7 : (dayIndex + delta) % 7 - (currentDay + delta) % 7;
  return addDays2(_date, diff);
}

// node_modules/date-fns/parse/_lib/parsers/DayParser.mjs
var DayParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      case "EEEEE":
        return match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      case "EEEE":
      default:
        return match2.day(dateString, { width: "wide", context: "formatting" }) || match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options) {
    date = setDay(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/LocalDayParser.mjs
var LocalDayParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2, options) {
    const valueCallback = (value) => {
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token) {
      case "e":
      case "ee":
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      case "eo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "day"
          }),
          valueCallback
        );
      case "eee":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      case "eeeee":
        return match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      case "eeee":
      default:
        return match2.day(dateString, { width: "wide", context: "formatting" }) || match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options) {
    date = setDay(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/StandAloneLocalDayParser.mjs
var StandAloneLocalDayParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "e",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2, options) {
    const valueCallback = (value) => {
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token) {
      case "c":
      case "cc":
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      case "co":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "day"
          }),
          valueCallback
        );
      case "ccc":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
      case "ccccc":
        return match2.day(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
      case "cccc":
      default:
        return match2.day(dateString, { width: "wide", context: "standalone" }) || match2.day(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options) {
    date = setDay(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/setISODay.mjs
function setISODay(date, day) {
  const _date = toDate(date);
  const currentDay = getISODay(_date);
  const diff = day - currentDay;
  return addDays2(_date, diff);
}

// node_modules/date-fns/parse/_lib/parsers/ISODayParser.mjs
var ISODayParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "E",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    const valueCallback = (value) => {
      if (value === 0) {
        return 7;
      }
      return value;
    };
    switch (token) {
      case "i":
      case "ii":
        return parseNDigits(token.length, dateString);
      case "io":
        return match2.ordinalNumber(dateString, { unit: "day" });
      case "iii":
        return mapValue(
          match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      case "iiiii":
        return mapValue(
          match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      case "iiiiii":
        return mapValue(
          match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      case "iiii":
      default:
        return mapValue(
          match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 7;
  }
  set(date, _flags, value) {
    date = setISODay(date, value);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/AMPMParser.mjs
var AMPMParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "a":
      case "aa":
      case "aaa":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaaa":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/AMPMMidnightParser.mjs
var AMPMMidnightParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "b":
      case "bb":
      case "bbb":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbbb":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/DayPeriodParser.mjs
var DayPeriodParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["a", "b", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBBB":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/Hour1to12Parser.mjs
var Hour1to12Parser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["H", "K", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "h":
        return parseNumericPattern(numericPatterns.hour12h, dateString);
      case "ho":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 12;
  }
  set(date, _flags, value) {
    const isPM = date.getHours() >= 12;
    if (isPM && value < 12) {
      date.setHours(value + 12, 0, 0, 0);
    } else if (!isPM && value === 12) {
      date.setHours(0, 0, 0, 0);
    } else {
      date.setHours(value, 0, 0, 0);
    }
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/Hour0to23Parser.mjs
var Hour0to23Parser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "H":
        return parseNumericPattern(numericPatterns.hour23h, dateString);
      case "Ho":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 23;
  }
  set(date, _flags, value) {
    date.setHours(value, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/Hour0To11Parser.mjs
var Hour0To11Parser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["h", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "K":
        return parseNumericPattern(numericPatterns.hour11h, dateString);
      case "Ko":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    const isPM = date.getHours() >= 12;
    if (isPM && value < 12) {
      date.setHours(value + 12, 0, 0, 0);
    } else {
      date.setHours(value, 0, 0, 0);
    }
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/Hour1To24Parser.mjs
var Hour1To24Parser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "k":
        return parseNumericPattern(numericPatterns.hour24h, dateString);
      case "ko":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 24;
  }
  set(date, _flags, value) {
    const hours2 = value <= 24 ? value % 24 : value;
    date.setHours(hours2, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/MinuteParser.mjs
var MinuteParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 60);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "m":
        return parseNumericPattern(numericPatterns.minute, dateString);
      case "mo":
        return match2.ordinalNumber(dateString, { unit: "minute" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 59;
  }
  set(date, _flags, value) {
    date.setMinutes(value, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/SecondParser.mjs
var SecondParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 50);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "s":
        return parseNumericPattern(numericPatterns.second, dateString);
      case "so":
        return match2.ordinalNumber(dateString, { unit: "second" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 59;
  }
  set(date, _flags, value) {
    date.setSeconds(value, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/FractionOfSecondParser.mjs
var FractionOfSecondParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 30);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token) {
    const valueCallback = (value) => Math.trunc(value * Math.pow(10, -token.length + 3));
    return mapValue(parseNDigits(token.length, dateString), valueCallback);
  }
  set(date, _flags, value) {
    date.setMilliseconds(value);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/ISOTimezoneWithZParser.mjs
var ISOTimezoneWithZParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 10);
    __publicField(this, "incompatibleTokens", ["t", "T", "x"]);
  }
  parse(dateString, token) {
    switch (token) {
      case "X":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          dateString
        );
      case "XX":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "XXXX":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          dateString
        );
      case "XXXXX":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          dateString
        );
      case "XXX":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }
  set(date, flags, value) {
    if (flags.timestampIsSet) return date;
    return constructFrom(
      date,
      date.getTime() - getTimezoneOffsetInMilliseconds(date) - value
    );
  }
};

// node_modules/date-fns/parse/_lib/parsers/ISOTimezoneParser.mjs
var ISOTimezoneParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 10);
    __publicField(this, "incompatibleTokens", ["t", "T", "X"]);
  }
  parse(dateString, token) {
    switch (token) {
      case "x":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          dateString
        );
      case "xx":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "xxxx":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          dateString
        );
      case "xxxxx":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          dateString
        );
      case "xxx":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }
  set(date, flags, value) {
    if (flags.timestampIsSet) return date;
    return constructFrom(
      date,
      date.getTime() - getTimezoneOffsetInMilliseconds(date) - value
    );
  }
};

// node_modules/date-fns/parse/_lib/parsers/TimestampSecondsParser.mjs
var TimestampSecondsParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 40);
    __publicField(this, "incompatibleTokens", "*");
  }
  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }
  set(date, _flags, value) {
    return [constructFrom(date, value * 1e3), { timestampIsSet: true }];
  }
};

// node_modules/date-fns/parse/_lib/parsers/TimestampMillisecondsParser.mjs
var TimestampMillisecondsParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 20);
    __publicField(this, "incompatibleTokens", "*");
  }
  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }
  set(date, _flags, value) {
    return [constructFrom(date, value), { timestampIsSet: true }];
  }
};

// node_modules/date-fns/parse/_lib/parsers.mjs
var parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};

// node_modules/date-fns/isSameMonth.mjs
function isSameMonth(dateLeft, dateRight) {
  const _dateLeft = toDate(dateLeft);
  const _dateRight = toDate(dateRight);
  return _dateLeft.getFullYear() === _dateRight.getFullYear() && _dateLeft.getMonth() === _dateRight.getMonth();
}

// node_modules/date-fns/isWithinInterval.mjs
function isWithinInterval(date, interval) {
  const time = +toDate(date);
  const [startTime, endTime] = [
    +toDate(interval.start),
    +toDate(interval.end)
  ].sort((a, b) => a - b);
  return time >= startTime && time <= endTime;
}

// node_modules/date-fns/subDays.mjs
function subDays(date, amount) {
  return addDays2(date, -amount);
}

// node_modules/date-fns/lightFormat.mjs
var formattingTokensRegExp = /(\w)\1*|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function lightFormat(date, formatStr) {
  const _date = toDate(date);
  if (!isValid(_date)) {
    throw new RangeError("Invalid time value");
  }
  const tokens = formatStr.match(formattingTokensRegExp);
  if (!tokens) return "";
  const result = tokens.map((substring) => {
    if (substring === "''") {
      return "'";
    }
    const firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }
    const formatter = lightFormatters[firstCharacter];
    if (formatter) {
      return formatter(_date, substring);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
      );
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString(input) {
  const matches = input.match(escapedStringRegExp);
  if (!matches) {
    return input;
  }
  return matches[1].replace(doubleQuoteRegExp, "'");
}

// node_modules/date-fns/setMonth.mjs
function setMonth(date, month) {
  const _date = toDate(date);
  const year = _date.getFullYear();
  const day = _date.getDate();
  const dateWithDesiredMonth = constructFrom(date, 0);
  dateWithDesiredMonth.setFullYear(year, month, 15);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  const daysInMonth = getDaysInMonth(dateWithDesiredMonth);
  _date.setMonth(month, Math.min(day, daysInMonth));
  return _date;
}

// node_modules/date-fns/setHours.mjs
function setHours(date, hours2) {
  const _date = toDate(date);
  _date.setHours(hours2);
  return _date;
}

// node_modules/date-fns/setMinutes.mjs
function setMinutes(date, minutes2) {
  const _date = toDate(date);
  _date.setMinutes(minutes2);
  return _date;
}

// node_modules/date-fns/setYear.mjs
function setYear(date, year) {
  const _date = toDate(date);
  if (isNaN(+_date)) {
    return constructFrom(date, NaN);
  }
  _date.setFullYear(year);
  return _date;
}

// node_modules/date-fns/subMonths.mjs
function subMonths(date, amount) {
  return addMonths(date, -amount);
}

// node_modules/date-fns/subWeeks.mjs
function subWeeks(date, amount) {
  return addWeeks(date, -amount);
}

// node_modules/@vkontakte/vkui/dist/hooks/useCalendar.js
var React227 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/calendar.js
var DEFAULT_MAX_YEAR = 9999;
var DEFAULT_MIN_YEAR = 100;
var getYears = (currentYear, range2) => {
  const years = [];
  const minYear = clamp2(currentYear - range2, DEFAULT_MIN_YEAR, DEFAULT_MAX_YEAR);
  const maxYear = clamp2(currentYear + range2, DEFAULT_MIN_YEAR, DEFAULT_MAX_YEAR);
  for (let i = minYear; i <= maxYear; i++) {
    years.push({
      label: String(i).padStart(4, "0"),
      value: i
    });
  }
  return years;
};
var getMonths = (locale) => {
  const months = [];
  const formatter = new Intl.DateTimeFormat(locale, {
    month: "long"
  });
  for (let i = 0; i < 12; i++) {
    months.push({
      label: formatter.format((/* @__PURE__ */ new Date("1970-01-01")).setMonth(i)),
      value: i
    });
  }
  return months;
};
var getDaysNames = (now2, weekStartsOn, locale) => {
  const formatter = new Intl.DateTimeFormat(locale, {
    weekday: "short"
  });
  return eachDayOfInterval({
    start: startOfWeek(now2, {
      weekStartsOn
    }),
    end: endOfWeek(now2, {
      weekStartsOn
    })
  }).map((day) => formatter.format(day));
};
var navigateDate = (date, key) => {
  let newDate = date !== null && date !== void 0 ? date : /* @__PURE__ */ new Date();
  switch (key) {
    case "ArrowRight":
      newDate = addDays2(newDate, 1);
      break;
    case "ArrowLeft":
      newDate = subDays(newDate, 1);
      break;
    case "ArrowUp":
      newDate = subWeeks(newDate, 1);
      break;
    case "ArrowDown":
      newDate = addWeeks(newDate, 1);
      break;
  }
  return newDate;
};
var getWeeks = (viewDate, weekStartsOn) => {
  const start = startOfWeek(startOfMonth(viewDate), {
    weekStartsOn
  });
  const end = endOfWeek(endOfMonth(viewDate), {
    weekStartsOn
  });
  let count = 0;
  let current = start;
  const nestedWeeks = [];
  let lastDay = null;
  while (isBefore(current, end)) {
    const weekNumber = Math.floor(count / 7);
    nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
    const day = current.getDay();
    if (lastDay !== day) {
      lastDay = day;
      nestedWeeks[weekNumber].push(current);
      count += 1;
    }
    current = addDays2(current, 1);
  }
  return nestedWeeks;
};
var setTimeEqual = (to, from) => {
  if (from) {
    to.setHours(from.getHours());
    to.setMinutes(from.getMinutes());
    to.setSeconds(from.getSeconds());
    to.setMilliseconds(from.getMilliseconds());
  }
  return to;
};
var isFirstDay = (day, dayOfWeek) => dayOfWeek === 0 || isFirstDayOfMonth(day);
var isLastDay = (day, dayOfWeek) => dayOfWeek === 6 || isLastDayOfMonth(day);
function clamp3(day, options = {}) {
  const { min: min3, max: max3 } = options;
  if (min3 && isBefore(day, min3)) {
    return min3;
  }
  if (max3 && isAfter(day, max3)) {
    return max3;
  }
  return day;
}
function isDayMinMaxRestricted(day, options = {}) {
  const { min: min3, max: max3, withTime = false } = options;
  if (!withTime && (min3 && isSameDay(day, min3) || max3 && isSameDay(day, max3))) {
    return false;
  }
  return Boolean(min3 && isBefore(day, min3) || max3 && isAfter(day, max3));
}

// node_modules/@vkontakte/vkui/dist/hooks/useCalendar.js
function useCalendar({ value, disablePast, disableFuture, shouldDisableDate, onHeaderChange, onNextMonth, onPrevMonth, minDateTime, maxDateTime }) {
  var _ref;
  const [viewDate, setViewDate] = React227.useState((_ref = Array.isArray(value) ? value[0] : value) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ new Date());
  const [focusedDay, setFocusedDay] = React227.useState();
  const setPrevMonth = React227.useCallback(() => {
    onPrevMonth === null || onPrevMonth === void 0 ? void 0 : onPrevMonth();
    setViewDate(subMonths(viewDate, 1));
  }, [
    viewDate,
    onPrevMonth
  ]);
  const setNextMonth = React227.useCallback(() => {
    onNextMonth === null || onNextMonth === void 0 ? void 0 : onNextMonth();
    setViewDate(addMonths(viewDate, 1));
  }, [
    viewDate,
    onNextMonth
  ]);
  const handleSetViewDate = React227.useCallback((value2) => {
    onHeaderChange === null || onHeaderChange === void 0 ? void 0 : onHeaderChange(value2);
    setViewDate(value2);
  }, [
    onHeaderChange
  ]);
  const isDayFocused = React227.useCallback((day) => Boolean(focusedDay && isSameDay(day, focusedDay)), [
    focusedDay
  ]);
  const isDayDisabled = React227.useCallback((day, withTime) => {
    const now2 = /* @__PURE__ */ new Date();
    if (shouldDisableDate) {
      return shouldDisableDate(day);
    }
    if (disableFuture) {
      return isAfter(startOfDay(day), now2);
    }
    if (disablePast) {
      return isBefore(endOfDay(day), now2);
    }
    if (minDateTime || maxDateTime) {
      return isDayMinMaxRestricted(day, {
        min: minDateTime,
        max: maxDateTime,
        withTime
      });
    }
    return false;
  }, [
    disableFuture,
    disablePast,
    shouldDisableDate,
    minDateTime,
    maxDateTime
  ]);
  const isMonthDisabled = React227.useCallback((month, year) => {
    const now2 = /* @__PURE__ */ new Date();
    year = year || viewDate.getFullYear();
    const minMonth = minDateTime ? minDateTime.getMonth() : 0;
    const maxMonth = maxDateTime ? maxDateTime.getMonth() : 11;
    const minYear = (minDateTime === null || minDateTime === void 0 ? void 0 : minDateTime.getFullYear()) || DEFAULT_MIN_YEAR;
    const maxYear = (maxDateTime === null || maxDateTime === void 0 ? void 0 : maxDateTime.getFullYear()) || DEFAULT_MAX_YEAR;
    let isDisabled = year >= minYear && year <= maxYear ? year === minYear && minMonth > month || year === maxYear && month > maxMonth : true;
    if (disableFuture) {
      isDisabled = isDisabled || (year === now2.getFullYear() ? month > now2.getMonth() : year > now2.getFullYear());
    }
    if (disablePast) {
      isDisabled = isDisabled || (year === now2.getFullYear() ? month < now2.getMonth() : year < now2.getFullYear());
    }
    return isDisabled;
  }, [
    disableFuture,
    disablePast,
    viewDate,
    minDateTime,
    maxDateTime
  ]);
  const isYearDisabled = React227.useCallback((year) => {
    const now2 = /* @__PURE__ */ new Date();
    const minYear = (minDateTime === null || minDateTime === void 0 ? void 0 : minDateTime.getFullYear()) || DEFAULT_MIN_YEAR;
    const maxYear = (maxDateTime === null || maxDateTime === void 0 ? void 0 : maxDateTime.getFullYear()) || DEFAULT_MAX_YEAR;
    let isDisabled = minYear > year || year > maxYear;
    if (disableFuture) {
      isDisabled = isDisabled || year > now2.getFullYear();
    }
    if (disablePast) {
      isDisabled = isDisabled || year < now2.getFullYear();
    }
    return isDisabled;
  }, [
    disableFuture,
    disablePast,
    minDateTime,
    maxDateTime
  ]);
  const resetSelectedDay = React227.useCallback(() => {
    setFocusedDay(void 0);
  }, [
    setFocusedDay
  ]);
  return {
    viewDate,
    setViewDate: handleSetViewDate,
    setPrevMonth,
    setNextMonth,
    focusedDay,
    setFocusedDay,
    isDayFocused,
    isDayDisabled,
    resetSelectedDay,
    isMonthDisabled,
    isYearDisabled
  };
}

// node_modules/@vkontakte/vkui/dist/components/CalendarDays/CalendarDays.js
var import_jsx_runtime209 = __toESM(require_jsx_runtime());
var React230 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useTodayDate.js
var React228 = __toESM(require_react());
function useTodayDate(listenDayChangesForUpdate = false) {
  const { document: document2, window: window2 } = useDOM();
  const [todayDate, setTodayDate] = React228.useState(() => /* @__PURE__ */ new Date());
  React228.useEffect(() => {
    if (!listenDayChangesForUpdate || !document2 || !window2) {
      return;
    }
    let timeout = void 0;
    const recalcTimeout = () => {
      if (document2.visibilityState === "visible") {
        const now2 = /* @__PURE__ */ new Date();
        const timeToDayChange = differenceInMilliseconds(endOfToday(), now2);
        window2.clearTimeout(timeout);
        timeout = window2.setTimeout(() => {
          setTodayDate(now2);
        }, timeToDayChange);
        if (!isSameDay(todayDate, now2)) {
          setTodayDate(now2);
        }
      }
    };
    recalcTimeout();
    document2.addEventListener("visibilitychange", recalcTimeout);
    return () => {
      window2.clearTimeout(timeout);
      document2.removeEventListener("visibilitychange", recalcTimeout);
    };
  }, [
    document2,
    listenDayChangesForUpdate,
    todayDate,
    window2
  ]);
  return todayDate;
}

// node_modules/@vkontakte/vkui/dist/components/CalendarDay/CalendarDay.js
var import_jsx_runtime208 = __toESM(require_jsx_runtime());
var React229 = __toESM(require_react());
var CalendarDay = React229.memo((_param) => {
  var { day, today, selected, onChange, hidden, disabled, active, selectionStart, selectionEnd, focused, onEnter, onLeave, hinted, hintedSelectionStart, hintedSelectionEnd, sameMonth, size: size4, className, children, renderDayContent, testId } = _param, restProps = _object_without_properties(_param, [
    "day",
    "today",
    "selected",
    "onChange",
    "hidden",
    "disabled",
    "active",
    "selectionStart",
    "selectionEnd",
    "focused",
    "onEnter",
    "onLeave",
    "hinted",
    "hintedSelectionStart",
    "hintedSelectionEnd",
    "sameMonth",
    "size",
    "className",
    "children",
    "renderDayContent",
    "testId"
  ]);
  const { locale } = useConfigProvider();
  const ref = React229.useRef(null);
  const onClick = React229.useCallback(() => onChange(day), [
    day,
    onChange
  ]);
  const handleEnter = React229.useCallback(() => onEnter === null || onEnter === void 0 ? void 0 : onEnter(day), [
    day,
    onEnter
  ]);
  const handleLeave = React229.useCallback(() => onLeave === null || onLeave === void 0 ? void 0 : onLeave(day), [
    day,
    onLeave
  ]);
  const label = new Intl.DateTimeFormat(locale, {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric"
  }).format(day);
  React229.useEffect(() => {
    if (focused && ref.current) {
      ref.current.dispatchEvent(new Event(ENABLE_KEYBOARD_INPUT_EVENT_NAME, {
        bubbles: true
      }));
      ref.current.focus();
    }
  }, [
    focused
  ]);
  const content = React229.useMemo(() => {
    if (renderDayContent) {
      return renderDayContent(day);
    }
    return (0, import_jsx_runtime208.jsxs)("div", {
      className: "vkuiCalendarDay__day-number",
      children: [
        (0, import_jsx_runtime208.jsx)(VisuallyHidden, {
          children: children !== null && children !== void 0 ? children : label
        }),
        (0, import_jsx_runtime208.jsx)("span", {
          "aria-hidden": true,
          children: day.getDate()
        })
      ]
    });
  }, [
    renderDayContent,
    day,
    children,
    label
  ]);
  if (hidden) {
    return (0, import_jsx_runtime208.jsx)("div", {
      className: "vkuiCalendarDay__hidden"
    });
  }
  return (0, import_jsx_runtime208.jsx)(Tappable, _object_spread_props(_object_spread({
    className: clsx("vkuiCalendarDay", size4 === "s" && "vkuiCalendarDay--size-s", today && "vkuiCalendarDay--today", selected && !disabled && "vkuiCalendarDay--selected", selectionStart && "vkuiCalendarDay--selection-start", selectionEnd && "vkuiCalendarDay--selection-end", disabled && "vkuiCalendarDay--disabled", !sameMonth && "vkuiCalendarDay--not-same-month", className),
    hoverMode: active ? "" : "vkuiCalendarDay--hover",
    hasActive: false,
    onClick,
    disabled,
    tabIndex: -1,
    getRootRef: ref,
    focusVisibleMode: active ? "outside" : "inside",
    onPointerEnter: handleEnter,
    onPointerLeave: handleLeave,
    "data-testid": typeof testId === "string" ? testId : testId === null || testId === void 0 ? void 0 : testId(day)
  }, restProps), {
    children: (0, import_jsx_runtime208.jsx)("div", {
      className: clsx("vkuiCalendarDay__hinted", hinted && "vkuiCalendarDay__hinted--active", hintedSelectionStart && "vkuiCalendarDay__hinted--selection-start", hintedSelectionEnd && "vkuiCalendarDay__hinted--selection-end"),
      children: (0, import_jsx_runtime208.jsx)("div", {
        className: clsx("vkuiCalendarDay__inner", active && !disabled && "vkuiCalendarDay__inner--active"),
        children: content
      })
    })
  }));
});
CalendarDay.displayName = "CalendarDay";

// node_modules/@vkontakte/vkui/dist/components/CalendarDays/CalendarDays.js
var CalendarDays = (_param) => {
  var { viewDate, value, weekStartsOn, onDayChange, isDaySelected, isDayActive, isDaySelectionEnd, isDaySelectionStart, onDayEnter, onDayLeave, isDayHinted, isHintedDaySelectionStart, isHintedDaySelectionEnd, isDayFocused, isDayDisabled, size: size4, showNeighboringMonth = false, dayProps, listenDayChangesForUpdate = false, getRootRef, renderDayContent, dayTestId } = _param, props = _object_without_properties(_param, [
    "viewDate",
    "value",
    "weekStartsOn",
    "onDayChange",
    "isDaySelected",
    "isDayActive",
    "isDaySelectionEnd",
    "isDaySelectionStart",
    "onDayEnter",
    "onDayLeave",
    "isDayHinted",
    "isHintedDaySelectionStart",
    "isHintedDaySelectionEnd",
    "isDayFocused",
    "isDayDisabled",
    "size",
    "showNeighboringMonth",
    "dayProps",
    "listenDayChangesForUpdate",
    "getRootRef",
    "renderDayContent",
    "dayTestId"
  ]);
  const { locale } = useConfigProvider();
  const ref = useExternRef(getRootRef);
  const now2 = useTodayDate(listenDayChangesForUpdate);
  const weeks = React230.useMemo(() => getWeeks(viewDate, weekStartsOn), [
    weekStartsOn,
    viewDate
  ]);
  const daysNames = React230.useMemo(() => getDaysNames(now2, weekStartsOn, locale), [
    locale,
    now2,
    weekStartsOn
  ]);
  const handleDayChange = React230.useCallback((date) => {
    var _ref_current;
    onDayChange(date);
    (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.focus();
  }, [
    onDayChange,
    ref
  ]);
  return (0, import_jsx_runtime209.jsxs)(RootComponent, _object_spread_props(_object_spread({}, props), {
    baseClassName: "vkuiCalendarDays",
    getRootRef: ref,
    children: [
      (0, import_jsx_runtime209.jsx)("div", {
        className: clsx("vkuiCalendarDays__row", size4 === "s" && "vkuiCalendarDays__row--size-s"),
        children: daysNames.map((dayName) => (0, import_jsx_runtime209.jsx)(Footnote, {
          className: "vkuiCalendarDays__weekday",
          children: dayName
        }, dayName))
      }),
      weeks.map((week, i) => (0, import_jsx_runtime209.jsx)("div", {
        className: clsx("vkuiCalendarDays__row", size4 === "s" && "vkuiCalendarDays__row--size-s"),
        children: week.map((day, i2) => {
          const sameMonth = isSameMonth(day, viewDate);
          return (0, import_jsx_runtime209.jsx)(CalendarDay, _object_spread({
            day,
            today: isSameDay(day, now2),
            active: isDayActive(day),
            onChange: handleDayChange,
            hidden: !showNeighboringMonth && !sameMonth,
            disabled: isDayDisabled(day),
            selectionStart: isDaySelectionStart(day, i2),
            selectionEnd: isDaySelectionEnd(day, i2),
            hintedSelectionStart: isHintedDaySelectionStart === null || isHintedDaySelectionStart === void 0 ? void 0 : isHintedDaySelectionStart(day, i2),
            hintedSelectionEnd: isHintedDaySelectionEnd === null || isHintedDaySelectionEnd === void 0 ? void 0 : isHintedDaySelectionEnd(day, i2),
            selected: isDaySelected === null || isDaySelected === void 0 ? void 0 : isDaySelected(day),
            focused: isDayFocused(day),
            onEnter: onDayEnter,
            onLeave: onDayLeave,
            hinted: isDayHinted === null || isDayHinted === void 0 ? void 0 : isDayHinted(day),
            sameMonth,
            size: size4,
            renderDayContent,
            testId: dayTestId
          }, dayProps), day.toISOString());
        })
      }, i))
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/CalendarHeader/CalendarHeader.js
var import_jsx_runtime211 = __toESM(require_jsx_runtime());
var React232 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/AdaptivityProvider/AdaptivityProvider.js
var import_jsx_runtime210 = __toESM(require_jsx_runtime());
var React231 = __toESM(require_react());
var AdaptivityProvider = ({ viewWidth, viewHeight, sizeX: sizeXProp, sizeY: sizeYProp, hasPointer, hasHover: hasHover2, children }) => {
  const adaptivity = React231.useMemo(() => {
    const nextProps = {
      viewWidth,
      viewHeight,
      sizeX: sizeXProp,
      sizeY: sizeYProp,
      hasPointer,
      hasHover: hasHover2
    };
    if (sizeXProp === void 0 && viewWidth !== void 0) {
      nextProps.sizeX = getSizeX(viewWidth);
    }
    if (sizeYProp === void 0) {
      if (isCompactByViewWidth(viewWidth, hasPointer) || isCompactByViewHeight(viewHeight)) {
        nextProps.sizeY = "compact";
      } else if (viewWidth !== void 0 || viewHeight !== void 0) {
        nextProps.sizeY = "regular";
      }
    }
    return nextProps;
  }, [
    viewWidth,
    viewHeight,
    sizeXProp,
    sizeYProp,
    hasPointer,
    hasHover2
  ]);
  return (0, import_jsx_runtime210.jsx)(AdaptivityContext.Provider, {
    value: adaptivity,
    children
  });
};

// node_modules/@vkontakte/vkui/dist/components/CalendarHeader/CalendarHeader.js
var CalendarHeader = (_param) => {
  var { viewDate, onChange, prevMonthHidden: prevMonthHiddenProp = false, nextMonthHidden: nextMonthHiddenProp = false, disablePickers = false, onNextMonth, onPrevMonth, prevMonthProps = {}, nextMonthProps = {}, prevMonthLabel = "Предыдущий месяц", nextMonthLabel = "Следующий месяц", changeMonthLabel = "Изменить месяц", changeYearLabel = "Изменить год", prevMonthIcon = (0, import_jsx_runtime211.jsx)(Icon20ChevronLeftOutline, {
    className: "vkuiCalendarHeader__nav-icon--accent",
    width: 30,
    height: 30
  }), nextMonthIcon = (0, import_jsx_runtime211.jsx)(Icon20ChevronRightOutline, {
    className: "vkuiCalendarHeader__nav-icon--accent",
    width: 30,
    height: 30
  }), isMonthDisabled, isYearDisabled, monthDropdownTestId, yearDropdownTestId, prevMonthButtonTestId, nextMonthButtonTestId } = _param, restProps = _object_without_properties(_param, [
    "viewDate",
    "onChange",
    "prevMonthHidden",
    "nextMonthHidden",
    "disablePickers",
    "onNextMonth",
    "onPrevMonth",
    "prevMonthProps",
    "nextMonthProps",
    "prevMonthLabel",
    "nextMonthLabel",
    "changeMonthLabel",
    "changeYearLabel",
    "prevMonthIcon",
    "nextMonthIcon",
    "isMonthDisabled",
    "isYearDisabled",
    "monthDropdownTestId",
    "yearDropdownTestId",
    "prevMonthButtonTestId",
    "nextMonthButtonTestId"
  ]);
  const { locale } = useConfigProvider();
  const onMonthsChange = React232.useCallback((event) => onChange(setMonth(viewDate, Number(event.target.value))), [
    onChange,
    viewDate
  ]);
  const onYearChange = React232.useCallback((event) => onChange(setYear(viewDate, Number(event.target.value))), [
    onChange,
    viewDate
  ]);
  const currentYear = viewDate.getFullYear();
  const currentMonth = viewDate.getMonth();
  const months = React232.useMemo(() => getMonths(locale).map(({ value, label }) => ({
    value,
    label: (0, import_jsx_runtime211.jsx)("span", {
      className: "vkuiCalendarHeader__month",
      children: label
    }),
    disabled: isMonthDisabled && isMonthDisabled(value)
  })), [
    locale,
    isMonthDisabled
  ]);
  const years = React232.useMemo(() => getYears(currentYear, 100).map((year) => _object_spread_props(_object_spread({}, year), {
    disabled: isYearDisabled && isYearDisabled(year.value)
  })), [
    currentYear,
    isYearDisabled
  ]);
  const formatter = new Intl.DateTimeFormat(locale, {
    year: "numeric",
    month: "long"
  });
  const { className: prevMonthClassName } = prevMonthProps, restPrevMonthProps = _object_without_properties(prevMonthProps, [
    "className"
  ]);
  const { className: nextMonthClassName } = nextMonthProps, restNextMonthProps = _object_without_properties(nextMonthProps, [
    "className"
  ]);
  let nextMonthHidden = nextMonthHiddenProp || currentMonth === 11 && currentYear === DEFAULT_MAX_YEAR;
  if (isMonthDisabled && !nextMonthHidden) {
    nextMonthHidden = isMonthDisabled(currentMonth === 11 ? 0 : currentMonth + 1, currentMonth === 11 ? Math.min(currentYear + 1, DEFAULT_MAX_YEAR) : currentYear);
  }
  let prevMonthHidden = prevMonthHiddenProp || currentMonth === 0 && currentYear === DEFAULT_MIN_YEAR;
  if (isMonthDisabled && !prevMonthHidden) {
    prevMonthHidden = isMonthDisabled(currentMonth === 0 ? 11 : currentMonth - 1, currentMonth === 0 ? Math.max(currentYear - 1, DEFAULT_MIN_YEAR) : currentYear);
  }
  return (0, import_jsx_runtime211.jsxs)(RootComponent, _object_spread_props(_object_spread({
    baseClassName: "vkuiCalendarHeader"
  }, restProps), {
    children: [
      !prevMonthHidden && (0, import_jsx_runtime211.jsx)(AdaptivityProvider, {
        sizeX: "regular",
        children: (0, import_jsx_runtime211.jsxs)(Tappable, _object_spread_props(_object_spread({
          className: clsx("vkuiCalendarHeader__nav-icon", "vkuiCalendarHeader__nav-icon-prev", prevMonthClassName),
          onClick: onPrevMonth,
          "data-testid": prevMonthButtonTestId
        }, restPrevMonthProps), {
          children: [
            (0, import_jsx_runtime211.jsxs)(VisuallyHidden, {
              children: [
                prevMonthLabel,
                ", ",
                formatter.format(subMonths(viewDate, 1))
              ]
            }),
            prevMonthIcon
          ]
        }))
      }),
      disablePickers ? (0, import_jsx_runtime211.jsxs)(Paragraph, {
        className: clsx("vkuiCalendarHeader__pickers", "vkuiInternalCalendarHeader__pickers"),
        weight: "2",
        children: [
          (0, import_jsx_runtime211.jsx)("span", {
            className: "vkuiCalendarHeader__month",
            children: new Intl.DateTimeFormat(locale, {
              month: "long"
            }).format(viewDate)
          }),
          " ",
          new Intl.DateTimeFormat(locale, {
            year: "numeric"
          }).format(viewDate)
        ]
      }) : (0, import_jsx_runtime211.jsx)(AdaptivityProvider, {
        sizeY: "compact",
        children: (0, import_jsx_runtime211.jsxs)("div", {
          className: clsx("vkuiCalendarHeader__pickers", "vkuiInternalCalendarHeader__pickers"),
          children: [
            (0, import_jsx_runtime211.jsx)(CustomSelect, {
              className: clsx("vkuiCalendarHeader__picker", "vkuiInternalCalendarHeader__picker"),
              value: currentMonth,
              options: months,
              dropdownOffsetDistance: 4,
              dropdownAutoWidth: true,
              icon: (0, import_jsx_runtime211.jsx)(Icon12Dropdown, {}),
              onChange: onMonthsChange,
              forceDropdownPortal: false,
              selectType: "accent",
              "aria-label": changeMonthLabel,
              "data-testid": typeof monthDropdownTestId === "string" ? monthDropdownTestId : monthDropdownTestId === null || monthDropdownTestId === void 0 ? void 0 : monthDropdownTestId(currentMonth)
            }),
            (0, import_jsx_runtime211.jsx)(CustomSelect, {
              className: clsx("vkuiCalendarHeader__picker", "vkuiInternalCalendarHeader__picker"),
              value: currentYear,
              options: years,
              dropdownOffsetDistance: 4,
              dropdownAutoWidth: true,
              icon: (0, import_jsx_runtime211.jsx)(Icon12Dropdown, {}),
              onChange: onYearChange,
              forceDropdownPortal: false,
              selectType: "accent",
              "aria-label": changeYearLabel,
              "data-testid": yearDropdownTestId
            })
          ]
        })
      }),
      !nextMonthHidden && (0, import_jsx_runtime211.jsx)(AdaptivityProvider, {
        sizeX: "regular",
        children: (0, import_jsx_runtime211.jsxs)(Tappable, _object_spread_props(_object_spread({
          className: clsx("vkuiCalendarHeader__nav-icon", "vkuiCalendarHeader__nav-icon-next", nextMonthClassName),
          onClick: onNextMonth,
          "data-testid": nextMonthButtonTestId
        }, restNextMonthProps), {
          children: [
            (0, import_jsx_runtime211.jsxs)(VisuallyHidden, {
              children: [
                nextMonthLabel,
                ", ",
                formatter.format(addMonths(viewDate, 1))
              ]
            }),
            nextMonthIcon
          ]
        }))
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/CalendarTime/CalendarTime.js
var import_jsx_runtime212 = __toESM(require_jsx_runtime());
var React233 = __toESM(require_react());
var hours = [];
for (let i = 0; i < 24; i += 1) {
  hours.push({
    value: i,
    label: String(i).padStart(2, "0")
  });
}
var minutes = [];
for (let i = 0; i < 60; i += 1) {
  minutes.push({
    value: i,
    label: String(i).padStart(2, "0")
  });
}
var CalendarTime = ({ value, onChange, onClose, changeHoursLabel, changeMinutesLabel, isDayDisabled, doneButtonText = "Готово", doneButtonDisabled = false, doneButtonShow = true, minutesTestId, hoursTestId, doneButtonTestId }) => {
  const localHours = isDayDisabled ? hours.map((hour) => {
    return _object_spread_props(_object_spread({}, hour), {
      disabled: isDayDisabled(setHours(value, hour.value), true)
    });
  }) : hours;
  const localMinutes = isDayDisabled ? minutes.map((minute) => {
    return _object_spread_props(_object_spread({}, minute), {
      disabled: isDayDisabled(setMinutes(value, minute.value), true)
    });
  }) : minutes;
  const onHoursChange = React233.useCallback((event) => onChange === null || onChange === void 0 ? void 0 : onChange(setHours(value, Number(event.target.value))), [
    onChange,
    value
  ]);
  const onMinutesChange = React233.useCallback((event) => onChange === null || onChange === void 0 ? void 0 : onChange(setMinutes(value, Number(event.target.value))), [
    onChange,
    value
  ]);
  return (0, import_jsx_runtime212.jsxs)("div", {
    className: clsx("vkuiCalendarTime", !doneButtonShow && "vkuiCalendarTime__withoutDone"),
    children: [
      (0, import_jsx_runtime212.jsx)("div", {
        className: "vkuiCalendarTime__picker",
        children: (0, import_jsx_runtime212.jsx)(AdaptivityProvider, {
          sizeY: "compact",
          children: (0, import_jsx_runtime212.jsx)(CustomSelect, {
            value: value.getHours(),
            options: localHours,
            onChange: onHoursChange,
            forceDropdownPortal: false,
            "aria-label": changeHoursLabel,
            "data-testid": hoursTestId
          })
        })
      }),
      (0, import_jsx_runtime212.jsx)("div", {
        className: "vkuiCalendarTime__divider",
        children: ":"
      }),
      (0, import_jsx_runtime212.jsx)("div", {
        className: "vkuiCalendarTime__picker",
        children: (0, import_jsx_runtime212.jsx)(AdaptivityProvider, {
          sizeY: "compact",
          children: (0, import_jsx_runtime212.jsx)(CustomSelect, {
            value: value.getMinutes(),
            options: localMinutes,
            onChange: onMinutesChange,
            forceDropdownPortal: false,
            "aria-label": changeMinutesLabel,
            "data-testid": minutesTestId
          })
        })
      }),
      doneButtonShow && (0, import_jsx_runtime212.jsx)("div", {
        className: "vkuiCalendarTime__button",
        children: (0, import_jsx_runtime212.jsx)(AdaptivityProvider, {
          sizeY: "compact",
          children: (0, import_jsx_runtime212.jsx)(Button, {
            mode: "secondary",
            onClick: onClose,
            size: "l",
            disabled: doneButtonDisabled,
            "data-testid": doneButtonTestId,
            children: doneButtonText
          })
        })
      })
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/Calendar/Calendar.js
var warn24 = warnOnce("Calendar");
var Calendar = (_param) => {
  var { value, onChange, disablePast, disableFuture, shouldDisableDate, onClose, enableTime = false, doneButtonText, doneButtonDisabled, doneButtonShow, weekStartsOn = 1, disablePickers, changeHoursLabel = "Изменить час", changeMinutesLabel = "Изменить минуту", prevMonthLabel = "Предыдущий месяц", nextMonthLabel = "Следующий месяц", changeMonthLabel = "Изменить месяц", changeYearLabel = "Изменить год", showNeighboringMonth, changeDayLabel = "Изменить день", size: size4 = "m", viewDate: externalViewDate, onHeaderChange, onNextMonth, onPrevMonth, prevMonthIcon, nextMonthIcon, prevMonthProps, nextMonthProps, dayProps, listenDayChangesForUpdate, renderDayContent, minDateTime, maxDateTime, minutesTestId, hoursTestId, doneButtonTestId, prevMonthButtonTestId, nextMonthButtonTestId, monthDropdownTestId, yearDropdownTestId, dayTestId } = _param, props = _object_without_properties(_param, [
    "value",
    "onChange",
    "disablePast",
    "disableFuture",
    "shouldDisableDate",
    "onClose",
    "enableTime",
    "doneButtonText",
    "doneButtonDisabled",
    "doneButtonShow",
    "weekStartsOn",
    "disablePickers",
    "changeHoursLabel",
    "changeMinutesLabel",
    "prevMonthLabel",
    "nextMonthLabel",
    "changeMonthLabel",
    "changeYearLabel",
    "showNeighboringMonth",
    "changeDayLabel",
    "size",
    "viewDate",
    "onHeaderChange",
    "onNextMonth",
    "onPrevMonth",
    "prevMonthIcon",
    "nextMonthIcon",
    "prevMonthProps",
    "nextMonthProps",
    "dayProps",
    "listenDayChangesForUpdate",
    "renderDayContent",
    "minDateTime",
    "maxDateTime",
    "minutesTestId",
    "hoursTestId",
    "doneButtonTestId",
    "prevMonthButtonTestId",
    "nextMonthButtonTestId",
    "monthDropdownTestId",
    "yearDropdownTestId",
    "dayTestId"
  ]);
  const { viewDate, setViewDate, setPrevMonth, setNextMonth, focusedDay, setFocusedDay, isDayFocused, isDayDisabled, resetSelectedDay, isMonthDisabled, isYearDisabled } = useCalendar({
    value,
    disableFuture,
    disablePast,
    shouldDisableDate,
    onHeaderChange,
    onNextMonth,
    onPrevMonth,
    minDateTime,
    maxDateTime
  });
  useIsomorphicLayoutEffect(() => {
    if (value) {
      setViewDate(value);
    }
  }, [
    value
  ]);
  if (!disablePickers && size4 === "s") {
    warn24("Нельзя включить селекты выбора месяца/года, если размер календаря 's'", "error");
  }
  if (enableTime && size4 === "s") {
    warn24("Нельзя включить выбор времени, если размер календаря 's'", "error");
  }
  const handleKeyDown = React234.useCallback((event) => {
    if ([
      "ArrowUp",
      "ArrowDown",
      "ArrowLeft",
      "ArrowRight"
    ].includes(event.key)) {
      event.preventDefault();
    }
    const newFocusedDay = navigateDate(focusedDay !== null && focusedDay !== void 0 ? focusedDay : value, event.key);
    if (newFocusedDay && !isSameMonth(newFocusedDay, viewDate)) {
      setViewDate(newFocusedDay);
    }
    setFocusedDay(newFocusedDay);
  }, [
    focusedDay,
    setFocusedDay,
    setViewDate,
    value,
    viewDate
  ]);
  const onDayChange = React234.useCallback((date) => {
    let actualDate = setTimeEqual(date, value);
    if (minDateTime || maxDateTime) {
      actualDate = clamp3(actualDate, {
        min: minDateTime,
        max: maxDateTime
      });
    }
    onChange === null || onChange === void 0 ? void 0 : onChange(actualDate);
  }, [
    value,
    onChange,
    maxDateTime,
    minDateTime
  ]);
  const isDayActive = React234.useCallback((day) => Boolean(value && isSameDay(day, value)), [
    value
  ]);
  return (0, import_jsx_runtime213.jsxs)(RootComponent, _object_spread_props(_object_spread({}, props), {
    baseClassName: clsx("vkuiCalendar", size4 === "s" && "vkuiCalendar--size-s"),
    children: [
      (0, import_jsx_runtime213.jsx)(CalendarHeader, {
        viewDate: externalViewDate || viewDate,
        onChange: setViewDate,
        onNextMonth: setNextMonth,
        onPrevMonth: setPrevMonth,
        disablePickers: disablePickers || size4 === "s",
        className: "vkuiCalendar__header",
        prevMonthLabel,
        nextMonthLabel,
        changeMonthLabel,
        changeYearLabel,
        prevMonthIcon,
        nextMonthIcon,
        prevMonthProps,
        nextMonthProps,
        isMonthDisabled,
        isYearDisabled,
        nextMonthButtonTestId,
        prevMonthButtonTestId,
        monthDropdownTestId,
        yearDropdownTestId
      }),
      (0, import_jsx_runtime213.jsx)(CalendarDays, {
        viewDate: externalViewDate || viewDate,
        value,
        weekStartsOn,
        isDayFocused,
        tabIndex: 0,
        "aria-label": changeDayLabel,
        onKeyDown: handleKeyDown,
        onDayChange,
        isDayActive,
        isDaySelectionStart: isFirstDay,
        isDaySelectionEnd: isLastDay,
        isDayDisabled,
        onBlur: resetSelectedDay,
        showNeighboringMonth,
        size: size4,
        dayProps,
        listenDayChangesForUpdate,
        renderDayContent,
        dayTestId
      }),
      enableTime && value && size4 !== "s" && (0, import_jsx_runtime213.jsx)("div", {
        className: "vkuiCalendar__time",
        children: (0, import_jsx_runtime213.jsx)(CalendarTime, {
          value,
          onChange,
          onClose,
          doneButtonText,
          doneButtonDisabled,
          doneButtonShow,
          changeHoursLabel,
          changeMinutesLabel,
          isDayDisabled: minDateTime || maxDateTime ? isDayDisabled : void 0,
          minutesTestId,
          hoursTestId,
          doneButtonTestId
        })
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/CalendarRange/CalendarRange.js
var import_jsx_runtime214 = __toESM(require_jsx_runtime());
var React235 = __toESM(require_react());
var getIsDaySelected = (day, value) => {
  if (!(value === null || value === void 0 ? void 0 : value[0]) || !value[1]) {
    return false;
  }
  return isWithinInterval(day, {
    start: startOfDay(value[0]),
    end: endOfDay(value[1])
  });
};
var CalendarRange = (_param) => {
  var { value, onChange, disablePast, disableFuture, shouldDisableDate, onClose, weekStartsOn = 1, disablePickers, prevMonthLabel = "Предыдущий месяц", nextMonthLabel = "Следующий месяц", changeMonthLabel = "Изменить месяц", changeYearLabel = "Изменить год", changeDayLabel = "Изменить день", prevMonthIcon, nextMonthIcon, listenDayChangesForUpdate, renderDayContent, dayTestId, leftPartHeaderTestsData, rightPartHeaderTestsData } = _param, props = _object_without_properties(_param, [
    "value",
    "onChange",
    "disablePast",
    "disableFuture",
    "shouldDisableDate",
    "onClose",
    "weekStartsOn",
    "disablePickers",
    "prevMonthLabel",
    "nextMonthLabel",
    "changeMonthLabel",
    "changeYearLabel",
    "changeDayLabel",
    "prevMonthIcon",
    "nextMonthIcon",
    "listenDayChangesForUpdate",
    "renderDayContent",
    "dayTestId",
    "leftPartHeaderTestsData",
    "rightPartHeaderTestsData"
  ]);
  const { viewDate, setViewDate, setPrevMonth, setNextMonth, focusedDay, setFocusedDay, isDayFocused, isDayDisabled, resetSelectedDay, isMonthDisabled, isYearDisabled } = useCalendar({
    value,
    disableFuture,
    disablePast,
    shouldDisableDate
  });
  const [hintedDate, setHintedDate] = React235.useState();
  const secondViewDate = addMonths(viewDate, 1);
  const handleKeyDown = React235.useCallback((event) => {
    if ([
      "ArrowUp",
      "ArrowDown",
      "ArrowLeft",
      "ArrowRight"
    ].includes(event.key)) {
      event.preventDefault();
    }
    const newFocusedDay = navigateDate(focusedDay !== null && focusedDay !== void 0 ? focusedDay : value === null || value === void 0 ? void 0 : value[1], event.key);
    if (newFocusedDay && !isSameMonth(newFocusedDay, viewDate) && !isSameMonth(newFocusedDay, addMonths(viewDate, 1))) {
      setViewDate(newFocusedDay);
    }
    setFocusedDay(newFocusedDay);
  }, [
    focusedDay,
    setFocusedDay,
    setViewDate,
    value,
    viewDate
  ]);
  const getNewValue = React235.useCallback((date) => {
    const isValueEmpty = !value || value[0] === null && value[1] === null;
    if (isValueEmpty) {
      return [
        date,
        null
      ];
    }
    const [start, end] = value;
    if (start && isSameDay(date, start) || end && isSameDay(date, end)) {
      return [
        setTimeEqual(date, start),
        setTimeEqual(date, end)
      ];
    } else if (start && isBefore(date, start)) {
      return [
        setTimeEqual(date, start),
        end
      ];
    } else if (start && isAfter(date, start)) {
      return [
        start,
        setTimeEqual(date, end)
      ];
    }
    return value;
  }, [
    value
  ]);
  const onDayChange = React235.useCallback((date) => {
    onChange === null || onChange === void 0 ? void 0 : onChange(getNewValue(date));
    setHintedDate(void 0);
  }, [
    onChange,
    getNewValue
  ]);
  const isDaySelected = React235.useCallback((day) => getIsDaySelected(day, value), [
    value
  ]);
  const isDayActive = React235.useCallback((day) => Boolean((value === null || value === void 0 ? void 0 : value[0]) && isSameDay(day, value[0]) || (value === null || value === void 0 ? void 0 : value[1]) && isSameDay(day, value[1])), [
    value
  ]);
  const isDaySelectionEnd = React235.useCallback((day, dayOfWeek) => Boolean(isLastDay(day, dayOfWeek) || (value === null || value === void 0 ? void 0 : value[1]) && isSameDay(day, value[1])), [
    value
  ]);
  const isHintedDaySelectionEnd = React235.useCallback((day, dayOfWeek) => Boolean(isLastDay(day, dayOfWeek) || (hintedDate === null || hintedDate === void 0 ? void 0 : hintedDate[1]) && isSameDay(day, hintedDate[1])), [
    hintedDate
  ]);
  const isDaySelectionStart = React235.useCallback((day, dayOfWeek) => Boolean(isFirstDay(day, dayOfWeek) || (value === null || value === void 0 ? void 0 : value[0]) && isSameDay(day, value[0])), [
    value
  ]);
  const isHintedDaySelectionStart = React235.useCallback((day, dayOfWeek) => Boolean(isFirstDay(day, dayOfWeek) || (hintedDate === null || hintedDate === void 0 ? void 0 : hintedDate[0]) && isSameDay(day, hintedDate[0])), [
    hintedDate
  ]);
  const onDayEnter = React235.useCallback((date) => setHintedDate(getNewValue(date)), [
    setHintedDate,
    getNewValue
  ]);
  const onDayLeave = React235.useCallback(() => setHintedDate(void 0), [
    setHintedDate
  ]);
  const isDayHinted = React235.useCallback((day) => getIsDaySelected(day, hintedDate), [
    hintedDate
  ]);
  const onRightPartViewDateChange = React235.useCallback((newDate) => setViewDate(subMonths(newDate, 1)), [
    setViewDate
  ]);
  return (0, import_jsx_runtime214.jsxs)(RootComponent, _object_spread_props(_object_spread({}, props), {
    baseClassName: "vkuiCalendarRange",
    children: [
      (0, import_jsx_runtime214.jsxs)("div", {
        className: "vkuiCalendarRange__inner",
        children: [
          (0, import_jsx_runtime214.jsx)(CalendarHeader, _object_spread({
            viewDate,
            onChange: setViewDate,
            nextMonthHidden: true,
            onPrevMonth: setPrevMonth,
            disablePickers,
            className: "vkuiCalendarRange__header",
            prevMonthLabel,
            nextMonthLabel,
            changeMonthLabel,
            changeYearLabel,
            prevMonthIcon,
            isMonthDisabled,
            isYearDisabled
          }, leftPartHeaderTestsData)),
          (0, import_jsx_runtime214.jsx)(CalendarDays, {
            viewDate,
            value,
            weekStartsOn,
            onKeyDown: handleKeyDown,
            isDayFocused,
            onDayChange,
            isDaySelected,
            isDayActive,
            isDaySelectionEnd,
            isDaySelectionStart,
            isDayHinted,
            onDayEnter,
            onDayLeave,
            isHintedDaySelectionEnd,
            isHintedDaySelectionStart,
            isDayDisabled,
            listenDayChangesForUpdate,
            renderDayContent,
            "aria-label": changeDayLabel,
            dayTestId
          })
        ]
      }),
      (0, import_jsx_runtime214.jsxs)("div", {
        className: "vkuiCalendarRange__inner",
        children: [
          (0, import_jsx_runtime214.jsx)(CalendarHeader, _object_spread({
            viewDate: secondViewDate,
            onChange: onRightPartViewDateChange,
            prevMonthHidden: true,
            onNextMonth: setNextMonth,
            disablePickers,
            className: "vkuiCalendarRange__header",
            prevMonthLabel,
            nextMonthLabel,
            changeMonthLabel,
            changeYearLabel,
            nextMonthIcon,
            isMonthDisabled,
            isYearDisabled
          }, rightPartHeaderTestsData)),
          (0, import_jsx_runtime214.jsx)(CalendarDays, {
            viewDate: secondViewDate,
            value,
            weekStartsOn,
            "aria-label": changeDayLabel,
            onKeyDown: handleKeyDown,
            isDayFocused,
            onDayChange,
            isDaySelected,
            isDayActive,
            isDaySelectionEnd,
            isDaySelectionStart,
            isDayHinted,
            onDayEnter,
            onDayLeave,
            isHintedDaySelectionEnd,
            isHintedDaySelectionStart,
            isDayDisabled,
            listenDayChangesForUpdate,
            renderDayContent,
            tabIndex: 0,
            onBlur: resetSelectedDay,
            dayTestId
          })
        ]
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/DateInput/DateInput.js
var import_jsx_runtime217 = __toESM(require_jsx_runtime());
var React239 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useDateInput.js
var import_react12 = __toESM(require_react());
var React236 = __toESM(require_react());
function useDateInput({ maxElement, refs, autoFocus, disabled, elementsConfig: elementsConfig3, onChange, onInternalValueChange, getInternalValue: getInternalValue3, value, onCalendarOpenChanged }) {
  const { document: document2 } = useDOM();
  const { value: open, setTrue: openCalendar, setFalse: closeCalendar } = useBooleanState(false);
  const rootRef = React236.useRef(null);
  const calendarRef = React236.useRef(null);
  const [internalValue, setInternalValue] = React236.useState([]);
  const [focusedElement, setFocusedElement] = React236.useState(null);
  const { window: window2 } = useDOM();
  const _onCalendarClose = (0, import_react12.useCallback)(() => {
    if (open) {
      closeCalendar();
      onCalendarOpenChanged === null || onCalendarOpenChanged === void 0 ? void 0 : onCalendarOpenChanged(false);
    }
  }, [
    closeCalendar,
    onCalendarOpenChanged,
    open
  ]);
  const _onCalendarOpen = (0, import_react12.useCallback)(() => {
    if (!open) {
      openCalendar();
      onCalendarOpenChanged === null || onCalendarOpenChanged === void 0 ? void 0 : onCalendarOpenChanged(true);
    }
  }, [
    onCalendarOpenChanged,
    open,
    openCalendar
  ]);
  const removeFocusFromField = React236.useCallback(() => {
    if (focusedElement !== null) {
      var _window_getSelection;
      setFocusedElement(null);
      _onCalendarClose();
      (_window_getSelection = window2.getSelection()) === null || _window_getSelection === void 0 ? void 0 : _window_getSelection.removeAllRanges();
      setInternalValue(getInternalValue3(value));
    }
  }, [
    focusedElement,
    _onCalendarClose,
    window2,
    getInternalValue3,
    value
  ]);
  const handleClickOutside = React236.useCallback((e) => {
    var _rootRef_current, _calendarRef_current;
    if (!((_rootRef_current = rootRef.current) === null || _rootRef_current === void 0 ? void 0 : _rootRef_current.contains(e.target)) && !((_calendarRef_current = calendarRef.current) === null || _calendarRef_current === void 0 ? void 0 : _calendarRef_current.contains(e.target))) {
      removeFocusFromField();
    }
  }, [
    removeFocusFromField
  ]);
  const selectFirst = React236.useCallback(() => {
    setFocusedElement(0);
  }, []);
  useGlobalEventListener(document2, "click", handleClickOutside, {
    capture: true
  });
  React236.useEffect(() => {
    setInternalValue(getInternalValue3(value));
  }, [
    getInternalValue3,
    value
  ]);
  React236.useEffect(() => {
    if (autoFocus) {
      selectFirst();
    }
  }, [
    autoFocus,
    selectFirst
  ]);
  React236.useEffect(() => {
    if (disabled || focusedElement === null) {
      return;
    }
    const range2 = window2.document.createRange();
    let element = refs[focusedElement].current;
    if (element) {
      element.focus();
      _onCalendarOpen();
      range2.selectNodeContents(element);
      const selection = window2.getSelection();
      selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();
      selection === null || selection === void 0 ? void 0 : selection.addRange(range2);
    }
  }, [
    disabled,
    focusedElement,
    _onCalendarOpen,
    refs,
    window2
  ]);
  const clear = React236.useCallback(() => {
    onChange === null || onChange === void 0 ? void 0 : onChange(void 0);
    selectFirst();
  }, [
    onChange,
    selectFirst
  ]);
  const handleFieldEnter = React236.useCallback(() => {
    if (!open) {
      selectFirst();
    }
  }, [
    open,
    selectFirst
  ]);
  const handleKeyDown = React236.useCallback((e) => {
    if (focusedElement === null) {
      return;
    }
    const _value = [
      ...internalValue
    ];
    const config = elementsConfig3(focusedElement);
    if (/^\d+$/.test(e.key)) {
      if (_value[focusedElement].length >= config.length) {
        _value[focusedElement] = e.key;
      } else {
        _value[focusedElement] += e.key;
        if (_value[focusedElement].length >= config.length && focusedElement < maxElement) {
          setFocusedElement(focusedElement + 1);
        }
      }
    } else if (e.key === "Backspace") {
      if (!_value[focusedElement]) {
        setFocusedElement(focusedElement <= 0 ? maxElement : focusedElement - 1);
      } else {
        _value[focusedElement] = _value[focusedElement].slice(0, -1);
      }
    } else if (e.key === "ArrowDown" || e.key === "Down") {
      let currentValue = Number(_value[focusedElement]);
      _value[focusedElement] = String(currentValue <= config.min ? config.max : currentValue - 1).padStart(config.length, "0");
    } else if (e.key === "ArrowUp" || e.key === "Up") {
      let currentValue = Number(_value[focusedElement]);
      _value[focusedElement] = String(currentValue >= config.max ? config.min : currentValue + 1).padStart(config.length, "0");
    } else if (e.key === "Enter" || e.key === "Tab" && focusedElement === maxElement || e.key === "Tab" && e.shiftKey && focusedElement === 0) {
      removeFocusFromField();
      return;
    } else if (e.key === "ArrowLeft" || e.key === "Left" || e.key === "Tab" && e.shiftKey) {
      setFocusedElement(focusedElement <= 0 ? maxElement : focusedElement - 1);
    } else if (e.key === "ArrowRight" || e.key === "Right" || e.key === "Tab") {
      setFocusedElement(focusedElement >= maxElement ? 0 : focusedElement + 1);
    } else if (e.key === "Delete" || e.key === "Del") {
      _value[focusedElement] = "";
    } else {
      return;
    }
    e.preventDefault();
    setInternalValue(_value);
    onInternalValueChange(_value);
  }, [
    elementsConfig3,
    focusedElement,
    internalValue,
    maxElement,
    onInternalValueChange,
    removeFocusFromField
  ]);
  return {
    rootRef,
    calendarRef,
    open,
    openCalendar: _onCalendarOpen,
    closeCalendar: _onCalendarClose,
    internalValue,
    focusedElement,
    setFocusedElement,
    handleKeyDown,
    clear,
    handleFieldEnter,
    removeFocusFromField
  };
}

// node_modules/@vkontakte/vkui/dist/lib/date.js
function parse2(input, format3, referenceDate = /* @__PURE__ */ new Date()) {
  const match2 = /^\d\d/;
  const match4 = /^\d{4}/;
  const entries = [
    [
      "yyyy",
      match4,
      (val) => [
        "Y",
        +val,
        true
      ]
    ],
    [
      "MM",
      match2,
      (val) => {
        const numVal = +val;
        const okay = numVal > 0 && numVal <= 12;
        return [
          "M",
          numVal - 1,
          okay
        ];
      }
    ],
    [
      "dd",
      match2,
      (val) => [
        "D",
        +val,
        true
      ]
    ],
    [
      "HH",
      match2,
      (val) => {
        const numVal = parseInt(val, 10);
        const okay = numVal >= 0 && numVal < 24;
        return [
          "h",
          numVal,
          okay
        ];
      }
    ],
    [
      "mm",
      match2,
      (val) => {
        const numVal = parseInt(val, 10);
        const okay = numVal >= 0 && numVal < 60;
        return [
          "m",
          numVal,
          okay
        ];
      }
    ]
  ];
  const superRegExp = new RegExp(entries.map((item) => item[0]).join("|"), "g");
  const store = {
    y: referenceDate.getFullYear(),
    M: referenceDate.getMonth(),
    d: referenceDate.getDate(),
    h: referenceDate.getHours(),
    m: referenceDate.getMinutes(),
    s: referenceDate.getSeconds(),
    ms: referenceDate.getMilliseconds()
  };
  let prevInputIndex = 0;
  let lastNonFormatting = "";
  let lastFormatIndex = 0;
  let found = false;
  while (true) {
    const match3 = superRegExp.exec(format3);
    if (!match3) {
      break;
    }
    const length = match3[0].length;
    const atIndex = superRegExp.lastIndex - length;
    const item = entries.find((item2) => item2[0] === match3[0]);
    lastNonFormatting = format3.slice(lastFormatIndex, atIndex);
    lastFormatIndex = superRegExp.lastIndex;
    if (input.slice(prevInputIndex, prevInputIndex + lastNonFormatting.length) !== lastNonFormatting) {
      return /* @__PURE__ */ new Date("");
    }
    const value = input.slice(prevInputIndex + lastNonFormatting.length).match(item[1]);
    if (!value) {
      return /* @__PURE__ */ new Date("");
    }
    prevInputIndex = prevInputIndex + lastNonFormatting.length + value[0].length;
    const [key, newValue, okay] = item[2](value[0]);
    if (!okay) {
      return /* @__PURE__ */ new Date("");
    }
    store[key] = newValue;
    found = true;
  }
  if (!found) {
    return /* @__PURE__ */ new Date("");
  }
  const date = new Date(store.Y, store.M, store.D, store.h, store.m, store.s, store.ms);
  if (date.getMonth() !== store.M || date.getDate() !== store.D) {
    return /* @__PURE__ */ new Date("");
  }
  return date;
}
function format2(date, format3) {
  return lightFormat(date, format3);
}
function isMatch(input, format3) {
  return !isNaN(+parse2(input, format3));
}

// node_modules/@vkontakte/vkui/dist/components/InputLike/InputLike.js
var import_jsx_runtime215 = __toESM(require_jsx_runtime());
var React237 = __toESM(require_react());
var MASK_SYMBOL = String.fromCharCode(8199);
function getMaskElements(length) {
  const result = [];
  for (let index2 = 0; index2 < length; index2 += 1) {
    result.push((0, import_jsx_runtime215.jsx)("span", {
      className: "vkuiInputLike__mask",
      children: MASK_SYMBOL
    }, index2));
  }
  return result;
}
var InputLike = (_param) => {
  var { value, length, index: index2, onElementSelect, onClick, onFocus, label } = _param, restProps = _object_without_properties(_param, [
    "value",
    "length",
    "index",
    "onElementSelect",
    "onClick",
    "onFocus",
    "label"
  ]);
  const handleElementSelect = React237.useCallback((event) => {
    stopPropagation(event);
    onElementSelect === null || onElementSelect === void 0 ? void 0 : onElementSelect(index2);
  }, [
    index2,
    onElementSelect
  ]);
  var _value_length;
  return (0, import_jsx_runtime215.jsxs)(RootComponent, _object_spread_props(_object_spread({
    Component: "span",
    baseClassName: (value === null || value === void 0 ? void 0 : value.length) === length ? "vkuiInputLike--full" : void 0,
    tabIndex: 0,
    onClick: callMultiple(onClick, handleElementSelect),
    onFocus: callMultiple(stopPropagation, onFocus)
  }, restProps), {
    children: [
      label && (0, import_jsx_runtime215.jsx)(VisuallyHidden, {
        children: label
      }),
      value === null || value === void 0 ? void 0 : value.slice(0, length - 1),
      (value === null || value === void 0 ? void 0 : value.slice(length - 1)) && (0, import_jsx_runtime215.jsx)("span", {
        className: "vkuiInputLike__last_character",
        children: value.slice(length - 1)
      }, index2),
      getMaskElements(length - ((_value_length = value === null || value === void 0 ? void 0 : value.length) !== null && _value_length !== void 0 ? _value_length : 0))
    ]
  }));
};
InputLike.displayName = "InputLike";

// node_modules/@vkontakte/vkui/dist/components/InputLike/InputLikeDivider.js
var import_jsx_runtime216 = __toESM(require_jsx_runtime());
var React238 = __toESM(require_react());
var InputLikeDivider = (_param) => {
  var { children, className } = _param, props = _object_without_properties(_param, [
    "children",
    "className"
  ]);
  return (0, import_jsx_runtime216.jsx)("span", _object_spread_props(_object_spread({
    className: clsx("vkuiInputLike__divider", className)
  }, props), {
    children
  }));
};

// node_modules/@vkontakte/vkui/dist/components/DateInput/DateInput.js
var sizeYClassNames37 = {
  none: "vkuiDateInput--sizeY-none",
  compact: "vkuiDateInput--sizeY-compact"
};
var elementsConfig = (index2) => {
  let length = 2;
  let min3 = 1;
  let max3 = 0;
  switch (index2) {
    case 0:
      max3 = 31;
      break;
    case 1:
      max3 = 12;
      break;
    case 2:
      max3 = 2100;
      min3 = 1900;
      length = 4;
      break;
    case 3:
      max3 = 23;
      break;
    case 4:
      max3 = 59;
      break;
  }
  return {
    length,
    min: min3,
    max: max3
  };
};
var getInternalValue = (value) => {
  const newValue = [
    "",
    "",
    "",
    "",
    ""
  ];
  if (value) {
    newValue[0] = String(value.getDate()).padStart(2, "0");
    newValue[1] = String(value.getMonth() + 1).padStart(2, "0");
    newValue[2] = String(value.getFullYear()).padStart(4, "0");
    newValue[3] = String(value.getHours()).padStart(2, "0");
    newValue[4] = String(value.getMinutes()).padStart(2, "0");
  }
  return newValue;
};
var DateInput = (_param) => {
  var { enableTime, shouldDisableDate, disableFuture, disablePast, minDateTime, maxDateTime, value, onChange, calendarPlacement = "bottom-start", style, className, doneButtonText, closeOnChange = true, disablePickers, getRootRef, name, autoFocus, disabled, onClick, onFocus, prevMonthLabel = "Предыдущий месяц", nextMonthLabel = "Следующий месяц", showNeighboringMonth, size: size4, changeMonthLabel = "Изменить месяц", changeYearLabel = "Изменить год", changeDayLabel = "Изменить день", changeHoursLabel = "Изменить час", changeMinutesLabel = "Изменить минуту", clearFieldLabel = "Очистить поле", showCalendarLabel = "Показать календарь", viewDate, onHeaderChange, onNextMonth, onPrevMonth, prevMonthIcon, nextMonthIcon, disableCalendar = false, renderDayContent, onCalendarOpenChanged, calendarTestsProps, dayFieldTestId, monthFieldTestId, yearFieldTestId, hourFieldTestId, minuteFieldTestId } = _param, props = _object_without_properties(_param, [
    "enableTime",
    "shouldDisableDate",
    "disableFuture",
    "disablePast",
    "minDateTime",
    "maxDateTime",
    "value",
    "onChange",
    "calendarPlacement",
    "style",
    "className",
    "doneButtonText",
    "closeOnChange",
    "disablePickers",
    "getRootRef",
    "name",
    "autoFocus",
    "disabled",
    "onClick",
    "onFocus",
    "prevMonthLabel",
    "nextMonthLabel",
    "showNeighboringMonth",
    "size",
    "changeMonthLabel",
    "changeYearLabel",
    "changeDayLabel",
    "changeHoursLabel",
    "changeMinutesLabel",
    "clearFieldLabel",
    "showCalendarLabel",
    "viewDate",
    "onHeaderChange",
    "onNextMonth",
    "onPrevMonth",
    "prevMonthIcon",
    "nextMonthIcon",
    "disableCalendar",
    "renderDayContent",
    "onCalendarOpenChanged",
    "calendarTestsProps",
    "dayFieldTestId",
    "monthFieldTestId",
    "yearFieldTestId",
    "hourFieldTestId",
    "minuteFieldTestId"
  ]);
  const daysRef = React239.useRef(null);
  const monthsRef = React239.useRef(null);
  const yearsRef = React239.useRef(null);
  const hoursRef = React239.useRef(null);
  const minutesRef = React239.useRef(null);
  const maxElement = enableTime ? 4 : 2;
  const onInternalValueChange = React239.useCallback((internalValue2) => {
    for (let i = 0; i <= maxElement; i += 1) {
      if (internalValue2[i].length < elementsConfig(i).length) {
        return;
      }
    }
    let formattedValue = `${internalValue2[0]}.${internalValue2[1]}.${internalValue2[2]}`;
    let mask = "dd.MM.yyyy";
    if (enableTime) {
      formattedValue += ` ${internalValue2[3]}:${internalValue2[4]}`;
      mask += " HH:mm";
    }
    if (isMatch(formattedValue, mask)) {
      const now2 = /* @__PURE__ */ new Date();
      onChange === null || onChange === void 0 ? void 0 : onChange(parse2(formattedValue, mask, value !== null && value !== void 0 ? value : enableTime ? startOfMinute(now2) : startOfDay(now2)));
    }
  }, [
    enableTime,
    maxElement,
    onChange,
    value
  ]);
  const refs = React239.useMemo(() => [
    daysRef,
    monthsRef,
    yearsRef,
    hoursRef,
    minutesRef
  ], [
    daysRef,
    monthsRef,
    yearsRef,
    hoursRef,
    minutesRef
  ]);
  const { rootRef, calendarRef, open, openCalendar, internalValue, handleKeyDown, setFocusedElement, handleFieldEnter, clear, removeFocusFromField } = useDateInput({
    maxElement,
    refs,
    autoFocus,
    disabled,
    elementsConfig,
    onChange,
    onInternalValueChange,
    getInternalValue,
    value,
    onCalendarOpenChanged
  });
  const { sizeY = "none" } = useAdaptivity();
  const handleRootRef = useExternRef(rootRef, getRootRef);
  const onCalendarChange = React239.useCallback((value2) => {
    onChange === null || onChange === void 0 ? void 0 : onChange(value2);
    if (closeOnChange && !enableTime) {
      removeFocusFromField();
    }
  }, [
    onChange,
    removeFocusFromField,
    closeOnChange,
    enableTime
  ]);
  return (0, import_jsx_runtime217.jsxs)(FormField, _object_spread_props(_object_spread({
    style,
    className: clsx(sizeY !== "regular" && sizeYClassNames37[sizeY], className),
    getRootRef: handleRootRef,
    after: value ? (0, import_jsx_runtime217.jsx)(IconButton, {
      hoverMode: "opacity",
      label: clearFieldLabel,
      onClick: clear,
      children: (0, import_jsx_runtime217.jsx)(Icon16Clear, {})
    }) : (0, import_jsx_runtime217.jsx)(IconButton, {
      hoverMode: "opacity",
      label: showCalendarLabel,
      onClick: openCalendar,
      children: (0, import_jsx_runtime217.jsx)(Icon20CalendarOutline, {})
    }),
    disabled,
    onClick: callMultiple(handleFieldEnter, onClick),
    onFocus: callMultiple(handleFieldEnter, onFocus)
  }, props), {
    children: [
      (0, import_jsx_runtime217.jsx)("input", {
        type: "hidden",
        name,
        value: value ? format2(value, enableTime ? "dd.MM.yyyy'T'HH:mm" : "dd.MM.yyyy") : ""
      }),
      (0, import_jsx_runtime217.jsxs)(Text, {
        className: "vkuiDateInput__input",
        onKeyDown: handleKeyDown,
        // Инцидент: в PR https://github.com/VKCOM/VKUI/pull/6649 стабильно ломается порядок стилей
        // из-за чего `.Typography--normalize` перебивает стили.
        normalize: false,
        Component: "span",
        children: [
          (0, import_jsx_runtime217.jsx)(InputLike, {
            length: 2,
            getRootRef: daysRef,
            index: 0,
            onElementSelect: setFocusedElement,
            value: internalValue[0],
            label: changeDayLabel,
            "data-testid": dayFieldTestId
          }),
          (0, import_jsx_runtime217.jsx)(InputLikeDivider, {
            children: "."
          }),
          (0, import_jsx_runtime217.jsx)(InputLike, {
            length: 2,
            getRootRef: monthsRef,
            index: 1,
            onElementSelect: setFocusedElement,
            value: internalValue[1],
            label: changeMonthLabel,
            "data-testid": monthFieldTestId
          }),
          (0, import_jsx_runtime217.jsx)(InputLikeDivider, {
            children: "."
          }),
          (0, import_jsx_runtime217.jsx)(InputLike, {
            length: 4,
            getRootRef: yearsRef,
            index: 2,
            onElementSelect: setFocusedElement,
            value: internalValue[2],
            label: changeYearLabel,
            "data-testid": yearFieldTestId
          }),
          enableTime && (0, import_jsx_runtime217.jsxs)(React239.Fragment, {
            children: [
              (0, import_jsx_runtime217.jsx)(InputLikeDivider, {
                className: "vkuiDateInput__input--time-divider",
                children: " "
              }),
              (0, import_jsx_runtime217.jsx)(InputLike, {
                length: 2,
                getRootRef: hoursRef,
                index: 3,
                onElementSelect: setFocusedElement,
                value: internalValue[3],
                label: changeHoursLabel,
                "data-testid": hourFieldTestId
              }),
              (0, import_jsx_runtime217.jsx)(InputLikeDivider, {
                children: ":"
              }),
              (0, import_jsx_runtime217.jsx)(InputLike, {
                length: 2,
                getRootRef: minutesRef,
                index: 4,
                onElementSelect: setFocusedElement,
                value: internalValue[4],
                label: changeMinutesLabel,
                "data-testid": minuteFieldTestId
              })
            ]
          })
        ]
      }),
      open && !disableCalendar && (0, import_jsx_runtime217.jsx)(Popper, {
        targetRef: rootRef,
        offsetByMainAxis: 8,
        placement: calendarPlacement,
        autoUpdateOnTargetResize: true,
        children: (0, import_jsx_runtime217.jsx)(Calendar, _object_spread({
          value,
          onChange: onCalendarChange,
          enableTime,
          disablePast,
          disableFuture,
          shouldDisableDate,
          onClose: removeFocusFromField,
          getRootRef: calendarRef,
          doneButtonText,
          disablePickers,
          changeHoursLabel,
          changeMinutesLabel,
          prevMonthLabel,
          nextMonthLabel,
          changeMonthLabel,
          changeYearLabel,
          changeDayLabel,
          showNeighboringMonth,
          renderDayContent,
          size: size4,
          viewDate,
          onHeaderChange,
          onNextMonth,
          onPrevMonth,
          prevMonthIcon,
          nextMonthIcon,
          minDateTime,
          maxDateTime
        }, calendarTestsProps))
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/DateRangeInput/DateRangeInput.js
var import_jsx_runtime218 = __toESM(require_jsx_runtime());
var React240 = __toESM(require_react());
var sizeYClassNames38 = {
  none: "vkuiDateRangeInput--sizeY-none",
  compact: "vkuiDateRangeInput--sizeY-compact"
};
var elementsConfig2 = (index2) => {
  let length = 2;
  let min3 = 1;
  let max3 = 0;
  switch (index2) {
    case 0:
    case 3:
      max3 = 31;
      break;
    case 1:
    case 4:
      max3 = 12;
      break;
    case 2:
    case 5:
      max3 = 2100;
      min3 = 1900;
      length = 4;
      break;
  }
  return {
    length,
    min: min3,
    max: max3
  };
};
var getInternalValue2 = (value) => {
  const newValue = [
    "",
    "",
    "",
    "",
    "",
    ""
  ];
  if (value === null || value === void 0 ? void 0 : value[0]) {
    newValue[0] = String(value[0].getDate()).padStart(2, "0");
    newValue[1] = String(value[0].getMonth() + 1).padStart(2, "0");
    newValue[2] = String(value[0].getFullYear()).padStart(4, "0");
  }
  if (value === null || value === void 0 ? void 0 : value[1]) {
    newValue[3] = String(value[1].getDate()).padStart(2, "0");
    newValue[4] = String(value[1].getMonth() + 1).padStart(2, "0");
    newValue[5] = String(value[1].getFullYear()).padStart(4, "0");
  }
  return newValue;
};
var DateRangeInput = (_param) => {
  var { shouldDisableDate, disableFuture, disablePast, value, onChange, calendarPlacement = "bottom-start", style, className, closeOnChange = true, disablePickers, getRootRef, name, autoFocus, disabled, onClick, onFocus, prevMonthLabel = "Предыдущий месяц", nextMonthLabel = "Следующий месяц", changeDayLabel = "Изменить день", changeMonthLabel = "Изменить месяц", changeYearLabel = "Изменить год", changeStartDayLabel = "Изменить день начала", changeStartMonthLabel = "Изменить месяц начала", changeStartYearLabel = "Изменить год начала", changeEndDayLabel = "Изменить день окончания", changeEndMonthLabel = "Изменить месяц окончания", changeEndYearLabel = "Изменить год окончания", clearFieldLabel = "Очистить поле", showCalendarLabel = "Показать календарь", prevMonthIcon, nextMonthIcon, disableCalendar = false, onCalendarOpenChanged, renderDayContent, calendarTestsProps, startDateTestsProps, endDateTestsProps } = _param, props = _object_without_properties(_param, [
    "shouldDisableDate",
    "disableFuture",
    "disablePast",
    "value",
    "onChange",
    "calendarPlacement",
    "style",
    "className",
    "closeOnChange",
    "disablePickers",
    "getRootRef",
    "name",
    "autoFocus",
    "disabled",
    "onClick",
    "onFocus",
    "prevMonthLabel",
    "nextMonthLabel",
    "changeDayLabel",
    "changeMonthLabel",
    "changeYearLabel",
    "changeStartDayLabel",
    "changeStartMonthLabel",
    "changeStartYearLabel",
    "changeEndDayLabel",
    "changeEndMonthLabel",
    "changeEndYearLabel",
    "clearFieldLabel",
    "showCalendarLabel",
    "prevMonthIcon",
    "nextMonthIcon",
    "disableCalendar",
    "onCalendarOpenChanged",
    "renderDayContent",
    "calendarTestsProps",
    "startDateTestsProps",
    "endDateTestsProps"
  ]);
  const daysStartRef = React240.useRef(null);
  const monthsStartRef = React240.useRef(null);
  const yearsStartRef = React240.useRef(null);
  const daysEndRef = React240.useRef(null);
  const monthsEndRef = React240.useRef(null);
  const yearsEndRef = React240.useRef(null);
  const onInternalValueChange = React240.useCallback((internalValue2) => {
    let isStartValid = true;
    let isEndValid = true;
    for (let i = 0; i <= 2; i += 1) {
      if (internalValue2[i].length < elementsConfig2(i).length) {
        isStartValid = false;
      }
    }
    for (let i = 3; i <= 5; i += 1) {
      if (internalValue2[i].length < elementsConfig2(i).length) {
        isEndValid = false;
      }
    }
    const formattedStartValue = `${internalValue2[0]}.${internalValue2[1]}.${internalValue2[2]}`;
    const formattedEndValue = `${internalValue2[3]}.${internalValue2[4]}.${internalValue2[5]}`;
    const mask = "dd.MM.yyyy";
    if (!isMatch(formattedStartValue, mask)) {
      isStartValid = false;
    }
    if (!isMatch(formattedEndValue, mask)) {
      isEndValid = false;
    }
    if (!isStartValid && !isEndValid) {
      return;
    }
    const valueExists = Array.isArray(value);
    const now2 = /* @__PURE__ */ new Date();
    const start = isStartValid ? parse2(formattedStartValue, mask, valueExists && (value === null || value === void 0 ? void 0 : value[0]) || now2) : null;
    const end = isEndValid ? parse2(formattedEndValue, mask, valueExists && (value === null || value === void 0 ? void 0 : value[1]) || now2) : null;
    if (start && end && isAfter(end, start)) {
      onChange === null || onChange === void 0 ? void 0 : onChange([
        start,
        end
      ]);
    }
  }, [
    onChange,
    value
  ]);
  const refs = React240.useMemo(() => [
    daysStartRef,
    monthsStartRef,
    yearsStartRef,
    daysEndRef,
    monthsEndRef,
    yearsEndRef
  ], [
    daysStartRef,
    monthsStartRef,
    yearsStartRef,
    daysEndRef,
    monthsEndRef,
    yearsEndRef
  ]);
  const { rootRef, calendarRef, open, openCalendar, closeCalendar, internalValue, handleKeyDown, setFocusedElement, handleFieldEnter, clear, removeFocusFromField } = useDateInput({
    maxElement: 5,
    refs,
    autoFocus,
    disabled,
    elementsConfig: elementsConfig2,
    onChange,
    onInternalValueChange,
    getInternalValue: getInternalValue2,
    value,
    onCalendarOpenChanged
  });
  const { sizeY = "none" } = useAdaptivity();
  const handleRootRef = useExternRef(rootRef, getRootRef);
  const onCalendarChange = React240.useCallback((newValue) => {
    onChange === null || onChange === void 0 ? void 0 : onChange(newValue);
    if (closeOnChange && (newValue === null || newValue === void 0 ? void 0 : newValue[1]) && newValue[1] !== (value === null || value === void 0 ? void 0 : value[1])) {
      removeFocusFromField();
    }
  }, [
    onChange,
    closeOnChange,
    value,
    removeFocusFromField
  ]);
  return (0, import_jsx_runtime218.jsxs)(FormField, _object_spread_props(_object_spread({
    style,
    className: clsx(sizeY !== "regular" && sizeYClassNames38[sizeY], className),
    getRootRef: handleRootRef,
    after: value ? (0, import_jsx_runtime218.jsxs)(IconButton, {
      hoverMode: "opacity",
      onClick: clear,
      children: [
        (0, import_jsx_runtime218.jsx)(VisuallyHidden, {
          children: clearFieldLabel
        }),
        (0, import_jsx_runtime218.jsx)(Icon16Clear, {})
      ]
    }) : (0, import_jsx_runtime218.jsxs)(IconButton, {
      hoverMode: "opacity",
      onClick: openCalendar,
      children: [
        (0, import_jsx_runtime218.jsx)(VisuallyHidden, {
          children: showCalendarLabel
        }),
        (0, import_jsx_runtime218.jsx)(Icon20CalendarOutline, {})
      ]
    }),
    disabled,
    onClick: callMultiple(handleFieldEnter, onClick),
    onFocus: callMultiple(handleFieldEnter, onFocus)
  }, props), {
    children: [
      (0, import_jsx_runtime218.jsx)("input", {
        type: "hidden",
        name,
        value: value ? `${value[0] ? format2(value[0], "dd.MM.yyyy") : ""} - ${value[1] ? format2(value[1], "dd.MM.yyyy") : ""}` : ""
      }),
      (0, import_jsx_runtime218.jsxs)(Text, {
        className: "vkuiDateInput__input",
        onKeyDown: handleKeyDown,
        children: [
          (0, import_jsx_runtime218.jsx)(InputLike, {
            length: 2,
            getRootRef: daysStartRef,
            index: 0,
            onElementSelect: setFocusedElement,
            value: internalValue[0],
            label: changeStartDayLabel,
            "data-testid": startDateTestsProps === null || startDateTestsProps === void 0 ? void 0 : startDateTestsProps.day
          }),
          (0, import_jsx_runtime218.jsx)(InputLikeDivider, {
            children: "."
          }),
          (0, import_jsx_runtime218.jsx)(InputLike, {
            length: 2,
            getRootRef: monthsStartRef,
            index: 1,
            onElementSelect: setFocusedElement,
            value: internalValue[1],
            label: changeStartMonthLabel,
            "data-testid": startDateTestsProps === null || startDateTestsProps === void 0 ? void 0 : startDateTestsProps.month
          }),
          (0, import_jsx_runtime218.jsx)(InputLikeDivider, {
            children: "."
          }),
          (0, import_jsx_runtime218.jsx)(InputLike, {
            length: 4,
            getRootRef: yearsStartRef,
            index: 2,
            onElementSelect: setFocusedElement,
            value: internalValue[2],
            label: changeStartYearLabel,
            "data-testid": startDateTestsProps === null || startDateTestsProps === void 0 ? void 0 : startDateTestsProps.year
          }),
          (0, import_jsx_runtime218.jsx)(InputLikeDivider, {
            children: " — "
          }),
          (0, import_jsx_runtime218.jsx)(InputLike, {
            length: 2,
            getRootRef: daysEndRef,
            index: 3,
            onElementSelect: setFocusedElement,
            value: internalValue[3],
            label: changeEndDayLabel,
            "data-testid": endDateTestsProps === null || endDateTestsProps === void 0 ? void 0 : endDateTestsProps.day
          }),
          (0, import_jsx_runtime218.jsx)(InputLikeDivider, {
            children: "."
          }),
          (0, import_jsx_runtime218.jsx)(InputLike, {
            length: 2,
            getRootRef: monthsEndRef,
            index: 4,
            onElementSelect: setFocusedElement,
            value: internalValue[4],
            label: changeEndMonthLabel,
            "data-testid": endDateTestsProps === null || endDateTestsProps === void 0 ? void 0 : endDateTestsProps.month
          }),
          (0, import_jsx_runtime218.jsx)(InputLikeDivider, {
            children: "."
          }),
          (0, import_jsx_runtime218.jsx)(InputLike, {
            length: 4,
            getRootRef: yearsEndRef,
            index: 5,
            onElementSelect: setFocusedElement,
            value: internalValue[5],
            label: changeEndYearLabel,
            "data-testid": endDateTestsProps === null || endDateTestsProps === void 0 ? void 0 : endDateTestsProps.year
          })
        ]
      }),
      open && !disableCalendar && (0, import_jsx_runtime218.jsx)(Popper, {
        targetRef: rootRef,
        offsetByMainAxis: 8,
        placement: calendarPlacement,
        children: (0, import_jsx_runtime218.jsx)(CalendarRange, _object_spread({
          value,
          onChange: onCalendarChange,
          disablePast,
          disableFuture,
          shouldDisableDate,
          onClose: closeCalendar,
          getRootRef: calendarRef,
          disablePickers,
          prevMonthLabel,
          nextMonthLabel,
          changeMonthLabel,
          changeYearLabel,
          changeDayLabel,
          prevMonthIcon,
          nextMonthIcon,
          renderDayContent
        }, calendarTestsProps))
      })
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Skeleton/Skeleton.js
var import_jsx_runtime219 = __toESM(require_jsx_runtime());
var React241 = __toESM(require_react());
var CUSTOM_PROPERTY_GRADIENT_LEFT = "--vkui_internal--skeleton_gradient_left";
function useSkeletonSyncAnimation(disableAnimation, duration = 1.5) {
  const [isAnimationStarted, setIsAnimationStarted] = React241.useState(false);
  const timer = React241.useRef(void 0);
  const syncAnimation = React241.useCallback(() => {
    clearTimeout(timer.current);
    setIsAnimationStarted(false);
    const durationInMilliseconds = duration * millisecondsInSecond;
    const delay = durationInMilliseconds - performance.now() % durationInMilliseconds;
    timer.current = setTimeout(() => setIsAnimationStarted(true), delay);
    return () => clearTimeout(timer.current);
  }, [
    duration
  ]);
  React241.useEffect(() => {
    if (disableAnimation) {
      setIsAnimationStarted(false);
      return;
    }
    if (isAnimationStarted) {
      return;
    }
    return syncAnimation();
  }, [
    disableAnimation,
    isAnimationStarted,
    syncAnimation
  ]);
  return isAnimationStarted;
}
function useSkeletonPosition(rootRef) {
  const { document: document2, window: window2 } = useDOM();
  const [skeletonGradientLeft, setSkeletonGradientLeft] = React241.useState("0");
  const prevSkeletonGradientLeft = usePrevious(skeletonGradientLeft);
  const updatePosition = React241.useCallback(() => {
    const el = rootRef.current;
    if (!el || !document2) {
      return;
    }
    const value = -(el.getBoundingClientRect().left - document2.body.getBoundingClientRect().left);
    const gradientValue = value === 0 ? "0" : `${value}px`;
    if (prevSkeletonGradientLeft !== gradientValue) {
      setSkeletonGradientLeft(gradientValue);
    }
  }, [
    document2,
    prevSkeletonGradientLeft,
    rootRef
  ]);
  React241.useEffect(updatePosition, [
    updatePosition
  ]);
  useGlobalEventListener(window2, "resize", updatePosition);
  return skeletonGradientLeft;
}
var Skeleton = (_param) => {
  var { width, height, inlineSize, blockSize, maxWidth, maxInlineSize, borderRadius, style, children, colorFrom, colorTo, noAnimation = false, duration, margin, getRootRef } = _param, restProps = _object_without_properties(_param, [
    "width",
    "height",
    "inlineSize",
    "blockSize",
    "maxWidth",
    "maxInlineSize",
    "borderRadius",
    "style",
    "children",
    "colorFrom",
    "colorTo",
    "noAnimation",
    "duration",
    "margin",
    "getRootRef"
  ]);
  const rootRef = useExternRef(getRootRef);
  const disableAnimation = !useSkeletonSyncAnimation(noAnimation, duration);
  const skeletonGradientLeft = useSkeletonPosition(rootRef);
  const skeletonStyle = {
    width,
    height,
    inlineSize,
    blockSize,
    maxWidth,
    maxInlineSize,
    borderRadius,
    margin,
    [CUSTOM_PROPERTY_GRADIENT_LEFT]: skeletonGradientLeft
  };
  if (colorFrom) {
    skeletonStyle["--vkui_internal--skeleton_color_from"] = colorFrom;
  }
  if (colorTo) {
    skeletonStyle["--vkui_internal--skeleton_color_to"] = colorTo;
  }
  if (Number.isFinite(duration)) {
    skeletonStyle["--vkui_internal--skeleton_animation_duration"] = `${duration}s`;
  }
  return (0, import_jsx_runtime219.jsx)(RootComponent, _object_spread_props(_object_spread({
    getRootRef: rootRef,
    Component: "span",
    baseClassName: clsx("vkuiSkeleton", disableAnimation && "vkuiSkeleton--disableAnimation"),
    style: _object_spread({}, skeletonStyle, style)
  }, restProps), {
    children: children || (0, import_jsx_runtime219.jsx)(import_jsx_runtime219.Fragment, {
      children: "‌"
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Div/Div.js
var import_jsx_runtime220 = __toESM(require_jsx_runtime());
var React242 = __toESM(require_react());
var Div = (props) => (0, import_jsx_runtime220.jsx)(RootComponent, _object_spread({
  baseClassName: "vkuiDiv"
}, props));

// node_modules/@vkontakte/vkui/dist/components/PanelSpinner/PanelSpinner.js
var import_jsx_runtime221 = __toESM(require_jsx_runtime());
var React243 = __toESM(require_react());
var PanelSpinner = React243.memo((_param) => {
  var { height = 96, style } = _param, restProps = _object_without_properties(_param, [
    "height",
    "style"
  ]);
  return (0, import_jsx_runtime221.jsx)(Spinner, _object_spread_props(_object_spread({
    size: "regular"
  }, restProps), {
    style: _object_spread({
      height
    }, style)
  }));
});
PanelSpinner.displayName = "PanelSpinner";

// node_modules/@vkontakte/vkui/dist/components/PanelHeaderClose/PanelHeaderClose.js
var import_jsx_runtime222 = __toESM(require_jsx_runtime());
var PanelHeaderClose = (_param) => {
  var { children = "Отмена" } = _param, restProps = _object_without_properties(_param, [
    "children"
  ]);
  const platform3 = usePlatform();
  return (0, import_jsx_runtime222.jsx)(PanelHeaderButton, _object_spread_props(_object_spread({}, restProps), {
    children: platform3 === "ios" ? children : (0, import_jsx_runtime222.jsxs)(import_jsx_runtime222.Fragment, {
      children: [
        (0, import_jsx_runtime222.jsx)(VisuallyHidden, {
          children
        }),
        (0, import_jsx_runtime222.jsx)(AdaptiveIconRenderer, {
          IconCompact: Icon24CancelOutline,
          IconRegular: Icon28CancelOutline
        })
      ]
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/PanelHeaderBack/PanelHeaderBack.js
var import_jsx_runtime223 = __toESM(require_jsx_runtime());
var React244 = __toESM(require_react());
var getBackIcon = (platform3) => {
  switch (platform3) {
    case "ios":
      return (0, import_jsx_runtime223.jsx)(Icon28ChevronBack, {});
    case "vkcom":
      return (0, import_jsx_runtime223.jsx)(AdaptiveIconRenderer, {
        IconCompact: Icon20ChevronLeftOutline,
        IconRegular: Icon28ChevronLeftOutline
      });
    default:
      return (0, import_jsx_runtime223.jsx)(AdaptiveIconRenderer, {
        IconCompact: Icon24ArrowLeftOutline,
        IconRegular: Icon28ArrowLeftOutline
      });
  }
};
var PanelHeaderBack = (_param) => {
  var { label, className, children = "Назад" } = _param, restProps = _object_without_properties(_param, [
    "label",
    "className",
    "children"
  ]);
  const platform3 = usePlatform();
  const { sizeX = "none" } = useAdaptivity();
  const showLabel = platform3 === "vkcom" || platform3 === "ios";
  return (0, import_jsx_runtime223.jsxs)(PanelHeaderButton, _object_spread_props(_object_spread({}, restProps), {
    className: clsx(sizeX === "compact" && "vkuiPanelHeaderBack--sizeX-compact", platform3 === "ios" && "vkuiPanelHeaderBack--ios", platform3 === "vkcom" && "vkuiPanelHeaderBack--vkcom", showLabel && !!label && "vkuiPanelHeaderBack--has-label", className),
    label: showLabel && label,
    children: [
      children && (0, import_jsx_runtime223.jsx)(VisuallyHidden, {
        children
      }),
      getBackIcon(platform3)
    ]
  }));
};

// node_modules/@vkontakte/vkui/dist/components/PanelHeaderSubmit/PanelHeaderSubmit.js
var import_jsx_runtime224 = __toESM(require_jsx_runtime());
var PanelHeaderSubmit = (_param) => {
  var { children = "Готово" } = _param, restProps = _object_without_properties(_param, [
    "children"
  ]);
  const platform3 = usePlatform();
  return (0, import_jsx_runtime224.jsx)(PanelHeaderButton, _object_spread_props(_object_spread({
    primary: true
  }, restProps), {
    children: platform3 === "ios" ? children : (0, import_jsx_runtime224.jsxs)(import_jsx_runtime224.Fragment, {
      children: [
        (0, import_jsx_runtime224.jsx)(VisuallyHidden, {
          children
        }),
        (0, import_jsx_runtime224.jsx)(AdaptiveIconRenderer, {
          IconCompact: Icon24DoneOutline,
          IconRegular: Icon28DoneOutline
        })
      ]
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/PanelHeaderEdit/PanelHeaderEdit.js
var import_jsx_runtime225 = __toESM(require_jsx_runtime());
var React245 = __toESM(require_react());
var PanelHeaderEdit = (_param) => {
  var { isActive = false, editLabel = "Редактировать", doneLabel = "Готово" } = _param, restProps = _object_without_properties(_param, [
    "isActive",
    "editLabel",
    "doneLabel"
  ]);
  const platform3 = usePlatform();
  const label = isActive ? doneLabel : editLabel;
  return (0, import_jsx_runtime225.jsx)(PanelHeaderButton, _object_spread_props(_object_spread({}, restProps), {
    children: platform3 === "ios" ? label : (0, import_jsx_runtime225.jsxs)(import_jsx_runtime225.Fragment, {
      children: [
        (0, import_jsx_runtime225.jsx)(VisuallyHidden, {
          children: label
        }),
        (0, import_jsx_runtime225.jsx)(AdaptiveIconRenderer, {
          IconCompact: isActive ? Icon24DoneOutline : Icon24PenOutline,
          IconRegular: isActive ? Icon28DoneOutline : Icon28EditOutline
        })
      ]
    })
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ConfigProvider/ConfigProvider.js
var import_jsx_runtime226 = __toESM(require_jsx_runtime());
var React247 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useAutoDetectAppearance.js
var React246 = __toESM(require_react());
var useAutoDetectAppearance = (appearanceProp) => {
  const { window: window2 } = useDOM();
  const [appearance, setAppearance] = React246.useState(appearanceProp || Appearance.LIGHT);
  useIsomorphicLayoutEffect(() => {
    if (appearanceProp) {
      setAppearance(appearanceProp);
      return noop;
    }
    const mediaQuery = window2 ? window2.matchMedia("(prefers-color-scheme: dark)") : void 0;
    if (!mediaQuery) {
      return noop;
    }
    const check = (event) => {
      setAppearance(event.matches ? Appearance.DARK : Appearance.LIGHT);
    };
    check(mediaQuery);
    matchMediaListAddListener(mediaQuery, check);
    return () => matchMediaListRemoveListener(mediaQuery, check);
  }, [
    window2,
    appearanceProp
  ]);
  return appearance;
};

// node_modules/@vkontakte/vkui/dist/components/ConfigProvider/ConfigProvider.js
var ConfigProvider = (propsRaw) => {
  const props = excludeKeysWithUndefined(propsRaw);
  const parentConfig = useConfigProvider();
  const { children, hasCustomPanelHeaderAfter, customPanelHeaderAfterMinWidth, isWebView, transitionMotionEnabled, platform: platform3, locale, appearance: appearanceProp, tokensClassNames } = _object_spread({}, parentConfig, props);
  const appearance = useAutoDetectAppearance(appearanceProp);
  const configContext = useObjectMemo({
    hasCustomPanelHeaderAfter,
    customPanelHeaderAfterMinWidth,
    isWebView,
    transitionMotionEnabled,
    platform: platform3,
    locale,
    tokensClassNames,
    appearance
  });
  return (0, import_jsx_runtime226.jsx)(ConfigProviderContext.Provider, {
    value: configContext,
    children: (0, import_jsx_runtime226.jsx)(IconAppearanceProvider, {
      value: appearance,
      children: (0, import_jsx_runtime226.jsx)(TokensClassProvider, {
        children
      })
    })
  });
};

// node_modules/@vkontakte/vkui/dist/components/LocaleProvider/LocaleProvider.js
var import_jsx_runtime227 = __toESM(require_jsx_runtime());
var React248 = __toESM(require_react());
function LocaleProvider({ value, children }) {
  return (0, import_jsx_runtime227.jsx)(ConfigProviderOverride, {
    locale: value,
    children
  });
}

// node_modules/@vkontakte/vkui/dist/components/PlatformProvider/PlatformProvider.js
var import_jsx_runtime228 = __toESM(require_jsx_runtime());
var React249 = __toESM(require_react());
function PlatformProvider({ value, children }) {
  return (0, import_jsx_runtime228.jsx)(ConfigProviderOverride, {
    platform: value,
    children: (0, import_jsx_runtime228.jsx)(TokensClassProvider, {
      children
    })
  });
}

// node_modules/@vkontakte/vkui/dist/components/Popover/Popover.js
var import_jsx_runtime229 = __toESM(require_jsx_runtime());
var React250 = __toESM(require_react());
var Popover = (_param) => {
  var {
    // UsePopoverProps
    arrow: withArrow,
    arrowHeight = DEFAULT_ARROW_HEIGHT,
    arrowPadding = DEFAULT_ARROW_PADDING,
    placement: expectedPlacement = "bottom-start",
    onPlacementChange,
    disableFlipMiddleware = false,
    trigger = "click",
    content,
    hoverDelay = 150,
    closeAfterClick,
    offsetByMainAxis = 8,
    offsetByCrossAxis = 0,
    sameWidth,
    hideWhenReferenceHidden,
    disabled,
    disableInteractive,
    disableCloseOnClickOutside,
    disableCloseOnEscKey,
    keepMounted = false,
    customMiddlewares,
    // uncontrolled
    defaultShown = false,
    // controlled
    shown: shownProp,
    onShownChange,
    onShownChanged,
    // Для AppRootPortal
    usePortal = true,
    // Для FloatingArrow
    arrowProps,
    ArrowIcon: ArrowIcon2 = DefaultIcon,
    // FocusTrapProps
    autoFocus = true,
    restoreFocus = true,
    className,
    children,
    noStyling = false,
    zIndex = "var(--vkui--z_index_popout)",
    // a11y
    role = "dialog"
  } = _param, restPopoverProps = _object_without_properties(_param, [
    "arrow",
    "arrowHeight",
    "arrowPadding",
    "placement",
    "onPlacementChange",
    "disableFlipMiddleware",
    "trigger",
    "content",
    "hoverDelay",
    "closeAfterClick",
    "offsetByMainAxis",
    "offsetByCrossAxis",
    "sameWidth",
    "hideWhenReferenceHidden",
    "disabled",
    "disableInteractive",
    "disableCloseOnClickOutside",
    "disableCloseOnEscKey",
    "keepMounted",
    "customMiddlewares",
    "defaultShown",
    "shown",
    "onShownChange",
    "onShownChanged",
    "usePortal",
    "arrowProps",
    "ArrowIcon",
    "autoFocus",
    "restoreFocus",
    "className",
    "children",
    "noStyling",
    "zIndex",
    "role"
  ]);
  const [arrowRef, setArrowRef] = React250.useState(null);
  const { middlewares, strictPlacement } = useFloatingMiddlewaresBootstrap({
    arrow: withArrow,
    arrowRef,
    arrowHeight,
    arrowPadding,
    placement: expectedPlacement,
    offsetByMainAxis,
    offsetByCrossAxis,
    sameWidth,
    hideWhenReferenceHidden,
    disableFlipMiddleware,
    customMiddlewares
  });
  const { placement: resolvedPlacement, shown, willBeHide, refs, referenceProps, floatingProps, middlewareData, onClose, onRestoreFocus, onEscapeKeyDown } = useFloatingWithInteractions({
    middlewares,
    placement: strictPlacement,
    trigger,
    hoverDelay,
    closeAfterClick,
    disabled,
    disableInteractive,
    disableCloseOnClickOutside,
    disableCloseOnEscKey,
    defaultShown,
    shown: shownProp,
    onShownChange,
    onShownChanged
  });
  usePlacementChangeCallback(expectedPlacement, resolvedPlacement, onPlacementChange);
  const [, child] = usePatchChildren(children, injectAriaExpandedPropByRole(referenceProps, shown, role), refs.setReference);
  let popover = null;
  if (shown || keepMounted) {
    const hidden = keepMounted && !shown;
    let arrow4 = null;
    if (withArrow) {
      const { arrow: arrowCoords } = middlewareData;
      arrow4 = (0, import_jsx_runtime229.jsx)(FloatingArrow, _object_spread_props(_object_spread({
        iconClassName: noStyling ? void 0 : "vkuiPopover__arrow"
      }, arrowProps), {
        coords: arrowCoords,
        placement: resolvedPlacement,
        getRootRef: setArrowRef,
        Icon: ArrowIcon2
      }));
    }
    popover = (0, import_jsx_runtime229.jsx)(AppRootPortal, {
      usePortal,
      children: (0, import_jsx_runtime229.jsx)("div", _object_spread_props(_object_spread({
        ref: refs.setFloating,
        className: clsx("vkuiPopover", hidden && "vkuiPopover--hidden")
      }, floatingProps), {
        style: _object_spread({
          zIndex: !hidden ? zIndex : void 0
        }, floatingProps.style),
        children: (0, import_jsx_runtime229.jsxs)(FocusTrap, _object_spread_props(_object_spread({}, restPopoverProps), {
          role,
          className: clsx("vkuiPopover__in", noStyling ? void 0 : "vkuiPopover__in--withStyling", willBeHide ? animationFadeClassNames.out : animationFadeClassNames.in, transformOriginClassNames[resolvedPlacement], className),
          mount: !hidden,
          disabled: hidden,
          autoFocus: disableInteractive ? false : autoFocus,
          restoreFocus: restoreFocus ? () => onRestoreFocus(restoreFocus) : false,
          onClose: onEscapeKeyDown,
          children: [
            arrow4,
            typeof content === "function" ? content({
              onClose
            }) : content
          ]
        }))
      }))
    });
  }
  return (0, import_jsx_runtime229.jsxs)(React250.Fragment, {
    children: [
      child,
      popover
    ]
  });
};

// node_modules/@vkontakte/vkui/dist/components/NavIdContext/useNavId.js
var React251 = __toESM(require_react());
var useNavId = () => ({
  view: React251.useContext(NavViewIdContext),
  panel: React251.useContext(NavPanelIdContext)
});

// node_modules/@vkontakte/vkui/dist/lib/removeObjectKeys.js
function removeObjectKeys(obj, keys = []) {
  let newObj = _object_spread({}, obj);
  keys.forEach((key) => delete newObj[key]);
  return newObj;
}

// node_modules/@vkontakte/vkui/dist/lib/SSR.js
var import_jsx_runtime230 = __toESM(require_jsx_runtime());
var React252 = __toESM(require_react());
var SSRWrapper = ({ userAgent, browserInfo, children }) => {
  if (!browserInfo && userAgent) {
    browserInfo = computeBrowserInfo(userAgent);
  }
  const dom = useObjectMemo(getDOM());
  return (0, import_jsx_runtime230.jsx)(ConfigProviderOverride, {
    platform: platform(browserInfo),
    children: (0, import_jsx_runtime230.jsx)(DOMContext.Provider, {
      value: dom,
      children
    })
  });
};

// node_modules/@vkontakte/vkui/dist/helpers/avatar.js
function calcInitialsAvatarColor(objectId) {
  return objectId % 6 + 1;
}

// node_modules/@vkontakte/vkui/dist/components/View/ViewInfinite.js
var import_jsx_runtime231 = __toESM(require_jsx_runtime());
var React253 = __toESM(require_react());
var warn25 = warnOnce("ViewInfinite");
var scrollsCache2 = {};
var _React_Component;
var ViewInfiniteComponent = class extends (_React_Component = React253.Component) {
  get document() {
    return this.props.document;
  }
  get window() {
    return this.props.window;
  }
  get panels() {
    return React253.Children.toArray(this.props.children);
  }
  componentWillUnmount() {
    const id = getNavId(this.props);
    if (id) {
      scrollsCache2[id] = this.scrolls;
    }
    if (this.animationFinishTimeout) {
      clearTimeout(this.animationFinishTimeout);
    }
  }
  componentDidUpdate(prevProps, prevState) {
    if (prevProps.activePanel !== this.props.activePanel && !prevState.swipingBack && !prevState.browserSwipe) {
      var _this_props_scroll;
      let isBack = false;
      if (this.props.isBackCheck) {
        isBack = this.props.isBackCheck({
          from: prevProps.activePanel,
          to: this.props.activePanel
        });
      } else {
        const firstLayerId = this.panels.map((panel) => getNavId(panel.props, warn25)).find((id) => id === prevProps.activePanel || id === this.props.activePanel);
        isBack = firstLayerId === this.props.activePanel;
      }
      this.blurActiveElement();
      const prevScrolls = this.scrolls[prevProps.activePanel] || [];
      const scrolls = _object_spread_props(_object_spread({}, this.scrolls), {
        [prevProps.activePanel]: [
          ...prevScrolls,
          (_this_props_scroll = this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.getScroll({
            compensateKeyboardHeight: false
          }).y
        ]
      });
      this.scrolls = scrolls;
      if (this.shouldDisableTransitionMotion()) {
        this.flushTransition(prevProps.activePanel, isBack);
      } else {
        this.setState({
          visiblePanels: [
            prevProps.activePanel,
            this.props.activePanel
          ],
          prevPanel: prevProps.activePanel,
          nextPanel: this.props.activePanel,
          activePanel: null,
          animated: true,
          isBack
        });
      }
    }
    if (prevProps.activePanel !== this.props.activePanel && prevState.swipingBack) {
      const nextPanel = this.state.swipeBackNextPanel;
      const prevPanel = this.state.swipeBackPrevPanel;
      let scrollPosition = void 0;
      this.scrolls = _object_spread({}, this.scrolls);
      if (prevPanel !== null) {
        const prevPanelScrolls = [
          ...this.scrolls[prevPanel] || []
        ].slice(0, -1);
        this.scrolls[prevPanel] = prevPanelScrolls;
      }
      if (nextPanel !== null) {
        const newPanelScrolls = [
          ...this.scrolls[nextPanel] || []
        ];
        scrollPosition = newPanelScrolls.pop();
        this.scrolls[nextPanel] = newPanelScrolls;
      }
      this.setState({
        swipeBackPrevPanel: null,
        swipeBackNextPanel: null,
        swipingBack: false,
        swipeBackResult: null,
        swipeBackStartX: 0,
        swipeBackShift: 0,
        activePanel: nextPanel,
        visiblePanels: [
          nextPanel
        ]
      }, () => {
        var _this_props_scroll2;
        (_this_props_scroll2 = this.props.scroll) === null || _this_props_scroll2 === void 0 ? void 0 : _this_props_scroll2.scrollTo(0, scrollPosition);
        prevProps.onTransition && prevProps.onTransition({
          isBack: true,
          from: prevPanel,
          to: nextPanel
        });
      });
    }
    if (!prevState.swipeBackResult && this.state.swipeBackResult) {
      this.waitTransitionFinish(this.pickPanel(this.state.swipeBackNextPanel), this.swipingBackTransitionEndHandler);
    }
    if (prevState.swipeBackResult === "fail" && !this.state.swipeBackResult && this.state.activePanel !== null) {
      var _this_props_scroll1;
      const newPanelScrolls = [
        ...this.scrolls[this.state.activePanel] || []
      ];
      const scrollPosition = newPanelScrolls.pop();
      this.scrolls = _object_spread_props(_object_spread({}, this.scrolls), {
        [this.state.activePanel]: newPanelScrolls
      });
      (_this_props_scroll1 = this.props.scroll) === null || _this_props_scroll1 === void 0 ? void 0 : _this_props_scroll1.scrollTo(0, scrollPosition);
    }
    if (prevProps.activePanel !== this.props.activePanel && this.state.browserSwipe) {
      this.setState({
        browserSwipe: false,
        nextPanel: null,
        prevPanel: null,
        animated: false,
        visiblePanels: [
          this.props.activePanel
        ],
        activePanel: this.props.activePanel
      });
    }
  }
  shouldDisableTransitionMotion() {
    var _this_props_configProvider, _this_props_splitCol;
    return ((_this_props_configProvider = this.props.configProvider) === null || _this_props_configProvider === void 0 ? void 0 : _this_props_configProvider.transitionMotionEnabled) === false || !((_this_props_splitCol = this.props.splitCol) === null || _this_props_splitCol === void 0 ? void 0 : _this_props_splitCol.animate) || this.props.platform === "vkcom";
  }
  disposeTransition() {
    this.transitionDisposer();
    this.transitionDisposer = noop;
  }
  waitTransitionFinish(elem, eventHandler) {
    if (this.shouldDisableTransitionMotion()) {
      this.disposeTransition();
      this.transitionFinishTimeout = setTimeout(eventHandler);
    } else if (elem) {
      this.disposeTransition();
      elem.addEventListener("transitionend", eventHandler);
      this.transitionDisposer = () => {
        elem.removeEventListener("transitionend", eventHandler);
      };
    } else {
      if (this.transitionFinishTimeout) {
        clearTimeout(this.transitionFinishTimeout);
      }
      this.transitionFinishTimeout = setTimeout(eventHandler, this.props.platform === "android" || this.props.platform === "vkcom" ? 300 : 600);
    }
  }
  blurActiveElement() {
    var _this_document;
    if (typeof this.window !== "undefined" && ((_this_document = this.document) === null || _this_document === void 0 ? void 0 : _this_document.activeElement)) {
      this.document.activeElement.blur();
    }
  }
  pickPanel(id) {
    if (id === null) {
      return void 0;
    }
    return this.panelNodes[id];
  }
  flushTransition(prevPanel, isBack) {
    const activePanel = this.props.activePanel;
    const prevPanelScrolls = [
      ...this.scrolls[prevPanel] || []
    ].slice(0, -1);
    const newPanelScrolls = [
      ...this.scrolls[activePanel] || []
    ];
    const scrollPosition = isBack ? newPanelScrolls.pop() : 0;
    if (isBack) {
      this.scrolls = _object_spread_props(_object_spread({}, this.scrolls), {
        [prevPanel]: prevPanelScrolls,
        [activePanel]: newPanelScrolls
      });
    }
    this.setState({
      prevPanel: null,
      nextPanel: null,
      visiblePanels: [
        activePanel
      ],
      activePanel,
      animated: false,
      isBack
    }, () => {
      var _this_props_scroll;
      (_this_props_scroll = this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.scrollTo(0, isBack ? scrollPosition : 0);
      this.props.onTransition && this.props.onTransition({
        isBack,
        from: prevPanel,
        to: activePanel
      });
    });
  }
  onSwipeBackSuccess() {
    this.props.onSwipeBack && this.props.onSwipeBack();
  }
  onSwipeBackCancel() {
    this.props.onSwipeBackCancel && this.props.onSwipeBackCancel();
    this.setState({
      swipeBackPrevPanel: null,
      swipeBackNextPanel: null,
      swipingBack: false,
      swipeBackResult: null,
      swipeBackStartX: 0,
      swipeBackShift: 0
    });
  }
  calcPanelSwipeStyles(panelId) {
    if (!canUseDOM || !this.window) {
      return {};
    }
    const isPrev = panelId === this.state.swipeBackPrevPanel;
    const isNext = panelId === this.state.swipeBackNextPanel;
    if (!isPrev && !isNext || this.state.swipeBackResult) {
      return {};
    }
    let prevPanelTranslate = `${this.state.swipeBackShift}px`;
    let nextPanelTranslate = `${-50 + this.state.swipeBackShift * 100 / this.window.innerWidth / 2}%`;
    let prevPanelShadow = 0.3 * (this.window.innerWidth - this.state.swipeBackShift) / this.window.innerWidth;
    if (this.state.swipeBackResult) {
      return isPrev ? {
        boxShadow: `-2px 0 12px rgba(0, 0, 0, ${prevPanelShadow})`
      } : {};
    }
    if (isNext) {
      return {
        transform: `translate3d(${nextPanelTranslate}, 0, 0)`
      };
    }
    if (isPrev) {
      return {
        transform: `translate3d(${prevPanelTranslate}, 0, 0)`,
        boxShadow: `-2px 0 12px rgba(0, 0, 0, ${prevPanelShadow})`
      };
    }
    return {};
  }
  render() {
    const _this_props = this.props, { platform: platform3, activePanel: _1, splitCol, configProvider, history, id, nav, onTransition, onSwipeBack, onSwipeBackStart, onSwipeBackCancel, window: window2, document: document2, scroll, isBackCheck, className } = _this_props, restProps = _object_without_properties(_this_props, [
      "platform",
      "activePanel",
      "splitCol",
      "configProvider",
      "history",
      "id",
      "nav",
      "onTransition",
      "onSwipeBack",
      "onSwipeBackStart",
      "onSwipeBackCancel",
      "window",
      "document",
      "scroll",
      "isBackCheck",
      "className"
    ]);
    const { prevPanel, nextPanel, activePanel, isBack, animated, swipeBackPrevPanel, swipeBackNextPanel, swipeBackResult, swipingBack } = this.state;
    const panels = this.panels.filter((panel) => {
      const panelId = getNavId(panel.props, warn25);
      return panelId !== void 0 && this.state.visiblePanels.includes(panelId) || panelId === swipeBackPrevPanel || panelId === swipeBackNextPanel;
    }).sort((panel) => {
      const panelId = getNavId(panel.props, warn25);
      const isPrevPanel = panelId === prevPanel || panelId === swipeBackPrevPanel;
      const isNextPanel = panelId === nextPanel || panelId === swipeBackNextPanel;
      if (isNextPanel) {
        return swipingBack || this.state.isBack ? -1 : 1;
      }
      if (isPrevPanel) {
        return swipingBack || this.state.isBack ? 1 : -1;
      }
      return 0;
    });
    const disableAnimation = this.shouldDisableTransitionMotion();
    const iOSSwipeBackSimulationEnabled = !disableAnimation && platform3 === "ios" && (configProvider === null || configProvider === void 0 ? void 0 : configProvider.isWebView) && Boolean(onSwipeBack);
    return (0, import_jsx_runtime231.jsx)(NavViewIdContext.Provider, {
      value: id || nav,
      children: (0, import_jsx_runtime231.jsx)(Touch, _object_spread_props(_object_spread({
        Component: "section"
      }, restProps), {
        className: clsx("vkuiView", platform3 === "ios" && clsx("vkuiView--ios", "vkuiInternalView--ios"), !disableAnimation && this.state.animated && "vkuiView--animated", !disableAnimation && this.state.swipingBack && "vkuiView--swiping-back", disableAnimation && "vkuiView--no-motion", className),
        onMoveX: iOSSwipeBackSimulationEnabled ? this.handleTouchMoveXForIOSSwipeBackSimulation : platform3 === "ios" ? this.handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext : void 0,
        onEnd: iOSSwipeBackSimulationEnabled ? this.handleTouchEndForIOSSwipeBackSimulation : void 0,
        children: (0, import_jsx_runtime231.jsx)("div", {
          className: "vkuiView__panels",
          children: panels.map((panel) => {
            const panelId = getNavId(panel.props, warn25);
            const isPrev = panelId === prevPanel || panelId === swipeBackPrevPanel;
            const compensateScroll = isPrev || panelId === swipeBackNextPanel || panelId === nextPanel && isBack;
            const isTransitionTarget = animated && panelId === (isBack ? prevPanel : nextPanel);
            const scrollList = panelId && this.scrolls[panelId] || [];
            const scroll2 = scrollList[scrollList.length - 1] || 0;
            return (0, import_jsx_runtime231.jsx)("div", {
              className: clsx("vkuiView__panel", panelId === activePanel && "vkuiView__panel--active", panelId === prevPanel && "vkuiView__panel--prev", panelId === nextPanel && "vkuiView__panel--next", panelId === swipeBackPrevPanel && "vkuiView__panel--swipe-back-prev", panelId === swipeBackNextPanel && "vkuiView__panel--swipe-back-next", swipeBackResult === "success" && "vkuiView__panel--swipe-back-success", swipeBackResult === "fail" && "vkuiView__panel--swipe-back-failed"),
              onAnimationEnd: isTransitionTarget ? this.transitionEndHandler : void 0,
              ref: (el) => panelId !== void 0 && (this.panelNodes[panelId] = el),
              style: this.calcPanelSwipeStyles(panelId),
              children: (0, import_jsx_runtime231.jsx)("div", {
                className: "vkuiView__panel-in",
                style: {
                  marginTop: compensateScroll ? -scroll2 : void 0
                },
                children: (0, import_jsx_runtime231.jsx)(NavTransitionDirectionProvider, {
                  isBack: swipingBack || isBack,
                  children: (0, import_jsx_runtime231.jsx)(NavTransitionProvider, {
                    entering: panelId === nextPanel || panelId === swipeBackNextPanel,
                    children: panel
                  })
                })
              })
            }, panelId);
          })
        })
      }))
    });
  }
  constructor(props) {
    super(props), _define_property(this, "swipeBackPrevented", false), _define_property(this, "scrolls", scrollsCache2[getNavId(this.props, warn25)] || {}), _define_property(this, "transitionFinishTimeout", void 0), _define_property(this, "animationFinishTimeout", void 0), _define_property(this, "panelNodes", {}), _define_property(this, "transitionDisposer", noop), _define_property(this, "transitionEndHandler", () => {
      if (this.state.prevPanel !== null) {
        this.flushTransition(this.state.prevPanel, Boolean(this.state.isBack));
      }
    }), _define_property(this, "swipingBackTransitionEndHandler", (e) => {
      if (!e || e.propertyName.includes("transform") && e.target === this.pickPanel(this.state.swipeBackNextPanel)) {
        switch (this.state.swipeBackResult) {
          case "fail":
            this.onSwipeBackCancel();
            break;
          case "success":
            this.onSwipeBackSuccess();
        }
      }
    }), _define_property(this, "handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext", (event) => {
      if (this.state.browserSwipe) {
        return;
      }
      const { swipeBackTriggered, viewportStartEdgeTouched, viewportEndEdgeTouched } = getSwipeBackPredicates(event.startX, event.shiftX, this.window.innerWidth);
      if ((viewportStartEdgeTouched || viewportEndEdgeTouched) && swipeBackTriggered) {
        this.setState({
          browserSwipe: true
        });
      }
    }), _define_property(this, "handleTouchMoveXForIOSSwipeBackSimulation", (event) => {
      if (this.swipeBackPrevented || swipeBackExcluded(event)) {
        return;
      }
      const { swipedToOpposite, swipeBackTriggered, viewportStartEdgeTouched } = getSwipeBackPredicates(event.startX, event.shiftX, this.window.innerWidth);
      if (this.state.animated && swipeBackTriggered) {
        return;
      }
      if (!this.state.swipingBack && this.props.history && this.props.history.length > 1) {
        if (swipedToOpposite) {
          this.swipeBackPrevented = true;
          return;
        }
        if (!swipeBackTriggered) {
          return;
        }
        if (!viewportStartEdgeTouched && hasHorizontalScrollableElementWithScrolledToLeft(event.originalEvent.target)) {
          this.swipeBackPrevented = true;
          return;
        }
        if (this.props.onSwipeBackStart) {
          const payload = this.props.onSwipeBackStart(this.state.activePanel);
          if (payload === "prevent") {
            this.swipeBackPrevented = true;
            return;
          }
        }
        if (this.state.activePanel !== null) {
          var _this_props_scroll;
          this.blurActiveElement();
          const prevScrolls = this.scrolls[this.state.activePanel] || [];
          this.scrolls = _object_spread_props(_object_spread({}, this.scrolls), {
            [this.state.activePanel]: [
              ...prevScrolls,
              (_this_props_scroll = this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.getScroll().y
            ]
          });
        }
        this.setState({
          swipingBack: true,
          swipeBackStartX: event.startX,
          swipeBackPrevPanel: this.state.activePanel,
          swipeBackNextPanel: this.props.history.slice(-2)[0]
        });
      }
      if (this.state.swipingBack) {
        if (event.shiftX < 0) {
          this.setState({
            swipeBackShift: 0
          });
        } else if (event.shiftX > this.window.innerWidth - this.state.swipeBackStartX) {
          this.setState({
            swipeBackShift: this.window.innerWidth
          });
        } else {
          this.setState({
            swipeBackShift: event.shiftX
          });
        }
      }
    }), _define_property(this, "handleTouchEndForIOSSwipeBackSimulation", (event) => {
      this.swipeBackPrevented = false;
      if (this.state.swipingBack && this.window) {
        const speed = this.state.swipeBackShift / event.duration * 1e3;
        if (this.state.swipeBackShift === 0) {
          this.onSwipeBackCancel();
        } else if (this.state.swipeBackShift >= this.window.innerWidth) {
          this.onSwipeBackSuccess();
        } else if (speed > 250 || this.state.swipeBackShift >= this.window.innerWidth / 2) {
          this.setState({
            swipeBackResult: "success"
          });
        } else {
          this.setState({
            swipeBackResult: "fail"
          });
        }
      }
    });
    this.state = {
      animated: false,
      visiblePanels: [
        props.activePanel
      ],
      activePanel: props.activePanel,
      isBack: void 0,
      prevPanel: null,
      nextPanel: null,
      swipingBack: void 0,
      swipeBackStartX: 0,
      swipeBackShift: 0,
      swipeBackNextPanel: null,
      swipeBackPrevPanel: null,
      swipeBackResult: null,
      browserSwipe: false
    };
  }
};
_define_property(ViewInfiniteComponent, "defaultProps", {
  history: []
});
var ViewInfinite = withContext(withContext(withContext(withPlatform(withDOM(ViewInfiniteComponent)), SplitColContext, "splitCol"), ConfigProviderContext, "configProvider"), ScrollContext, "scroll");

export {
  clsx,
  useAdaptivity,
  Platform,
  platform,
  ConfigProviderContext,
  useConfigProvider,
  Appearance,
  useScrollLock,
  AppRoot,
  DisplayTitle,
  Title,
  Headline,
  Text,
  Paragraph,
  Subhead,
  Footnote,
  Caption,
  EllipsisText,
  UnstyledTextField,
  ViewWidth,
  ViewHeight,
  SizeType,
  getViewWidthByViewportWidth,
  getViewHeightByViewportHeight,
  usePlatform,
  Tappable,
  OnboardingTooltipContainer,
  FixedLayout,
  ImageBaseContext,
  getFallbackIconSizeByImageBaseSize,
  getBadgeIconSizeByImageBaseSize,
  getOverlayIconSizeByImageBaseSize,
  useAppearance,
  ImageBase,
  VisuallyHidden,
  Spinner,
  Button,
  IconButton,
  useAdaptivityConditionalRender,
  AdaptiveIconRenderer,
  ToolButton,
  useNavTransition,
  useNavDirection,
  Root,
  Touch,
  View,
  Panel,
  PanelHeaderButton,
  ModalRootContext,
  Separator,
  Spacing,
  PanelHeader,
  PanelHeaderContent,
  PanelHeaderContext,
  AppearanceProvider,
  SplitLayout,
  SplitCol,
  Epic,
  Tabbar,
  TabbarItem,
  ScrollArrow,
  HorizontalScroll,
  AspectRatio,
  Flex,
  SimpleGrid,
  PopoutWrapper,
  useAdaptivityWithJSMediaQueries,
  ModalDismissButton,
  Alert,
  ActionSheetItem,
  ActionSheetDefaultIosCloseItem,
  Popper,
  ActionSheet,
  ScreenSpinnerContext,
  ScreenSpinner,
  Snackbar,
  Tooltip,
  withPlatform,
  ModalRoot,
  useModalRootContext,
  withModalRootContext,
  useOrientationChange,
  ModalPage,
  ModalPageHeader,
  ModalCardBase,
  ModalCard,
  Badge,
  ContentBadge,
  ButtonGroup,
  Card,
  CardGrid,
  CardScroll,
  ContentCard,
  Header,
  Group,
  Gradient,
  List,
  SimpleCell,
  Cell,
  RichCell,
  CellButton,
  Avatar,
  HorizontalCell,
  HorizontalCellShowMore,
  Footer,
  InfoRow,
  animate2 as animate,
  Gallery,
  GridAvatar,
  Image,
  Progress,
  Search,
  Tabs,
  TabsItem,
  PullToRefresh,
  Link,
  Mark,
  OnboardingTooltip,
  Counter,
  UsersStack,
  Placeholder,
  Banner,
  MiniInfoCell,
  WriteBar,
  WriteBarIcon,
  SubnavigationBar,
  SubnavigationButton,
  usePagination,
  Pagination,
  Accordion,
  FormItem,
  FormField,
  FormLayoutGroup,
  FormStatus,
  Switch,
  File,
  DropZone,
  Input,
  Chip,
  ChipsInput,
  defaultFilterFn,
  CustomScrollView,
  CustomSelectOption,
  ChipsSelect,
  Slider,
  Textarea,
  SelectionControl,
  Radio2 as Radio,
  RadioGroup,
  Checkbox,
  CustomSelect,
  NativeSelect,
  Select,
  SelectMimicry,
  DatePicker,
  SegmentedControl,
  useTodayDate,
  AdaptivityProvider,
  Calendar,
  CalendarRange,
  DateInput,
  DateRangeInput,
  Skeleton,
  Div,
  PanelSpinner,
  PanelHeaderClose,
  PanelHeaderBack,
  PanelHeaderSubmit,
  PanelHeaderEdit,
  ConfigProvider,
  LocaleProvider,
  PlatformProvider,
  Popover,
  useNavId,
  removeObjectKeys,
  SSRWrapper,
  calcInitialsAvatarColor,
  ViewInfinite
};
//# sourceMappingURL=chunk-DPL2OPIY.js.map
